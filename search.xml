<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android studio快捷捷总结</title>
      <link href="/2018/11/29/Mac%E4%B8%8AAndroid%20studio%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/29/Mac%E4%B8%8AAndroid%20studio%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>现在日渐觉得快捷键使用的重要性了，对工作效率的提升以及code style很有帮助。然后在网上看到一个博客讲的非常详细，但是感觉有点乱，所以就基于这篇博客：<a href="https://blog.csdn.net/zq019/article/details/54618185" target="_blank" rel="noopener">史上最全的Android studio 的快捷键 MAC 和Win版本</a>进行总结归纳一下，也方便加深印象。</p><p>仔细看完发觉这些快捷键还是有规律的，很多都是键盘左下方那些功能键和一些字母的组合，并且字母很多情况下都是功能键所代表的功能英文名称的首字母，所以还是很好记的。下面就以在 mac 上的操作为</p><h3 id="command"><a href="#command" class="headerlink" title="command +"></a>command +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">AS配置界面</td><td style="text-align:left">Preferences</td><td style="text-align:left">command + ,</td><td style="text-align:left">control+alt+S</td></tr><tr><td style="text-align:left">工程项目配置界面</td><td style="text-align:left">Project Structure</td><td style="text-align:left">command + ;</td><td style="text-align:left">Control＋Alt+Shift+S</td></tr><tr><td style="text-align:left">注释选中代码</td><td style="text-align:left">Comment with Line Comment</td><td style="text-align:left">command + /</td><td style="text-align:left">ctrl + /</td></tr><tr><td style="text-align:left">代码折叠/展开</td><td style="text-align:left">Collapse/Expand</td><td style="text-align:left">command + 减号/加号</td><td style="text-align:left">ctrl + 减号/加号</td></tr><tr><td style="text-align:left">返回上次光标处</td><td style="text-align:left">略</td><td style="text-align:left">command + [</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">跳转到下次光标处</td><td style="text-align:left">略</td><td style="text-align:left">command + ]</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">文件方法结构</td><td style="text-align:left">File Structure</td><td style="text-align:left">command + F12</td><td style="text-align:left">ctrl + F12</td></tr><tr><td style="text-align:left">快捷向下复制行</td><td style="text-align:left">Duplicate Line or Block</td><td style="text-align:left">command + D</td><td style="text-align:left">ctrl + D</td></tr><tr><td style="text-align:left">快捷最近打开</td><td style="text-align:left">Recent Files</td><td style="text-align:left">command + E</td><td style="text-align:left">ctrl + E</td></tr><tr><td style="text-align:left">文件内查找</td><td style="text-align:left">Edit/Find/Find</td><td style="text-align:left">command + F</td><td style="text-align:left">ctrl + F</td></tr><tr><td style="text-align:left">按照模板生成代码</td><td style="text-align:left">Insert Live Template</td><td style="text-align:left">command + J</td><td style="text-align:left">ctrl + J</td></tr><tr><td style="text-align:left">定位到行</td><td style="text-align:left">Navigate/Line</td><td style="text-align:left">command + L</td><td style="text-align:left">ctrl + G</td></tr><tr><td style="text-align:left">快速构成代码</td><td style="text-align:left">Code Generate</td><td style="text-align:left">command + N</td><td style="text-align:left">alt + insert</td></tr><tr><td style="text-align:left">查找类</td><td style="text-align:left">Navigate/Class</td><td style="text-align:left">command + O</td><td style="text-align:left">ctrl + N</td></tr><tr><td style="text-align:left">提示参数类型</td><td style="text-align:left">Parameter Info</td><td style="text-align:left">command + P</td><td style="text-align:left">ctrl + P</td></tr><tr><td style="text-align:left">文件内替换</td><td style="text-align:left">Replace</td><td style="text-align:left">command + R</td><td style="text-align:left">ctrl + R</td></tr><tr><td style="text-align:left">跳转到父类</td><td style="text-align:left">Super method</td><td style="text-align:left">command + U</td><td style="text-align:left">ctrl + U</td></tr><tr><td style="text-align:left">关闭当前tab标签</td><td style="text-align:left">Close Editor Tabs</td><td style="text-align:left">command + W</td><td style="text-align:left">ctrl + shift + a</td></tr><tr><td style="text-align:left">删除行</td><td style="text-align:left">Delete Line</td><td style="text-align:left">command + delete</td><td style="text-align:left">ctrl + Y</td></tr><tr><td style="text-align:left">快速到行首/尾</td><td style="text-align:left">Move Caret to Line Start/End</td><td style="text-align:left">command + Left/Right</td><td style="text-align:left">ctrl + Left/Right</td></tr></tbody></table><h3 id="control"><a href="#control" class="headerlink" title="control +"></a>control +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">显示类关系继承体系</td><td style="text-align:left">Type Hierarchy</td><td style="text-align:left">control + H</td><td style="text-align:left">ctrl + H</td></tr><tr><td style="text-align:left">快速覆写方法</td><td style="text-align:left">override Methods</td><td style="text-align:left">control + O</td><td style="text-align:left">ctrl + O</td></tr><tr><td style="text-align:left">重构入口</td><td style="text-align:left">Refactor This</td><td style="text-align:left">control + T</td><td style="text-align:left">ctrl + alt + shift + T</td></tr></tbody></table><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift +"></a>Shift +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">重命名</td><td style="text-align:left">Rename</td><td style="text-align:left">shift + F6</td><td style="text-align:left">shift + F6</td></tr></tbody></table><h3 id="option"><a href="#option" class="headerlink" title="option +"></a>option +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">选择视图</td><td style="text-align:left">select in any view</td><td style="text-align:left">option + F1</td><td style="text-align:left">alt + F1</td></tr><tr><td style="text-align:left">扩大缩小选中范围</td><td style="text-align:left">Extend Selection/Shrink Selection</td><td style="text-align:left">option + UP/Down</td><td style="text-align:left">ctrl + W + shift + W</td></tr></tbody></table><h3 id="command-shift"><a href="#command-shift" class="headerlink" title="command + shift +"></a>command + shift +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">窗口内所有代码折叠/展开</td><td style="text-align:left">Collapse/Expand All</td><td style="text-align:left">command + shift + 减号/加号</td><td style="text-align:left">ctrl + shift + 减号/加号</td></tr><tr><td style="text-align:left">拷贝文件路径</td><td style="text-align:left">Copy Paths</td><td style="text-align:left">command + shift + C</td><td style="text-align:left">ctrl + shift + C</td></tr><tr><td style="text-align:left">最近修改的文件</td><td style="text-align:left">Recent edited file</td><td style="text-align:left">Command + Shift + E</td><td style="text-align:left">Ctrl + shift + enter</td></tr><tr><td style="text-align:left">全路径查找</td><td style="text-align:left">Find in Path</td><td style="text-align:left">command + shift + F</td><td style="text-align:left">ctrl + shift + F</td></tr><tr><td style="text-align:left">查找文件</td><td style="text-align:left">avigate/File</td><td style="text-align:left">command + shift + O</td><td style="text-align:left">ctrl + shift + N</td></tr><tr><td style="text-align:left">全路径中替换</td><td style="text-align:left">Replace in Path</td><td style="text-align:left">command + shift + R</td><td style="text-align:left">ctrl + shift + R</td></tr><tr><td style="text-align:left">大小写转换</td><td style="text-align:left">Toggle Case</td><td style="text-align:left">command + shift + U</td><td style="text-align:left">ctrl + shift + U</td></tr><tr><td style="text-align:left">显示粘贴版历史</td><td style="text-align:left">Paste from History</td><td style="text-align:left">command + shift + V</td><td style="text-align:left">ctrl + shift + V</td></tr><tr><td style="text-align:left">移动代码块</td><td style="text-align:left">Move Statement Up/Down</td><td style="text-align:left">command + shift + down/up</td><td style="text-align:left">ctrl + shift + down/up</td></tr><tr><td style="text-align:left">代码补全</td><td style="text-align:left">Complete Current Statement</td><td style="text-align:left">command + shift + enter</td><td style="text-align:left">ctrl + shift + enter</td></tr><tr><td style="text-align:left">返回光标最后编辑位置</td><td style="text-align:left">Last Edit Location</td><td style="text-align:left">command + shift + delete</td><td style="text-align:left">control + shift + Backspace</td></tr></tbody></table><h3 id="command-option"><a href="#command-option" class="headerlink" title="command + option +"></a>command + option +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">全局查找符号</td><td style="text-align:left">略</td><td style="text-align:left">command + option + O</td><td style="text-align:left">略</td></tr><tr><td style="text-align:left">格式化代码</td><td style="text-align:left">Reformat Code</td><td style="text-align:left">command + option + L</td><td style="text-align:left">ctrl + alt + L</td></tr><tr><td style="text-align:left">用代码模板包裹代码</td><td style="text-align:left">surround with Live Template</td><td style="text-align:left">command + option + J</td><td style="text-align:left">ctrl + alt + J</td></tr><tr><td style="text-align:left">if/try等包裹代码</td><td style="text-align:left">Surround With..</td><td style="text-align:left">command + option + T</td><td style="text-align:left">ctrl + alt + T</td></tr><tr><td style="text-align:left">多行注释</td><td style="text-align:left">Code/Comment</td><td style="text-align:left">command + option + /</td><td style="text-align:left">ctrl + alt + /</td></tr><tr><td style="text-align:left">抽取方法</td><td style="text-align:left">Extract Method</td><td style="text-align:left">command + option + M</td><td style="text-align:left">control+alt+M</td></tr><tr><td style="text-align:left">抽取变量</td><td style="text-align:left">Extract Variable</td><td style="text-align:left">command + option + V</td><td style="text-align:left">control+alt+V</td></tr><tr><td style="text-align:left">抽取字段</td><td style="text-align:left">Extract Field</td><td style="text-align:left">command + option + F</td><td style="text-align:left">control+alt+F</td></tr><tr><td style="text-align:left">抽取常量</td><td style="text-align:left">Extract Constant</td><td style="text-align:left">command + option + C</td><td style="text-align:left">control+alt+C</td></tr><tr><td style="text-align:left">抽取参数</td><td style="text-align:left">Extract Parameter</td><td style="text-align:left">command + option + P</td><td style="text-align:left">control+alt+P</td></tr><tr><td style="text-align:left">调到代码块首部/尾部</td><td style="text-align:left">Move Caret To Code Block</td><td style="text-align:left">Command + option +  [ 或者 ]</td><td style="text-align:left">Control+[ 或者 ]</td></tr></tbody></table><h3 id="option-shift"><a href="#option-shift" class="headerlink" title="option + shift +"></a>option + shift +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">向下移动一行</td><td style="text-align:left">Move Line Down</td><td style="text-align:left">option + shift + Down</td><td style="text-align:left">alt + shift + Down</td></tr><tr><td style="text-align:left">向上移动一行</td><td style="text-align:left">Move Line Up</td><td style="text-align:left">option + shift + Up</td><td style="text-align:left">alt + shift + Up</td></tr></tbody></table><h3 id="control-option"><a href="#control-option" class="headerlink" title="control + option +"></a>control + option +</h3><table><thead><tr><th style="text-align:left">功能描述</th><th style="text-align:left">keymap对应名字</th><th style="text-align:left">mac</th><th style="text-align:left">Win/Linux</th></tr></thead><tbody><tr><td style="text-align:left">去除无效包引用</td><td style="text-align:left">Optimize Imports</td><td style="text-align:left">control + option + O</td><td style="text-align:left">ctrl + alt + O</td></tr><tr><td style="text-align:left">查找调用的位置</td><td style="text-align:left">Call hierarchy</td><td style="text-align:left">control + option + H</td><td style="text-align:left">ctrl + alt + H</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlins初学记录</title>
      <link href="/2018/11/19/Kotlins%E5%88%9D%E5%AD%A6%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/11/19/Kotlins%E5%88%9D%E5%AD%A6%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="var和val的区别"><a href="#var和val的区别" class="headerlink" title="var和val的区别"></a>var和val的区别</h4><p>var是一个可变变量，可以通过重新分配来更改为另一个值的变量，这种声明变量的方式和java中声明变量的方式一样。</p><p>val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="区间范围"><a href="#区间范围" class="headerlink" title="区间范围"></a>区间范围</h4><ul><li><p>in a..b<br>表示[a, b]</p></li><li><p>in a until b<br>表示[a, b)</p></li></ul><h4 id="只读list"><a href="#只读list" class="headerlink" title="只读list"></a>只读list</h4><pre><code class="kotlin">val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code></pre><h4 id="Long类型显示加L"><a href="#Long类型显示加L" class="headerlink" title="Long类型显示加L"></a>Long类型显示加L</h4><p>如：</p><pre><code class="kotlin">Long a = 123L</code></pre><h4 id="浮点数默认为Double类型"><a href="#浮点数默认为Double类型" class="headerlink" title="浮点数默认为Double类型"></a>浮点数默认为Double类型</h4><p>Float 必须要用 f 或者 F 标记，如 123.5f</p><h4 id="kotlin数据类型"><a href="#kotlin数据类型" class="headerlink" title="kotlin数据类型"></a>kotlin数据类型</h4><p>kotlin中不存在基本数据类型，所有的东西都是对象；</p><p>几种表示数字的内置类型：Double、Float、Long、Int、Short、Char、Byte</p><h4 id="相等性和同一性"><a href="#相等性和同一性" class="headerlink" title="相等性和同一性"></a>相等性和同一性</h4><ul><li><p>相等性<br>即数值相等，对应于函数equals 或者 “==”</p></li><li><p>同一性<br>是否是用一个对象，对应于“===”</p></li></ul><h4 id="较小的类型不能够隐式转化为较大的类型"><a href="#较小的类型不能够隐式转化为较大的类型" class="headerlink" title="较小的类型不能够隐式转化为较大的类型"></a>较小的类型不能够隐式转化为较大的类型</h4><p>⚠️注意这一点是和 java 的区别<br>例如下面的代码就会报错：</p><pre><code class="kotlin">val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误</code></pre><p>我们可以显式转换来拓宽数字</p><pre><code class="kotlin">val i: Int = b.toInt() // OK：显式拓宽</code></pre><h4 id="Char类型不能直接当作数字"><a href="#Char类型不能直接当作数字" class="headerlink" title="Char类型不能直接当作数字"></a>Char类型不能直接当作数字</h4><h3 id="包与导入"><a href="#包与导入" class="headerlink" title="包与导入"></a>包与导入</h3><h4 id="可见性修饰符介绍"><a href="#可见性修饰符介绍" class="headerlink" title="可见性修饰符介绍"></a>可见性修饰符介绍</h4><p><a href="https://www.kotlincn.net/docs/reference/visibility-modifiers.html#%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Kotlin文档介绍</a></p><p>注意⚠️：Kotlin 中外部类不能访问内部类的 private 成员，这一点在java中可以</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><h4 id="If表达式"><a href="#If表达式" class="headerlink" title="If表达式"></a>If表达式</h4><p>if是一个表达式，即它会返回一个值</p><pre><code class="kotlin">// java用法if (a &gt; b) {    max = a} else {    max = b}// kotlin 中作为表达式val max = if (a &gt; b) a else b</code></pre><p>当然也可以想java那样当作代码块中的语句使用</p><p>但是，如果你使用 if 作为表达式而不是语句，该表达式需要有 else 分支，例如下面是语句就会报错：</p><pre><code class="kotlin">val max = if (a &gt; b) a</code></pre><h4 id="when表达式取代switch"><a href="#when表达式取代switch" class="headerlink" title="when表达式取代switch"></a>when表达式取代switch</h4><p>when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。</p><p>常见形式</p><p>作为控制快：</p><pre><code class="kotlin">when (x) {    1 -&gt; print(&quot;x == 1&quot;)    2 -&gt; print(&quot;x == 2&quot;)    else -&gt; { // 注意这个块        print(&quot;x is neither 1 nor 2&quot;)    }}</code></pre><p>作为表达式：</p><pre><code class="kotlin">val a = when (sign) {    1 -&gt; 1    2 -&gt; 2    else -&gt; 3}</code></pre><p>注意⚠️： 如果 when 作为一个表达式使用，则必须有 else 分支；</p><h4 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h4><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签</p><p>标签结合break和continue使用：</p><pre><code class="kotlin">loop@ for (i in 1..100) {    for (j in 1..100) {        if (……) break@loop    }}</code></pre><p>标签在内联函数的使用：</p><pre><code class="kotlin">fun foo() {    listOf(1, 2, 3, 4, 5).forEach {        if (it == 3) return // 非局部直接返回到 foo() 的调用者        print(it)    }    println(&quot;this point is unreachable&quot;)}</code></pre><p>为了只退出lambda表达式，像下面：</p><pre><code class="kotlin">fun foo() {    listOf(1, 2, 3, 4, 5).forEach lit@{        if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环        print(it)    }    print(&quot; done with explicit label&quot;)}</code></pre><p>简介版：标签与接受该 lambda 的函数同名。</p><pre><code class="kotlin">fun foo() {    listOf(1, 2, 3, 4, 5).forEach {        if (it == 3) return@forEach // 局部返回到该 lambda 表达式的调用者，即 forEach 循环        print(it)    }    print(&quot; done with implicit label&quot;)}</code></pre><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="主构造函数和次构造函数的区别"><a href="#主构造函数和次构造函数的区别" class="headerlink" title="主构造函数和次构造函数的区别"></a>主构造函数和次构造函数的区别</h4><p><a href="https://blog.csdn.net/xlh1191860939/article/details/79412319" target="_blank" rel="noopener">Kotlin的构造函数介绍</a></p><h4 id="不需要使用new关键字"><a href="#不需要使用new关键字" class="headerlink" title="不需要使用new关键字"></a>不需要使用new关键字</h4><pre><code class="kotlin">val rectangle = Rectangle(5.0, 2.0) // 不需要“new”关键字</code></pre><h4 id="扩展函数是静态解析的"><a href="#扩展函数是静态解析的" class="headerlink" title="扩展函数是静态解析的"></a>扩展函数是静态解析的</h4><p>扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。</p><p>我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如：</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {    open class C    class D: C()    fun C.foo() = &quot;c&quot;    fun D.foo() = &quot;d&quot;    fun printFoo(c: C) {        println(c.foo())    }    printFoo(D())}</code></pre><p>这个例子会输出 “c”，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。</p><h4 id="幕后属性的理解"><a href="#幕后属性的理解" class="headerlink" title="幕后属性的理解"></a>幕后属性的理解</h4><p><a href="https://zhuanlan.zhihu.com/p/27493630" target="_blank" rel="noopener">幕后字段和 field</a></p><p><a href="https://www.jianshu.com/p/69f5b8a46eba" target="_blank" rel="noopener">kotlin的幕后字段(backing field)的个人理解</a></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>faceu实习开发随记</title>
      <link href="/2018/11/19/faceu%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/"/>
      <url>/2018/11/19/faceu%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="2018-11-18"><a href="#2018-11-18" class="headerlink" title="2018/11/18"></a>2018/11/18</h3><h4 id="Android中visibility属性VISIBLE、INVISIBLE、GONE的区别"><a href="#Android中visibility属性VISIBLE、INVISIBLE、GONE的区别" class="headerlink" title="Android中visibility属性VISIBLE、INVISIBLE、GONE的区别"></a>Android中visibility属性VISIBLE、INVISIBLE、GONE的区别</h4><ul><li>可见（visible)</li></ul><p>XML文件：android:visibility=”visible”<br>Java代码：view.setVisibility(View.VISIBLE);</p><ul><li>不可见（invisible）</li></ul><p>XML文件：android:visibility=”invisible”<br>Java代码：view.setVisibility(View.INVISIBLE);</p><ul><li>隐藏（GONE）</li></ul><p>XML文件：android:visibility=”gone”<br>Java代码：view.setVisibility(View.GONE);</p><p>INVISIBLE 和 GONE 的主要区别是：<br>当控件 visibility 属性为 INVISIBLE 时，界面保留了 view 控件所占有的空间；<br>而控件属性为 GONE 时，界面则不保留 view 控件所占有的空间。</p><h4 id="Java基本数据类型的装箱与拆箱"><a href="#Java基本数据类型的装箱与拆箱" class="headerlink" title="Java基本数据类型的装箱与拆箱"></a>Java基本数据类型的装箱与拆箱</h4><p>这里拿int 和 Integer 作说明：<br>装箱过程是通过调用Integer的valueOf方法实现的，而拆箱过程是通过调用Integer的 intValue方法实现的；</p><p>Integer i = new Integer(xxx) 和 Integer i = xxx;这两种方式的区别：<br>最主要的区别是第一种方式不会处罚自动装箱的过程；</p><h3 id="2018-11-20"><a href="#2018-11-20" class="headerlink" title="2018/11/20"></a>2018/11/20</h3><p>Android SQlite 操作<br>sql命令</p><p>Kotlin还要继续学啊</p><h3 id="2018-11-24"><a href="#2018-11-24" class="headerlink" title="2018/11/24"></a>2018/11/24</h3><p>Android中广播的使用<br>使用广播检测网络变化</p><h3 id="2018-11-26"><a href="#2018-11-26" class="headerlink" title="2018/11/26"></a>2018/11/26</h3><p>git reset 三种用法总结</p><ul><li>git reset (–-mixed) HEAD~1<br>回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也不受影响)<br>git reset –-soft HEAD~1<br>回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响)<br>git reset –-hard HEAD~1<br>回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换</li></ul><p><code>--mixed</code> 和 <code>--soft</code>的区别在于<code>--mixed</code>相当于做了一次<code>git add</code> + <code>git commit</code>的逆操作;而<code>--soft</code>相当于做了一次<code>git commit</code>的拟操作<br><code>–-hard</code>会替换掉本地的文件；</p><h3 id="2018-11-28"><a href="#2018-11-28" class="headerlink" title="2018/11/28"></a>2018/11/28</h3><p>Kotlin静态属性以及静态方法理解与使用</p><h3 id="2018-11-29"><a href="#2018-11-29" class="headerlink" title="2018/11/29"></a>2018/11/29</h3><p>Android Studio快捷键总结<br>Rxjava学习</p><h3 id="2018-11-30"><a href="#2018-11-30" class="headerlink" title="2018/11/30"></a>2018/11/30</h3><p>okhttp 给提交的任务添加优先级<br>okhttp不支持给任务添加优先级，当我们有这个需求的时候，除了改okhttp的源码之外，可以考虑下面的思路</p><p>首先我们知道提交的到okhttp中执行的任务是不具备优先级的，所以我们可以自己定义一个具备优先级的任务把本来的任务包装起来，就好像想让几岁大的小孩排队就非常困难，但是如果有大人把小孩抱着，大人知道排队吧，这样间接达到的效果就是小孩排队了。这样外面的壳就具备优先级了，就可以在优先级队里里面排队了。</p><p>然后定义一个线程池，并且这个线程池的等待队列使用具有优先级的队列，优先级的逻辑根据自己的需要写，然后用这个线程池来代替okhttp本来的线程池</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Android中获取存储空间方法总结</title>
      <link href="/2018/11/07/%E5%9C%A8Android%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/07/%E5%9C%A8Android%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在最近的项目中需要获取android设备的存储空间大小，完成了就好好总结一下，以及遇到的一些坑。</p><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>首先需要弄懂几个很混淆的概念，内存、内部存储，外部存储。</p><ul><li>内存，英文中称作memory；</li><li>内部存储，英文中称作InternalStorage；</li><li>外部存储，英文中称作ExternalStorage；</li></ul><p>就贴一篇博客了，讲的非常清楚，还说明了在不同 android 版本中有什么差别;<br><a href="https://blog.csdn.net/u010937230/article/details/73303034/" target="_blank" rel="noopener">彻底搞懂Android文件存储—内部存储，外部存储以及各种存储路径</a></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MAC环境下apk反编译方法</title>
      <link href="/2018/11/06/MAC%E7%8E%AF%E5%A2%83%E4%B8%8Bapk%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/06/MAC%E7%8E%AF%E5%A2%83%E4%B8%8Bapk%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><ul><li>apktool:  <a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">apktool下载链接</a><br>下载最新版本的jar包即可；</li><li>dex2jar: <a href="https://sourceforge.net/projects/dex2jar/files/" target="_blank" rel="noopener">dex2jar下载链接</a><br>下载最新版本的zip包即可；</li><li>jd-gui: <a href="http://jd.benow.ca/" target="_blank" rel="noopener">JD-GUI下载链接</a><br>下载最新的Releases版本for OX;</li></ul><h2 id="反编译过程与排坑"><a href="#反编译过程与排坑" class="headerlink" title="反编译过程与排坑"></a>反编译过程与排坑</h2><p>首先可以将上面下载的三个包放到同一个文件夹里面（非必须，只是方便操作）；然后解压<code>dex2jar</code>以及<code>jd-gui</code>，然后便将你需要反编译的apk文件放入上面该文件夹中，这里我要反编译的apk名字为<code>BTcar.apk</code>，下面输入命令的时候对应输入你的apk文件名；</p><p><img src="http://dengw.xyz/20181107105318.png" alt=""></p><h3 id="apktool反编译apk得到图片、XML配置、语言资源等文件"><a href="#apktool反编译apk得到图片、XML配置、语言资源等文件" class="headerlink" title="apktool反编译apk得到图片、XML配置、语言资源等文件"></a>apktool反编译apk得到图片、XML配置、语言资源等文件</h3><p>打开命令行跳转到该目录下，执行如下命令：</p><pre><code>java -jar apktool_2.3.4.jar d -f BTcar.apk -o BTCar</code></pre><p>其中， <code>apktool_2.3.4.jar</code>为我使用的<code>apktool</code>的apk包名，<code>BTCar</code>为生成的文件夹名，输入命令后的结果如图：<br><img src="http://dengw.xyz/20181107110350.png" alt=""></p><p>结果：<br><img src="http://dengw.xyz/20181107110549.png" alt=""></p><p>这个BTCar文件夹为反编译生成的各种资源文件；</p><h3 id="dex2jar反编译apk得到Java源代码"><a href="#dex2jar反编译apk得到Java源代码" class="headerlink" title="dex2jar反编译apk得到Java源代码"></a>dex2jar反编译apk得到Java源代码</h3><p>将要反编译的APK后缀名改为.zip，并解压，得到classes.dex文件；这里有一个坑就是使用系统自带的解压工具解压不能够成功，会生成如下的文件；</p><p><img src="http://dengw.xyz/20181107110731.png" alt=""><br><img src="http://dengw.xyz/20181107110811.png" alt=""></p><p>一种解决方法就是在 appStore 上下载一个叫做<code>The Archiver</code>的解压工具，然后就可以成功解压，生成<code>BTCar-1</code>文件夹：<br><img src="http://dengw.xyz/20181107110825.png" alt=""></p><p>打开该文件夹就可以看到需要的<code>class.dex</code>文件：<br><img src="http://dengw.xyz/20181107110854.png" alt=""></p><p>将获取到的<code>classes.dex</code>放到之前解压出来的工具<code>dex2jar</code>文件夹内，然后在<code>dex2jar</code>文件夹内打开终端输入命令<code>./d2j-dex2jar.sh classes.dex</code>，这个地方的一个坑就是可能会出现<code>Permission Denied</code>异常：<br><img src="http://dengw.xyz/20181107110912.png" alt=""></p><p>关于如何在mac中修改文件权限可以参考这篇博客：<a href="https://blog.csdn.net/x1876631/article/details/70162009/" target="_blank" rel="noopener">mac 查看、修改文件权限的命令</a>，也可以直接使用下面的方法修改文件权限，一般报的哪个文件就修改对应文件权限即可，例如：</p><pre><code>zsh: permission denied: ./d2j-dex2jar.sh</code></pre><p>然后就在终端输入：</p><pre><code>chmod 777 d2j-dex2jar.sh</code></pre><p>所有文件的权限修改成功过后再执行<code>./d2j-dex2jar.sh classes.dex</code>，生成<code>classes-dex2jar.jar</code>:<br><img src="http://dengw.xyz/20181107110936.png" alt=""></p><h3 id="使用jd-gui工具查看java代码"><a href="#使用jd-gui工具查看java代码" class="headerlink" title="使用jd-gui工具查看java代码"></a>使用jd-gui工具查看java代码</h3><p>在得到classes-dex2jar.jar文件之后，就可以使用jd-gui工具查看源码了。这里另外一个坑就是如果你的Java版本大于Java 8的话是运行不了jd-gui，解决方法可以参考这篇博客：<a href="https://blog.csdn.net/YoungStunner/article/details/78699864" target="_blank" rel="noopener">Mac上的jd-gui不能使用（打开）</a>，上面有很详细的解决方法。解决后就可以使用jd-gui工具查看java源代码了。<br><img src="http://dengw.xyz/20181107110955.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apk反编译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发2018年互联网秋招总结</title>
      <link href="/2018/09/30/Android%E5%BC%80%E5%8F%912018%E5%B9%B4%E4%BA%92%E8%81%94%E7%BD%91%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/30/Android%E5%BC%80%E5%8F%912018%E5%B9%B4%E4%BA%92%E8%81%94%E7%BD%91%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>8月20号左右从美图离职参加秋招到今天9月30号，从8月20号参加阿里的一面到9月26号头条的三面，一个多月的互联网秋招对我来说差不多就结束了，现在来看，感受很深，失落过，焦虑过，挫败过，不过好在最后的结局让人满意，超过了秋招开始时候的预期目标，所以本文的基调还是轻松的，主要讲讲自己对秋招的总结。</p><h3 id="面试情况"><a href="#面试情况" class="headerlink" title="面试情况"></a>面试情况</h3><p>公司我投的倒是挺多的，除了阿里和金山wps都是正式批，有十多二十个吧，都通过了简历筛选，这儿要感谢我鸭大，以及高中的时候努力的自己，下面列一下详细的进度情况：</p><ul><li><strong>阿里</strong>：二面挂，阿里真的挺可惜的，实习离职第二天就收到面试电话了，奈何时间紧准备不充分；</li><li><strong>金山wps</strong>：hr面后无消息，当时说是一周内给消息的，然后到现在快一个月了也还没消息，可能是要价太高，排名又低，被淘汰了；</li><li><strong>虎牙</strong>：二面挂；虎牙其实是我最开始秋招的时候给自己定的目标之一，在广州，技术氛围和待遇上也挺满意的，可惜二面没过，当时也非常失落。不过虎牙面试过程中也让自己明白当时还存在的一些不足，数据结构和计算机网络的部分，这对后来头条的面试帮助非常大。这儿我的一点感触就是对于大多数人来说秋招是一个持久战，一次失败对整个秋招的影响不会很大，但是如果你能够从这次失败中发现自己的问题，那对整个秋招的帮助就非常大了，所以对于失败要善于总结，发现了问题一定要及时解决和补救，眼光要长远一点，不要太纠结一次的得失。</li><li><strong>爱奇艺</strong>：笔试后无消息，好像同批次笔试的都没有收到消息；</li><li><strong>bigo</strong>：一面挂；</li><li><strong>超有爱</strong>：笔试挂，因为最开始很想回成都去，百词斩真的挺想去的，但是要求也真的很高，1一个小时3道笔试题我通过了2.5道都没有面试机会，挺遗憾的。</li><li><strong>京东</strong>：笔试挂；</li><li><strong>欢聚时代</strong>：一面挂，这个我真的很想多说几句，一面面试完面试官亲口给我说：我这儿你过了，今天没有复试安排，复试会有邮件通知的，然而等了一周收到不适合的邮件2333，到这儿投的yy系的三个公司全部扑街；</li><li><strong>CVTE</strong>：hr面后无消息；</li><li><strong>触宝</strong>：拿到offer，到手的第一个offer，虽然说现在来看应该不会去了，不过当时拿到offer的时候真的非常开心，后面面试心态也更轻松，没有那么焦虑，真的非常感谢触宝对我的认可；</li><li><strong>网易</strong>：一面挂；网易感觉很奇怪，笔试的时候只做了半个小时就放弃直接交卷了然而都还给了我面试机会，面试的时候感觉表现很好却没有过2333；</li><li><strong>招银网络</strong>：时间冲突放弃了笔试；</li><li><strong>微众</strong>：一面挂；聊的挺好的，不过我感觉自己挺傻的，前面面试官先问我最近在面哪些公司啊，然后我说百度三面了（我这样原本是打算拔高自己的形象的，毕竟百度能够面到三面还是挺不容易的，哪知道给自己挖了一个坑），最后面试官就问了我一个问题：如果我现在直接给你发offer你会来微众吗？然后我诚实地说了如果百度三面过了应该会去百度，毕竟bat嘛，接着就和面试官讨论起平台，愉快地结束面试。然后回来就没收到任何消息了，事后想想真的觉得自己傻，欠缺面试经验吧；</li><li><strong>百度</strong>：拿到offer；完完全全的三轮技术面，前两轮表现得挺好，第三轮答得不好以为过不了，感谢百度给了我一个学习的机会；</li><li><strong>vivo</strong>：拿到offer，感觉vivo的流程是最快的，下午六点面试，一轮技术一轮hr面，晚上就收到offer了，</li><li><strong>头条</strong>：已确定拿到实习offer，正式offer已经在流程中，说到头条觉得自己真的挺幸运，最开始走的校招流程，做了一次笔试，5道题应该ac了3.5道左右，奈何其他人太强了，笔试没过，然后觉得自己太菜打算放弃秋招了（投简历的时候手里还一个offer都没有），先找个实习的offer然后准备明年春招，然后就投了头条的实习岗位。可能是因为现在投实习岗的不多所以就没有笔试，直接进入面试，3论技术面，运气又比较好，每一轮只有一道手撕算法题，一道是双栈实现队列，一道是二叉树的层次遍历，最后一道挺难的，求一个矩阵中最大子矩阵的和（一道动态规划的题，和求一个数组的最大子数组的最大和挺像的，不过要求了时间复杂度为O(n^3)，所以要考虑降维），都做出来了。第三面的时候有一个场景题，让设计一个登陆模块，其中一个要求是实现第二次登陆免登陆。我最开始给出的方案是使用 SharedPerfences 将第一次登陆输入的账号和密码保存到本地，下次登陆的时候直接去读取然后自动登陆，面试官说把安全性怎么办，然后我说使用一些加密算法将密码进行加密？面试还是不满意，问我还有没有其他的方法。然后仔细想了一下，突然想到上次虎牙面试的时候面试官问到的 cookie 的作用原理，当时没有回答上，下来很仔细地学习了一下，然后发现 cookie 可以适用于这个场景，说完面试官还算满意。另外一点是面试官还问了我关于B+树的一些问题，给了我一个场景让我画出分裂图，这儿又要感谢虎牙的面试了，因为一直觉得 B+ 树在数据库的索引部分中用的比较多，而移动开发一般不会问数据库的问题，但是之前虎牙的面试官把B+树当作数据结构的题来问了，虎牙面试完又很仔细地学习了一下B+树，所以准备真的很重要。三面后半个小时就接到hr的电话了，更让我惊喜的是说觉得我面试过程中表现得还行，能够帮我申请正式offer，现在已经在流程中了；</li><li><strong>腾讯</strong>：一面挂；</li><li><strong>酷狗</strong>：现在还没开始应该会直接放弃了；</li><li><strong>小米</strong>：通知去武汉面试太远直接放弃了；</li><li><strong>新浪</strong>：通知去成都面试，国庆正好要回老家有时间的话就去一下吧；</li><li><strong>华为</strong>：通知去面试了，到时候人在广州就去一下吧；</li><li><strong>oppo</strong>；广州场还没开始，到时候去试一下吧，因为有成都的岗位，观望一下；</li></ul><h3 id="秋招心得"><a href="#秋招心得" class="headerlink" title="秋招心得"></a>秋招心得</h3><p>从上面可以看到，我投了很多公司，也挂了非常多，前半段时间基本上面一个挂一个，很菜，信心也被打击过。不过后来能收获一个比较完美的结局，除开运气之外我觉得还是有一些个人原因吧，希望对大家有所帮助：</p><ul><li>个人心态</li></ul><p>心态真的很重要，心态不好的话整天忧心忡忡的，晚上睡不好觉，白天复习效果不好。我整个秋招基本上很少或者基本上没有失眠过，前半段时间面一个挂一个也没有失眠，我现在记得的一次失眠是收到百度录用短信通知第二天去面试那晚，激动地睡不着。也不要抱怨，不要太在意得失，笔试面试没过自身肯定是有原因的，你要做的就是好好弥补，发现问题就能进步了嘛，何必忧心忡忡呢是吧。</p><ul><li>基础扎实，技术要有深度：</li></ul><p>我学习android的时间不长，到现在也就8、9个月，还是本科生，所以相比那些学了两、三年的人来说肯定是有劣势的，像什么插件化、热修复、RN、Flutter这些根本就没有碰过。在我离职前我半开玩笑地问我的leader，我说我这些东西都不会是不是找不到工作了啊，他说，其实你不用太纠结，这些东西最多是一些加分项，而不是必须项，很多大厂更看重的还是基础。这些话对我很受益，如果当时没问他的话我肯定会把花时间去学习这些东西，而不是把重心放在基础知识的复习上，这样又学不深，基础有没有得到巩固，反而得不偿失。<br>对于基础知识，像操作系统，计算机网络，数据结构与算法、java相关的，android相关的，一定要做到非常熟悉，一些加分项不会只是不会加分，但是一些必须项不会的话肯定是会减分的，举个例子，Android 中 Activity的生命周期问题，你问每个学习 Android 的肯定都知道一些，我面试的时候也被问过很多次，变着花样来问你，可以像下面这样问：</p><blockquote><p>按下 home 键 activity的生命周期变化；<br>按下 back 键 activity的生命周期变化；<br>息屏时 activity的生命周期变化；<br>启动一个透明 Activity 时当前活动的生命周期变化；<br>旋转屏幕时未设置 configureChanges 参数时 activity 的生命周期变化；<br>旋转屏幕时设置了 configureChanges 参数时 activity 的生命周期变化；</p></blockquote><p>上面列的一些问题有一些共性，情景很多但是本质差别不大，面试的时候如果你之前都遇到过那还好说，没遇到过那就只有靠自己分析了。</p><p>说完基础，另外一点就是技术深度了，个人感觉对于应届生来说主要体现在源码的掌握程度上，虽然我现在学习的Android的时间不是很长，但是对于一些接触频率很高源码还是有掌握的，比如常见容器的源码我有一次面试就是叫我写一下 HashMap 添加元素源码，感觉如果平时没看过的话即使知道添加元素的过程也很难下笔。再者就是 Android 中 Activity 的启动过程的源码、View绘制与添加的源码以及一些经常使用第三方框架，Butterknife、EventBus、Rxjava、okHttp、Retrofit也要看一看，如果直接看源代码感觉很困难可以结合一些博客看一下关键性代码。</p><p>最后就是你写在简历上的东西自己一定要非常清楚，不要为了简历好看而给自己挖坑，到时候就得不偿失了。项目细节面试官一般都会深挖的，不过可能是面试官看我的项目太菜了，只是很简单地问了一下。</p><ul><li>学会总结：</li></ul><p>是要在一次面试完之后根据这次的面试情况及时总结，一次面试可以暴露出很多问题的，一次面试也是很好的反馈，这个在上面具体的面试情况里也说了这一点，我个人觉得这一点真的挺重要的，面试也是学习的过程，如果能够把一个个问题都解决了，那最后就是学到了嘛。发现问题，解决问题。</p><ul><li>表达清晰，逻辑清楚：</li></ul><p>这一点可以看作是个人软实力的一种体现吧，其实我在平时生活中的表达能力真算不上好，普通话也不算特别标准，但是一到面试的时候，对于接下来自己要说总能够很好的组织，然后表达，最开始我都没注意到这点的，在百度二面的时候二十分钟就问完了，当面试官说我问的差不多了的时候，我都有点蒙，说这么快？因为感觉百度二面二十多分钟就结束了感觉是要凉了啊，然后面试官说我一共问了你十五个问题，你回答的时候逻辑很清晰，说的很完整，表达的也很清楚，回答的挺好的，我这儿会把面试结果反馈上去，如果通过的话会给你发通知的，晚上就收到二面通过准备三面的通知。从这儿我觉得能够好好地表达确实会为面试加分不少。这一点其实平时也是可以准备的，对于一些很常规的问题，比如让你抽象类和接口的区别，这个问题应该面试java或者Android的都会遇到吧，我都是会像下面这样回答的，说的很全面，不容易遗漏，不过你回答得时候不要表现得有很明显背的痕迹，这个需要注意一下；</p><blockquote><p>首先从个体层面来说：<br>抽象类不能被实例化，而接口可以；<br>抽象类可以继承类或者实现接口，而接口只能够实现接口</p></blockquote><blockquote><p>从成员变量的角度来说：<br>接口只能够具有静态常量，而抽象类则没有限制，可以具有和普通类一样的成员变量；</p></blockquote><blockquote><p>从类函数来说：<br>抽象类可以有类构造器，接口没有；<br>抽象类可以有main方法，接口没有；<br>抽象类中可以具有抽象方法和非抽象方法，接口中只有抽象方法；<br>抽象类中的抽象方法可以除private之外的任意方法修饰符，接口中只可以为public和默认（和public一致）的</p></blockquote><blockquote><p>从子类的角度来说来说：<br>子类只能继承一个抽象类，但可以实现多个接口；</p></blockquote><blockquote><p>从访问速度上来说（寻找成员方法）：<br>抽象类更快，接口更慢；（主要是从方法表的角度进行考虑的）</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用的git命令清单</title>
      <link href="/2018/09/24/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
      <url>/2018/09/24/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h3><p>在当前目录新建一个Git代码库</p><ul><li>git init</li></ul><p>新建一个目录，将其初始化为Git代码库</p><ul><li>git init [project-name]</li></ul><p>下载一个项目和它的整个代码历史</p><ul><li>git clone [url]</li></ul><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><p>显示当前的Git配置</p><ul><li>git config –list</li></ul><p>编辑Git配置文件</p><ul><li>git config -e [–global]</li></ul><p>设置提交代码时的用户信息</p><ul><li>git config [–global] user.name “[name]”</li><li>git config [–global] user.email “[email address]”</li></ul><h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><p>添加指定文件到暂存区</p><ul><li>git add [file1] [file2] …</li></ul><p>添加指定目录到暂存区，包括子目录</p><ul><li>git add [dir]</li></ul><p>添加当前目录的所有文件到暂存区</p><ul><li>git add .</li></ul><p>删除工作区文件，并且将这次删除放入暂存区</p><ul><li>git rm [file1] [file2] …</li></ul><p>停止追踪指定文件，但该文件会保留在工作区</p><ul><li>git rm –cached [file]</li></ul><p>改名文件，并且将这个改名放入暂存区</p><ul><li>git mv [file-original] [file-renamed]</li></ul><h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h3><p>提交暂存区到仓库区</p><ul><li>git commit -m [message]</li></ul><p>提交暂存区的指定文件到仓库区</p><ul><li>git commit [file1] [file2] … -m [message]</li></ul><p>提交工作区自上次commit之后的变化，直接到仓库区</p><ul><li>git commit -a</li></ul><p>提交时显示所有diff信息</p><ul><li>git commit -v</li></ul><p>使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息</p><ul><li>git commit –amend -m [message]</li></ul><p>重做上一次commit，并包括指定文件的新变化</p><ul><li>git commit –amend …</li></ul><h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h3><p>列出所有本地分支</p><ul><li>git branch</li></ul><p>列出所有远程分支</p><ul><li>git branch -r</li></ul><p>列出所有本地分支和远程分支</p><ul><li>git branch -a</li></ul><p>新建一个分支，但依然停留在当前分支</p><ul><li>git branch [branch-name]</li></ul><p>新建一个分支，并切换到该分支</p><ul><li>git checkout -b [branch]</li></ul><p>新建一个分支，指向指定commit</p><ul><li>git branch [branch] [commit]</li></ul><p>新建一个分支，与指定的远程分支建立追踪关系</p><ul><li>git branch –track [branch] [remote-branch]</li></ul><p>切换到指定分支，并更新工作区</p><ul><li>git checkout [branch-name]</li></ul><p>建立追踪关系，在现有分支与指定的远程分支之间</p><ul><li>git branch –set-upstream [branch] [remote-branch]</li></ul><p>合并指定分支到当前分支</p><ul><li>git merge [branch]</li></ul><p>选择一个commit，合并进当前分支</p><ul><li>git cherry-pick [commit]</li></ul><p>删除分支</p><ul><li>git branch -d [branch-name]</li></ul><p>删除远程分支</p><ul><li><p>git push origin –delete</p></li><li><ul><li>git branch -dr</li></ul></li></ul><p>###六、标签</p><p>列出所有tag</p><ul><li>git tag</li></ul><p>新建一个tag在当前commit</p><ul><li>git tag [tag]</li></ul><p>新建一个tag在指定commit</p><ul><li>git tag [tag] [commit]</li></ul><p>查看tag信息</p><ul><li>git show [tag]</li></ul><p>提交指定tag</p><ul><li>git push [remote] [tag]</li></ul><p>提交所有tag</p><ul><li>git push [remote] –tags</li></ul><p>新建一个分支，指向某个tag</p><ul><li>git checkout -b [branch] [tag]</li></ul><h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><p>显示有变更的文件</p><ul><li>git status</li></ul><p>显示当前分支的版本历史</p><ul><li>git log</li></ul><p>显示commit历史，以及每次commit发生变更的文件</p><ul><li>git log –stat</li></ul><p>显示某个文件的版本历史，包括文件改名</p><ul><li><p>git log –follow [file]</p></li><li><p>git whatchanged [file]</p></li></ul><p>显示指定文件相关的每一次diff</p><ul><li>git log -p [file]</li></ul><p>显示指定文件是什么人在什么时间修改过</p><ul><li>git blame [file]</li></ul><p>显示暂存区和工作区的差异</p><ul><li>git diff</li></ul><p>显示暂存区和上一个commit的差异</p><ul><li>git diff –cached []</li></ul><p>显示工作区与当前分支最新commit之间的差异</p><ul><li>git diff HEAD</li></ul><p>显示两次提交之间的差异</p><ul><li>git diff [first-branch]…[second-branch]</li></ul><p>显示某次提交的元数据和内容变化</p><ul><li>git show [commit]</li></ul><p>显示某次提交发生变化的文件</p><ul><li>git show –name-only [commit]</li></ul><p>显示某次提交时，某个文件的内容</p><ul><li>git show [commit]:[filename]</li></ul><p>显示当前分支的最近几次提交</p><ul><li>git reflog</li></ul><h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><p>下载远程仓库的所有变动</p><ul><li>git fetch [remote]</li></ul><p>显示所有远程仓库</p><ul><li>git remote -v</li></ul><p>显示某个远程仓库的信息</p><ul><li>git remote show [remote]</li></ul><p>增加一个新的远程仓库，并命名</p><ul><li>git remote add [shortname] [url]</li></ul><p>取回远程仓库的变化，并与本地分支合并</p><ul><li>git pull [remote] [branch]</li></ul><p>上传本地指定分支到远程仓库</p><ul><li>git push [remote] [branch]</li></ul><p>强行推送当前分支到远程仓库，即使有冲突</p><ul><li>git push [remote] –force</li></ul><p>推送所有分支到远程仓库</p><ul><li>git push [remote] –all</li></ul><h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><p>恢复暂存区的指定文件到工作区</p><ul><li>git checkout [file]</li></ul><p>恢复某个commit的指定文件到工作区</p><ul><li>git checkout [commit] [file]</li></ul><p>恢复上一个commit的所有文件到工作区</p><ul><li>git checkout .</li></ul><p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><ul><li>git reset [file]</li></ul><p>重置暂存区与工作区，与上一次commit保持一致</p><ul><li>git reset –hard</li></ul><p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p><ul><li>git reset [commit]</li></ul><p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p><ul><li>git reset –hard [commit]</li></ul><p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p><ul><li>git reset –keep [commit]</li></ul><p>新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p><ul><li>git revert [commit]</li></ul><h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><p>生成一个可供发布的压缩包</p><ul><li>git archive</li></ul><p>备份当前工作区的内容</p><ul><li>git stash</li></ul><p>从Git栈中读取最近一次保存的内容，恢复工作区的相关内容</p><ul><li>git stash pop</li></ul><p>显示Git栈内的所有备份</p><ul><li>git stash list</li></ul><p>清空Git栈</p><ul><li>git stash clear</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android绘图之Paint和Canvas的使用方法</title>
      <link href="/2018/08/22/Android%E7%BB%98%E5%9B%BE%E4%B9%8BPaint%E5%92%8CCanvas%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/22/Android%E7%BB%98%E5%9B%BE%E4%B9%8BPaint%E5%92%8CCanvas%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在自定义 View 的时候经常会使用到 Paint 和 Canvas 进行绘图，这些类比较像一些工具类，主要集中在方法的理解与使用。下面是给出的一些常用方法，当然还有很多还有方法没有列出来，使用的时候可以直接查看源码查找相应的方法。</p><h3 id="Paint类"><a href="#Paint类" class="headerlink" title="Paint类"></a>Paint类</h3><h4 id="setStyle"><a href="#setStyle" class="headerlink" title="setStyle"></a>setStyle</h4><p>用于设置画笔的风格，可以指定是圆心还是实心，该方法在矩形，圆形有明显的效果</p><pre><code class="java">//参数style为画笔的风格public void setStyle(Paint.Style style)</code></pre><p>可选参数包括：</p><ul><li>Style.FILL: 实心</li><li>Style.FILL_AND_STROKE: 同时显示实心和空心</li><li>Style.STROKE: 空心</li></ul><h4 id="setStrokeCap"><a href="#setStrokeCap" class="headerlink" title="setStrokeCap"></a>setStrokeCap</h4><p> 用来控制我们的画笔在离开画板时候留下的最后一点图形，或者说叫做笔触风格 ，笔触就像我们现实世界中的笔，如果你用圆珠笔在纸上戳一点，那么这个点是个圆，它代表了笔的笔触形状，如果我们把一支铅笔笔尖削成方形的，那么画出来的线条会是一条弯曲的“矩形”，这就是笔触的意思。</p><pre><code class="java">public void setStrokeCap(Cap cap)</code></pre><p>参数可选列表：</p><ul><li>Cap.BUTT : 无笔触风格</li><li>Cap.ROUND ：圆形</li><li>Cap.SQUARE ： 方形</li></ul><h4 id="setStrokeJoin"><a href="#setStrokeJoin" class="headerlink" title="setStrokeJoin"></a>setStrokeJoin</h4><p>设置线段连接处样式</p><pre><code class="java">public void setStrokeJoin(Join join)</code></pre><p>可选值包括：</p><ul><li>Join.MITER（结合处为锐角）</li><li>Join.Round(结合处为圆弧)</li><li>Join.BEVEL(结合处为直线) </li></ul><h4 id="setTypeface"><a href="#setTypeface" class="headerlink" title="setTypeface"></a>setTypeface</h4><p>用于设置画笔的字体样式，可以使用系统自带的字段，也可以使用自定义的字体</p><pre><code class="java">//typeface为字体样式public void Typeface(Typeface typeface)</code></pre><p>一些可选值包括：</p><ul><li>Typeface.DEFAULT: 默认字体</li><li>Typeface.DEFAULT_BOLD: 加粗字体</li><li>Typeface.MONOSPACE: monospace字体</li><li>Typeface.SANS_SERIF: sans字体</li><li>Typeface.SERIF: serif字体</li></ul><h4 id="setColor"><a href="#setColor" class="headerlink" title="setColor"></a>setColor</h4><p>用于设置画笔的颜色</p><pre><code class="java">//参数color为颜色值，也可以使用Color类定义的颜色public void setColor(int color)</code></pre><p>下面是一些Color类定义的颜色：</p><ul><li>Color.BLACK:黑色</li><li>Color.BLUE:蓝色</li><li>Color.CYAN:青绿色</li><li>Color.DKGRAY:灰黑色</li><li>Color.YELLOW:黄色</li><li>Color.GRAY:灰色</li><li>Color.GREEN:绿色</li><li>Color.LTGRAY:浅绿色</li><li>Color.MAGENTA:红紫色</li><li>Color.TRANSPARENT:透明色</li></ul><h4 id="setAlpha"><a href="#setAlpha" class="headerlink" title="setAlpha"></a>setAlpha</h4><p>用于设置画笔的透明度，为透明度，其取值范围为0~255，数值越小越透明</p><pre><code class="java">public void setAlpha(int a)</code></pre><h4 id="setPathEffect"><a href="#setPathEffect" class="headerlink" title="setPathEffect"></a>setPathEffect</h4><p><a href="http://www.cnblogs.com/tianzhijiexian/p/4297783.html" target="_blank" rel="noopener">详解Paint的setPathEffect(PathEffect effect)</a></p><h4 id="setStrokeWidth"><a href="#setStrokeWidth" class="headerlink" title="setStrokeWidth"></a>setStrokeWidth</h4><p>用于设置画笔的空心线宽，该方法在矩形，圆形，等图形上有明显的效果；</p><pre><code class="java">//参数width为线宽，浮点型数据public void setStrokeWidth(float width)</code></pre><h4 id="setARGB"><a href="#setARGB" class="headerlink" title="setARGB"></a>setARGB</h4><p>用于设置画笔的颜色和透明度</p><pre><code class="java">public void setARGB(int a,int r,int g,int b);</code></pre><ul><li>参数a为透明度，范围0~255</li><li>参数r为红色的颜色值，范围0~255</li><li>参数g为绿色的颜色值，范围0~255</li><li>参数b为蓝色的颜色值，范围0~255</li></ul><h4 id="setTextSize"><a href="#setTextSize" class="headerlink" title="setTextSize"></a>setTextSize</h4><p> 用于设置画笔的字体大小，主要用于绘制字符串</p><pre><code class="java">// 参数为字体大小 public void setTextSize(float textSize)</code></pre><h4 id="setShadowLayer"><a href="#setShadowLayer" class="headerlink" title="setShadowLayer"></a>setShadowLayer</h4><p>用于设置添加阴影</p><pre><code class="java">public void setShadowLayer(float radius, float dx, float dy, int shadowColor) </code></pre><ul><li>adius 表示阴影的倾斜度</li><li>dx:水平方向位移的像素</li><li>dy:垂直方向位移的像素</li><li>shadowColor:设置阴影的颜色</li></ul><h4 id="setTextScaleX"><a href="#setTextScaleX" class="headerlink" title="setTextScaleX"></a>setTextScaleX</h4><p>设置字体水平方向的拉伸，默认为1，当大于1时表示向两边拉伸，小于1时表示向中间压缩</p><pre><code class="java">public void setTextScaleX(float scaleX)</code></pre><h4 id="setFakeBoldText"><a href="#setFakeBoldText" class="headerlink" title="setFakeBoldText"></a>setFakeBoldText</h4><p>用于设置文字是否为粗体</p><pre><code class="java">public void setFakeBoldText(boolean fakeBoldText)</code></pre><h4 id="setStrikeThruText"><a href="#setStrikeThruText" class="headerlink" title="setStrikeThruText"></a>setStrikeThruText</h4><p>设置是否带有删除线效果</p><pre><code class="java">public void setStrikeThruText(boolean strikeThruText)</code></pre><h4 id="setUnderlineText"><a href="#setUnderlineText" class="headerlink" title="setUnderlineText"></a>setUnderlineText</h4><p>用于设置画笔的下划线，当取值为true时，表示显示下划线</p><pre><code class="java">public void setUnderlineText(Boolean underlintext)</code></pre><h4 id="setTextAlign"><a href="#setTextAlign" class="headerlink" title="setTextAlign"></a>setTextAlign</h4><p>设置文字对齐方式</p><pre><code class="java">// 参数为文字对齐方式public void setTextAlign(Align align)</code></pre><p>可选参数包括：</p><ul><li>Align.LEFT</li><li>Align.RIGHT</li><li>Align.CENTER</li></ul><h4 id="setTextSkewX"><a href="#setTextSkewX" class="headerlink" title="setTextSkewX"></a>setTextSkewX</h4><p>用于设置画笔的倾斜因子</p><pre><code class="java">// 参数 skewX 为倾斜因子，正数表示向左倾斜，负数表示向右倾斜public void setTextSkewX(float skewX)</code></pre><h3 id="Canvas类"><a href="#Canvas类" class="headerlink" title="Canvas类"></a>Canvas类</h3><h4 id="绘制背景"><a href="#绘制背景" class="headerlink" title="绘制背景"></a>绘制背景</h4><h5 id="drawColor"><a href="#drawColor" class="headerlink" title="drawColor"></a>drawColor</h5><pre><code class="java">public void drawColor(int color) </code></pre><h5 id="drawRGB"><a href="#drawRGB" class="headerlink" title="drawRGB"></a>drawRGB</h5><pre><code class="java">public void drawRGB(int r, int g, int b) </code></pre><h4 id="绘制弧形"><a href="#绘制弧形" class="headerlink" title="绘制弧形"></a>绘制弧形</h4><h5 id="drawArc"><a href="#drawArc" class="headerlink" title="drawArc"></a>drawArc</h5><pre><code class="java">public void drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)</code></pre><p>参数信息：</p><ul><li>前面四个参数围成的矩形，在矩形内绘制内切弧形；</li><li>startAngle ： 起始角度</li><li>sweepAngle ： 结束角度（按顺时针）</li><li>useCenter ：若为true表示此弧会和 RectF 中心相连形成扇形，否则，弧的两头直接相连形成图形</li><li>paint</li></ul><pre><code class="java">public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint)</code></pre><p>直接用 RectF 来表示矩形区域</p><h4 id="绘制圆"><a href="#绘制圆" class="headerlink" title="绘制圆"></a>绘制圆</h4><h5 id="drawCircle"><a href="#drawCircle" class="headerlink" title="drawCircle"></a>drawCircle</h5><pre><code class="java">public void drawCircle(float cx, float cy, float radius, @NonNull Paint paint)</code></pre><p>参数信息：</p><ul><li>cx: 圆心横坐标</li><li>cy: 圆心纵坐标</li><li>radius: 半径</li><li>paint</li></ul><h4 id="绘制点"><a href="#绘制点" class="headerlink" title="绘制点"></a>绘制点</h4><h5 id="drawPoint"><a href="#drawPoint" class="headerlink" title="drawPoint"></a>drawPoint</h5><p>绘制一个点</p><pre><code class="java">public void drawPoint(float x, float y, @NonNull Paint paint)</code></pre><p>参数信息：</p><ul><li>x: 横坐标</li><li>y: 纵坐标</li><li>paint</li></ul><h4 id="绘制线段"><a href="#绘制线段" class="headerlink" title="绘制线段"></a>绘制线段</h4><h5 id="drawLine"><a href="#drawLine" class="headerlink" title="drawLine"></a>drawLine</h5><pre><code class="java">public void drawLine(float startX, float startY, float stopX, float stopY, @NonNull Paint paint)</code></pre><p>参数信息：</p><ul><li>startX: 第一个点的横坐标</li><li>startY: 第一个点的纵坐标</li><li>stopX: 第二个点的横坐标</li><li>stopY: 第一个点的纵坐标</li><li>paint</li></ul><h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h4><h5 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h5><pre><code class="java">public void drawRect(float left, float top, float right, float bottom, Paint paint)  </code></pre><p>因为默认矩形是水平的，所以只需要给出四条边的左边</p><pre><code class="java">public void drawRect(Rect r, Paint paint) </code></pre><h4 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h4><h5 id="drawRoundRect"><a href="#drawRoundRect" class="headerlink" title="drawRoundRect"></a>drawRoundRect</h5><pre><code class="java">public void drawRoundRect (RectF rect,float rx,float ry,Paint paint)</code></pre><p>参数信息：</p><ul><li>rx为X方向上的圆角半径</li><li>ry为Y方向上的圆角半径</li></ul><h4 id="绘制椭圆"><a href="#绘制椭圆" class="headerlink" title="绘制椭圆"></a>绘制椭圆</h4><h5 id="drawOval"><a href="#drawOval" class="headerlink" title="drawOval"></a>drawOval</h5><p>通过指定椭圆的外切矩形实现</p><pre><code class="java">public void drawOval(RectF rect.Paint paint)</code></pre><h4 id="根据定义的路径画出图"><a href="#根据定义的路径画出图" class="headerlink" title="根据定义的路径画出图"></a>根据定义的路径画出图</h4><p>主要用于绘制复杂的图形轮廓</p><h5 id="drawPath"><a href="#drawPath" class="headerlink" title="drawPath"></a>drawPath</h5><pre><code class="java">public void drawPath(Path path, Paint paint)</code></pre><p>比如我想要绘制一个三角形，可以定义一个path对象</p><pre><code class="java">Path path = new Path(); //定义一条路径path.moveTo(60, 60); //起始点 坐标60,60path.lineTo(100, 100);//连接直线path.lineTo(200,80);path.lineTo(60, 60);// 绘制定义的 pathcanvas.drawPath(path,paint);</code></pre><h4 id="绘制字体"><a href="#绘制字体" class="headerlink" title="绘制字体"></a>绘制字体</h4><h5 id="drawText"><a href="#drawText" class="headerlink" title="drawText"></a>drawText</h5><pre><code class="java">public void drawText(String text, float x, float y, Paint paint)public void drawText(char[] text,int index,int count,float x,float y,Paint paint)public void drawText(CharSequence text,int start,int end,float x,float y,Paint paint)public void drawText(String text,int start,int end,float x,float y,Paint paint)</code></pre><p>参数信息：</p><ul><li>text为字符串的内容</li><li>x为X坐标</li><li>y为Y坐标</li><li>index为显示的起始字符位置</li><li>count为显示的字符个数</li><li>start为显示的起始字符的位置</li><li>end为显示的终止的字符的位置</li></ul><h4 id="绘制Bitmap"><a href="#绘制Bitmap" class="headerlink" title="绘制Bitmap"></a>绘制Bitmap</h4><h5 id="drawBitmap"><a href="#drawBitmap" class="headerlink" title="drawBitmap"></a>drawBitmap</h5><pre><code class="java">public void drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</code></pre><ul><li>参数bitmap为Bitmap对象，代表图像资源，</li><li>left为图像显示的左边的位置</li><li>right为图像的显示的右边的位置</li></ul><h4 id="Canvas平移"><a href="#Canvas平移" class="headerlink" title="Canvas平移"></a>Canvas平移</h4><pre><code class="java">/**  * 画布向（100，50）方向平移  *   * 参数1: 向X轴方向移动100距离 * 参数2: 向Y轴方向移动50距离 */ canvas.translate(100, 50);</code></pre><h4 id="Canvas缩放"><a href="#Canvas缩放" class="headerlink" title="Canvas缩放"></a>Canvas缩放</h4><pre><code class="java">/**  * 在X轴方向放大为原来2倍，Y轴方向方大为原来的4倍  * 参数1: X轴的放大倍数  * 参数2: Y轴的放大倍数  * 默认原点为左上角 */canvas.scale(2, 4);/**  * 在X轴方向放大为原来2倍，Y轴方向方大为原来的4倍  * 参数1: X轴的放大倍数  * 参数2: Y轴的放大倍数  * 参数3: 原点X坐标 * 参数4: 原点Y坐标 */canvas.scale(2, 4，100,100);</code></pre><p>作用效果：<br><img src="http://dengw.xyz/hexo-blog/180822/B1dge7fakI.png" alt="enter image description here"></p><h4 id="Canvas旋转"><a href="#Canvas旋转" class="headerlink" title="Canvas旋转"></a>Canvas旋转</h4><pre><code class="java">/**  * 原点为中心，旋转30度（顺时针方向为正方向 ） * 参数: 旋转角度  */canvas.rotate(30);/**  * 以（100,100）为中心，旋转30度，顺时针方向为正方向  * 参数: 旋转角度  */canvas.rotate(30,100,100);</code></pre><p>作用效果：<br><img src="http://dengw.xyz/hexo-blog/180822/Jb3DiKd5jm.png" alt="enter image description here"></p><h4 id="Canvas保存和还原"><a href="#Canvas保存和还原" class="headerlink" title="Canvas保存和还原"></a>Canvas保存和还原</h4><p>Canvas提供了几个方法，让我们可以方便的对Canvas的状态进行更改和还原。这些方法是：</p><ul><li>save()</li><li>restore()</li><li>restoreToCount(int saveCount)。</li></ul><p>我们在对 Canvas 进行平移、旋转、放大等操作时候，可以调用save()方法，将当前修改过的Canvas状态进行保存，调用restore() 方法后，会将 Canvas 还原成最近的一个save() 的状态。</p><p>save()方法还会有一个返回值，我们也可以调用 restoreToCount(int saveCount) 方法，将这个返回值作为参数传递进去，就可以将Canvas还原成某一个特定的save()状态。</p><p>一个可参考操作：</p><pre><code class="java"> canvas.translate(100,100); // 平移（100,100） int save1 = canvas.save(); // 保存Canvas状态（状态1） canvas.scale(2, 2); // 放大2倍 int save2 = canvas.save(); // 保存Canvas状态（状态2） canvas.restore(); // 返回最新的save状态，即状态2 canvas.restoreToCount(save1);// 手动指定的返回到 状态1</code></pre><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.jianshu.com/p/f69873371763" target="_blank" rel="noopener">Android Canvas 方法总结</a></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IdCardCamera — 从一个Demo学习Android平台Camera开发</title>
      <link href="/2018/08/21/IdCardCamera%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AADemo%E5%AD%A6%E4%B9%A0Android%E5%B9%B3%E5%8F%B0Camera%E5%BC%80%E5%8F%91/"/>
      <url>/2018/08/21/IdCardCamera%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AADemo%E5%AD%A6%E4%B9%A0Android%E5%B9%B3%E5%8F%B0Camera%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>之前在 meitu 实习的时候就接触过 Android Camera，现在 Android 已经有两套相机 API：Camera 和Camera2，虽然现在官方推崇的是 Camera2 而且部分 Camera1 的很多API现在已经不再推荐使用了，但是现在市场上的手机厂商对 Camera2 的支持程度也各不相同，所以现在开发使用的还是主要是  Camera1  的API，给出的 Demo 也是在 Camera1 的基础上实现的。</p><h2 id="Camera-实践"><a href="#Camera-实践" class="headerlink" title="Camera 实践"></a>Camera 实践</h2><p>Demo实现的功能是一个拍摄身份证正反面的相机应用，首先肯定支持拍摄功能，这个过程就可以完整地体验一下相机应用的开发流程以及相关API的使用，比如：</p><ul><li>预览</li><li>闪光灯</li><li>对焦</li><li>拍摄</li></ul><p>其次呢，我们是为了拍摄身份证正反两面的照片，还需要支持对图片的截取功能，这部分我们通过自定义一个控件实现图片四个角的截取。</p><h3 id="相机开发的一般流程"><a href="#相机开发的一般流程" class="headerlink" title="相机开发的一般流程"></a>相机开发的一般流程</h3><ol><li>检测并访问相机资源，检查手机是否存在相机资源，如果存在则请求访问相机资源。</li><li>创建预览界面，创建继承自SurfaceView并实现SurfaceHolder接口的拍摄预览类。有了拍摄预览类，即可创建一个布局文件，将预览画面与设计好的用户界面控件融合在一起，实时显示相机的预览图像。</li><li>设置拍照监听器，给用户界面控件绑定监听器，使其能响应用户操作, 开始拍照过程。</li><li>拍照并保存文件，将拍摄获得的图像转换成位图文件，最终输出保存成各种常用格式的图片。</li><li>释放相机资源，相机是一个共享资源，当相机使用完毕后，必须正确地将其释放，以免其它程序访问使用时发生冲突。</li></ol><h4 id="资源权限和权限申请"><a href="#资源权限和权限申请" class="headerlink" title="资源权限和权限申请"></a>资源权限和权限申请</h4><p>首先要检查相机资源，获取系统相机的相关信息。</p><pre><code class="java">// 判断是否有相机context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA);// 判断是否有前置相机context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT);</code></pre><p>或者</p><pre><code class="java">//有多少个摄像头numberOfCameras = Camera.getNumberOfCameras();for (int i = 0; i &lt; numberOfCameras; ++i) {    final Camera.CameraInfo cameraInfo = new Camera.CameraInfo();    Camera.getCameraInfo(i, cameraInfo);    //后置摄像头    if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK)    {        faceBackCameraId = i;        faceBackCameraOrientation = cameraInfo.orientation;    }     //前置摄像头    else if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT)     {        faceFrontCameraId = i;        faceFrontCameraOrientation = cameraInfo.orientation;    }}</code></pre><p>另外，相机开发还会设计及到一些权限操作，比如，调用相机拍摄图片的权限，读、写文件的权限等，在demo中需要申请3个权限：</p><ul><li>Manifest.permission.WRITE_EXTERNAL_STORAGE</li><li>Manifest.permission.READ_EXTERNAL_STORAGE</li><li>Manifest.permission.CAMERA</li></ul><p>这里学习到了一种同时申请多个权限的方法</p><ul><li><p>首先用一个字符串数组保存要申请的权限：</p><pre><code class="java">// 需要申请的权限数组public static String[] permissions = new String[]{      Manifest.permission.WRITE_EXTERNAL_STORAGE,      Manifest.permission.READ_EXTERNAL_STORAGE,      Manifest.permission.CAMERA};</code></pre></li><li><p>检查应用是否已经具有某个权限，如果没有的话就申请这个权限；</p><pre><code class="java">/*** 检查权限，检查应用所需要的某个权限* @param context* @param requestCode  请求码* @param permission  权限* @return*/public static boolean checkSinglePermission(Context context,int requestCode, String permission) {  int permissionCode = ActivityCompat.checkSelfPermission(context, permission);  // PackageManager.PERMISSION_GRANTED 表示应用已经具有的权限  if(permissionCode != PackageManager.PERMISSION_GRANTED) {      ActivityCompat.requestPermissions((Activity) context, new String[]{permission}, requestCode);      return false;  }  return true;}</code></pre></li></ul><p>或者说同时检查应用是否已经具有多个权限，如果没有的话就申请其中应用还不具备权限；</p><pre><code class="java">/** * 检查权限，检查应用所需要的所有权限 * @param context * @param requestCode  请求码 * @param permissions  权限数组 * @return */public static boolean checkMultiPermissions(Context context, int requestCode, String []permissions) {    rejectedPermissions.clear();    for(String per : permissions) {        int permissionCode = ActivityCompat.checkSelfPermission(context, per);        if(permissionCode != PackageManager.PERMISSION_GRANTED) {            rejectedPermissions.add(per);        }    }    if(rejectedPermissions.isEmpty()) {        return true;    } else {        String[] permissionList = rejectedPermissions.toArray(new String[rejectedPermissions.size()]);        ActivityCompat.requestPermissions((Activity)context, permissionList, requestCode);        return false;    }}</code></pre><p>思路就是用一个数组保存还不具备的权限，如果数组不为空的话说明就需要申请这些权限。</p><ul><li>申请需要的权限</li></ul><p>申请一个权限的时候使用的是 <code>ActivityCompat</code> 的 <code>requestPermissions</code> 方法，该方法的声明为：</p><pre><code>public static void requestPermissions(final @NonNull Activity activity,            final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode)</code></pre><p>其中：</p><ul><li>activity：上下文，</li><li>permissions：权限数组</li><li>requestCode：请求码</li></ul><p>并且该方法请求完之后会有一个回调接口，需要在上面传入的上下文中重写该方法，该回调接口的作用就是权限请求的结果：</p><pre><code class="java">public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {/* callback - no nothing */}</code></pre><p>所以，比如当我们  requestPermissions 方法传入的 context 是 CameraActivity ，那么我们就需要在 CameraActivity 中重写 onRequestPermissionsResult 方法，详细见下面链接中给出的项目代码。</p><h4 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h4><pre><code>// 默认开启后置相机camera = Camera.open();// 当知道某个相机具体的id，参考上面检查是否有相机资源的第二种方法camera = Camera.open(cameraId);</code></pre><h4 id="获取相机参数"><a href="#获取相机参数" class="headerlink" title="获取相机参数"></a>获取相机参数</h4><pre><code>//获取相机参数Camera.Parameters parameters = camera.getParameters();</code></pre><p>常见的参数有以下几种:</p><p>闪光灯配置参数，可以通过Parameters.getFlashMode()接口获取:</p><ul><li>Camera.Parameters.FLASH_MODE_AUTO 自动模式，当光线较暗时自动打开闪光灯；</li><li>Camera.Parameters.FLASH_MODE_OFF 关闭闪光灯；</li><li>Camera.Parameters.FLASH_MODE_ON 拍照时闪光灯；</li><li>Camera.Parameters.FLASH_MODE_RED_EYE 闪光灯参数，防红眼模式。</li></ul><p>对焦模式配置参数，可以通过Parameters.getFocusMode()接口获取。</p><ul><li>Camera.Parameters.FOCUS_MODE_AUTO 自动对焦模式，摄影小白专用模式；</li><li>Camera.Parameters.FOCUS_MODE_FIXED 固定焦距模式，拍摄老司机模式；</li><li>Camera.Parameters.FOCUS_MODE_EDOF 景深模式，文艺女青年最喜欢的模式；</li><li>Camera.Parameters.FOCUS_MODE_INFINITY 远景模式，拍风景大场面的模式；</li><li>Camera.Parameters.FOCUS_MODE_MACRO 微焦模式，拍摄小花小草小蚂蚁专用模式；</li></ul><p>场景模式配置参数，可以通过Parameters.getSceneMode()接口获取。</p><ul><li>Camera.Parameters.SCENE_MODE_BARCODE 扫描条码场景，NextQRCode项目会判断并设置为这个场景；</li><li>Camera.Parameters.SCENE_MODE_ACTION 动作场景，就是抓拍跑得飞快的运动员、汽车等场景用的；</li><li>Camera.Parameters.SCENE_MODE_AUTO 自动选择场景；</li><li>Camera.Parameters.SCENE_MODE_HDR 高动态对比度场景，通常用于拍摄晚霞等明暗分明的照片；</li><li>Camera.Parameters.SCENE_MODE_NIGHT 夜间场景；</li></ul><h4 id="开启预览"><a href="#开启预览" class="headerlink" title="开启预览"></a>开启预览</h4><p>Camera的预览时通过 SurfaceView 的 SurfaceHolder 进行的，这里需要了解几个很关键的类：</p><ul><li>SurfaceView：用于绘制相机预览图像，提供实时预览的图像。</li><li>SurfaceHolder：用于控制Surface的一个抽象接口，它可以控制Surface的尺寸、格式与像素等，并可以监视Surface的变化。</li><li>SurfaceHolder.Callback：用于监听Surface状态变化的接口。</li></ul><h5 id="SurfaceView和普通的View区别"><a href="#SurfaceView和普通的View区别" class="headerlink" title="SurfaceView和普通的View区别"></a>SurfaceView和普通的View区别</h5><p>Surfaceview是视图（view）的一个继承类，这个视图里内嵌了一个专门用于绘制的Surface。</p><p>SurfaceView 是在一个新起的单独线程中可以重新绘制画面，而 View 必须在 UI 线程中更新画面。这样，如果绘图任务繁重，使用普通 View 的 onDraw 方法里面的代码要执行好长一段时间，就可能会造成UI主线程阻塞。而 SurfaceView 的机制是在后台线程执行繁重的绘图任务，把所有绘制的东西缓存起来；绘制完毕后，再回到 UI 线程，一次性把所绘制的东西渲染到屏幕上，实质上就是后台线程绘制，UI主线程渲染。</p><p>关于 SurfaceView 后面会专门写一篇博客来介绍。</p><p>在SurfaceHolder.Callback接口里定义了三个函数：</p><ul><li>surfaceCreated(SurfaceHolder holder); 当Surface第一次创建的时候调用</li><li>surfaceChanged(SurfaceHolder holder, int format, int width, int height); 当Surface的size、format等发生变化的时候调用</li><li>surfaceDestroyed(SurfaceHolder holder); 当Surface被销毁的时候调用</li></ul><p>介绍完上面这些可以写我们用于预览的控件了，下面是我们demo中的预览控件：</p><pre><code>// 继承自 SurfaceView 并实现 SurfaceHolder.Callback 接口public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback{    // camera实例    private Camera mCamera;    // 自定义View的三个构造函数    public CameraPreview(Context context) {        super(context);        init(context);    }    public CameraPreview(Context context, AttributeSet attrs) {        super(context, attrs);        init(context);    }    public CameraPreview(Context context, AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        init(context);    }    /**     * 依次为重写的 SurfaceHolder.Callback 的三个函数     */     // 在这个函数中一般设置预览界面的一些参数，然后开启预览    @Override    public void surfaceCreated(SurfaceHolder holder) {        if(mCamera != null) {            try {                Camera.Parameters parameters = mCamera.getParameters();                if(getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {                    //竖屏拍照时，需要设置旋转90度，否者看到的相机预览方向和界面方向不相同                    mCamera.setDisplayOrientation(90);                    parameters.setRotation(90);                } else {                    mCamera.setDisplayOrientation(0);                    parameters.setRotation(0);                }                // 设置预览的尺寸                Camera.Size size = getBestSize(parameters.getSupportedPreviewSizes());                if(size != null) {                    parameters.setPreviewSize(size.width, size.height);                    parameters.setPictureSize(size.width, size.height);                } else {                    parameters.setPreviewSize(1920, 1080);                    parameters.setPictureSize(1920, 1080);                }                //设置surfaceHolder                mCamera.setPreviewDisplay(holder);                //设置相机参数                mCamera.setParameters(parameters);                // 开启预览                mCamera.startPreview();                //首次对焦                CameraUtil.focus();            } catch (IOException e) {                e.printStackTrace();            }        }    }    @Override    public void surfaceChanged(SurfaceHolder holder, int format, int width,                               int height) {        //因为设置了固定屏幕方向，所以在实际使用中不会触发这个方法    }    // 这个函数中一般用来回收资源    @Override    public void surfaceDestroyed(SurfaceHolder holder) {        //回收释放资源        release();    }    private void init(Context context) {        SurfaceHolder surfaceHolder = getHolder();        surfaceHolder.addCallback(this);        surfaceHolder.setKeepScreenOn(true);        surfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);        mCamera = CameraUtil.getCameraInstance(context);    }    /**     * Android相机的预览尺寸都是4:3或者16:9，这里遍历所有支持的预览尺寸，得到16:9的最大尺寸，保证成像清晰度     *     * @param sizes     * @return 最佳尺寸     */    private Camera.Size getBestSize(List&lt;Camera.Size&gt; sizes) {        Camera.Size bestSize = null;        for (Camera.Size size : sizes) {            if ((float) size.width / (float) size.height == 16.0f / 9.0f) {                if (bestSize == null) {                    bestSize = size;                } else {                    if (size.width &gt; bestSize.width) {                        bestSize = size;                    }                }            }        }        return bestSize;    }    /**     * 释放资源     */    private void release() {        if (mCamera != null) {            mCamera.stopPreview();            CameraUtil.release();        }    }    /**     * 开启预览     */    public void startPreview() {        if (mCamera != null) {            mCamera.startPreview();        }    }}</code></pre><h4 id="关闭预览"><a href="#关闭预览" class="headerlink" title="关闭预览"></a>关闭预览</h4><pre><code>camera.stopPreview();</code></pre><h4 id="开启闪关灯"><a href="#开启闪关灯" class="headerlink" title="开启闪关灯"></a>开启闪关灯</h4><pre><code>/** * 开关闪光灯 * * @return 闪光灯是否开启 */public static boolean switchFlashLight() {    if (camera != null) {        Camera.Parameters parameters = camera.getParameters();        if (parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF))        {            parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);            camera.setParameters(parameters);            return true;        } else {            parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);            camera.setParameters(parameters);            return false;        }    }    return false;}</code></pre><p>这里需要注意的是严谨的话开启闪光灯之前还需要判断是否具有闪光灯，虽然现在没有手机闪光灯的手机基本上没有了。</p><h4 id="开启对焦"><a href="#开启对焦" class="headerlink" title="开启对焦"></a>开启对焦</h4><pre><code>camera.autoFocus(null);</code></pre><h4 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h4><p>拍照时通过调用Camera的takePicture()方法来完成的，</p><pre><code>takePicture(ShutterCallback shutter, PictureCallback raw,            PictureCallback jpeg)</code></pre><p>该方法有三个参数：</p><ul><li>ShutterCallback shutter：在拍照的瞬间被回调，这里通常可以播放”咔嚓”这样的拍照音效。</li><li>PictureCallback raw：返回未经压缩的图像数据。<br>PictureCallback jpeg：返回经过JPEG压缩的图像数据。</li></ul><p>我们一般用的就是最后一个，实现最后一个PictureCallback即可，在本demo中主要是在 PictureCallback 中进行图片的剪切。</p><pre><code class="java">new Camera.PictureCallback() {    @Override    public void onPictureTaken(final byte[] data, Camera camera) {        camera.stopPreview();        //子线程处理图片，防止ANR        new Thread(new Runnable() {            @Override            public void run() {                Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);                // 计算裁剪位置                float left, top, right, bottom;                left = ((float) mLlCameraCropContainer.getLeft() - (float)mCameraPreview.getLeft()) / (float) mCameraPreview.getWidth();                top = (float) mIvCameraCrop.getTop() / (float) mCameraPreview.getHeight();                right = (float) mLlCameraCropContainer.getRight() / (float) mCameraPreview.getWidth();                bottom = (float) mIvCameraCrop.getBottom() / (float) mCameraPreview.getHeight();                // 自动裁剪                mCropBitmap = Bitmap.createBitmap(bitmap,                (int) (left * (float) bitmap.getWidth()),                (int) (top * (float) bitmap.getHeight()),                (int) ((right - left) * (float) bitmap.getWidth()),                (int) ((bottom - top) * (float) bitmap.getHeight()));                // 手动裁剪                runOnUiThread(new Runnable() {                @Override                public void run() {                    //将裁剪区域设置成与扫描框一样大                    mCropImageView.setLayoutParams(new LinearLayout.LayoutParams(mIvCameraCrop.getWidth(), mIvCameraCrop.getHeight()));                    setCropLayout();                    mCropImageView.setImageBitmap(mCropBitmap);                }            });         }     }).start();  }}</code></pre><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><pre><code>camera.release();</code></pre><h3 id="图片截取"><a href="#图片截取" class="headerlink" title="图片截取"></a>图片截取</h3><p>上面的部分只是 Camera API的一些使用，基本上跟着文档走就可以了，也主要是为了帮助学习和熟悉 Camera API 。</p><p>下面回到Demo的需求，获取省份证正反两面的图片，很多时候就需要对一张现成的图片进行截取，这个时候就需要自己定义一个支持图片截图的控件了。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li>一个ImageView，用于显示拍摄的图片，作为图片截图的背景；</li><li>一个截取控件：含有四个可自由移动的顶点（一个新的控件），顶点间构成一个矩形，通过移动顶点控制上面 ImageView 的显示范围，达到截取的效果；</li></ul><p>对于截取控件，总体思路：四个顶点（Point）类 + 相互连线的边</p><ul><li>canvas.drawLine(topLeft.x, topLeft.y, topRight.x, topRight.y, paint); </li><li>canvas.drawLine(top.x, top.y, bottom.x, bottom.y, paint);</li></ul><p>这样，对于截取，重要的就是确定截取后四个顶点的位置，然后再重新绘图</p><pre><code>//图片裁剪的核心功能Bitmap.createBitmap(originalBitmap,//原图                 cropX,//图片裁剪横坐标开始位置                 cropY,//图片裁剪纵坐标开始位置                 cropWidth,//要裁剪的宽度                 cropHeight);//要裁剪的高度</code></pre><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ul><li>四个顶点(左上，左下，右上，右下)<pre><code>private Point topLeft, topRight, bottomLeft, bottomRight;</code></pre></li><li>原图 Bitmap<pre><code>// 确定要截取的范围后在原Bitmap的基础上创建一个新的Bitmapprivate Bitmap bitmap;</code></pre></li><li>绘制背景</li></ul><p>Paint + Path + Canvas</p><pre><code>private void drawBackground(Canvas canvas) {    Paint paint = new Paint();    paint.setColor(Color.parseColor(&quot;#66000000&quot;));    paint.setStyle(Paint.Style.FILL);    Path path = new Path();    path.moveTo(topLeft.x, topLeft.y);    path.lineTo(topRight.x, topRight.y);    path.lineTo(bottomRight.x, bottomRight.y);    path.lineTo(bottomLeft.x, bottomLeft.y);    path.close();    canvas.save();    canvas.clipPath(path, Region.Op.DIFFERENCE);    canvas.drawColor(Color.parseColor(&quot;#66000000&quot;));    canvas.restore();}</code></pre><ul><li>绘制顶点</li></ul><p>Paint + Canvas</p><pre><code>    private void drawVertex(Canvas canvas) {        Paint paint = new Paint();        paint.setColor(Color.WHITE);        paint.setStyle(Paint.Style.FILL);        canvas.drawCircle(topLeft.x, topLeft.y, vertexSize, paint);        canvas.drawCircle(topRight.x, topRight.y, vertexSize, paint);        canvas.drawCircle(bottomLeft.x, bottomLeft.y, vertexSize, paint);        canvas.drawCircle(bottomRight.x, bottomRight.y, vertexSize, paint);    }</code></pre><ul><li>绘制顶点间的连线从而构成矩形</li></ul><p>Paint + Canvas</p><pre><code>    private void drawEdge(Canvas canvas) {        Paint paint = new Paint();        paint.setColor(Color.WHITE);        paint.setStrokeWidth(3);        paint.setAntiAlias(true);        canvas.drawLine(topLeft.x, topLeft.y, topRight.x, topRight.y, paint);        canvas.drawLine(topLeft.x, topLeft.y, bottomLeft.x, bottomLeft.y, paint);        canvas.drawLine(bottomRight.x, bottomRight.y, topRight.x, topRight.y, paint);        canvas.drawLine(bottomRight.x, bottomRight.y, bottomLeft.x, bottomLeft.y, paint);    }</code></pre><ul><li>touchEvevt 处理</li></ul><p>处理 MotionEvent.ACTION_DOWN + MotionEvent.ACTION_MOVE事件，并拦截事件</p><pre><code>    @Override    public boolean onTouchEvent(MotionEvent event) {        switch (event.getAction()) {            case MotionEvent.ACTION_UP:                getParent().requestDisallowInterceptTouchEvent(false);                break;            case MotionEvent.ACTION_DOWN:                getParent().requestDisallowInterceptTouchEvent(false);                onActionDown(event);                return true;            case MotionEvent.ACTION_MOVE:                getParent().requestDisallowInterceptTouchEvent(true);                onActionMove(event);                return true;        }        return false;    }</code></pre><ul><li>MotionEvent.ACTION_DOWN事件的逻辑</li></ul><p>根据touchPoint确定作用的顶点</p><pre><code>    private void onActionDown(MotionEvent event) {        touchDownX = event.getX();        touchDownY = event.getY();        Point touchPoint = new Point((int) event.getX(), (int) event.getY());        int minDistance = distance(touchPoint, topLeft);        cropPosition = CropPosition.TOP_LEFT;        if (minDistance &gt; distance(touchPoint, topRight)) {            minDistance = distance(touchPoint, topRight);            cropPosition = CropPosition.TOP_RIGHT;        }        if (minDistance &gt; distance(touchPoint, bottomLeft)) {            minDistance = distance(touchPoint, bottomLeft);            cropPosition = CropPosition.BOTTOM_LEFT;        }        if (minDistance &gt; distance(touchPoint, bottomRight)) {            cropPosition = CropPosition.BOTTOM_RIGHT;        }    }</code></pre><ul><li>MotionEvent.ACTION_MOV</li></ul><p>根据上面确定的顶点，计算touchPoint的移动在 x 和 y方向的偏移量，然后调整作用顶点的坐标，最后调用 invalidate() 方法重新绘制View</p><pre><code>    private void onActionMove(MotionEvent event) {        int deltaX = (int) (event.getX() - touchDownX);        int deltaY = (int) (event.getY() - touchDownY);        switch (cropPosition) {            case TOP_LEFT:                adjustPointCoordinate(topLeft, deltaX, deltaY);                invalidate();                break;            case TOP_RIGHT:                adjustPointCoordinate(topRight, deltaX, deltaY);                invalidate();                break;            case BOTTOM_LEFT:                adjustPointCoordinate(bottomLeft, deltaX, deltaY);                invalidate();                break;            case BOTTOM_RIGHT:                adjustPointCoordinate(bottomRight, deltaX, deltaY);                invalidate();                break;        }        touchDownX = event.getX();        touchDownY = event.getY();    }    /**     * 移动中调整作用顶点的坐标     */    private void adjustPointCoordinate(Point point, int deltaX, int deltaY) {        int newX = point.x + deltaX;        if (newX &lt; minX) newX = minX;        if (newX &gt; maxX) newX = maxX;        int newY = point.y + deltaY;        if (newY &lt; minY) newY = minY;        if (newY &gt; maxY) newY = maxY;        point.set(newX, newY);    }</code></pre><ul><li>crop（图片裁剪）相关：</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://github.com/duang0626/IDCardCamera" target="_blank" rel="noopener">Demo地址 ： IDCardCamera</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5a33a5106fb9a04525782db5" target="_blank" rel="noopener">Android平台Camera开发实践指南</a><br><a href="https://blog.csdn.net/chunqiuwei/article/details/78858192" target="_blank" rel="noopener">Android自定义 view之图片裁剪从设计到实现</a></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Camera开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在两个Activity之间传递Bitmap对象的方法</title>
      <link href="/2018/08/15/%E5%9C%A8%E4%B8%A4%E4%B8%AAActivity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92Bitmap%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/15/%E5%9C%A8%E4%B8%A4%E4%B8%AAActivity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92Bitmap%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p>今天在做一个相机应用的时候，有这样一个场景，需要将一个 Bitmap 对象从一个 Activity 传递到另外一个 Activity，并且需要在另外一个 Activity 中显示出来。对于在不同的 Activity 之间传递数据这种场景，而且 Bitmap 是序列化的，所以很自然就想到使用 Intent，然后我也就这么用了，但是发现出了问题。</p><p>会发现跳转不过去，也就是说还是显示的之前的 Activity，我通过打 Log 发现 Intent 语句已经执行了，但是为什么跳转不过去了，然后就怀疑是 Bitmap 的问题，因为平时就使用 Intent 来传递一下字符串或者序列化对象之类。果然，我将 bitmap 换成一个字符串的话就可以成功的跳转，确定是 Bitmap 的原因。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>既然发现问题了那就去查阅解决方法嘛，一查，网上果然有人也遇到过这个问题。</p><p>首先引起这个问题的原因是使用 Intent 传递数据是有大小限制的，但是也没有一个确定的数值说小于这个数值就一定可以传输成功，大于这个数值就一定传输失败，一个说法是可能和运存大小有关或者是手机厂商自定义的，这个有待考证。</p><p>因为我发送的 Bitmap 是用2000W 像素拍摄的图片，说一肯定是因为太大了导致传输失败，那有什么就觉方法呢？</p><p>这里提供两个思路：</p><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>将图片保存到本地然后传递图片在本地的路径，这也是推荐的方法。</p><p>这种方法很好想到，保存到本地化后获取到的图片路径就是一个字符串了，肯定就可以传递了，不过这种方法比较麻烦，因为需要涉及到图片的保存操作，有一定的代码量。</p><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>将 bitmap 存储为 byte 数组，然后再通过Intent传递这个数组。</p><p>试了一下这种方法，确实可以，但是后来仔细想想，觉得还是有点疑问：将Bitmap 转化为一个 byte 数组在大小上应该不会有非常大的变化，这样按道理说还是会因为传递的数据太大而导致传输失败。或者说传递一个数组的话实际数据传递的次数增加了，这样单次传递的数据大小就更小，而一次性传递一个Bitmap对象单次传递到的数据太大？</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><p>这里主要提供一下思路2的代码</p><p>传递方：</p><pre><code class="java">Intent intent = new Intent(FirstActivity.this, SecondActivity.class);ByteArrayOutputStream outStream = new ByteArrayOutputStream();bitmap.compress(Bitmap.CompressFormat.PNG, 100, outStream);byte [] bitmapByte = outStream.toByteArray();intent.putExtra(IMAGE_PATH, bitmapByte);startActivity(intent);</code></pre><p>接收方：</p><pre><code class="java">byte [] bis=intent.getByteArrayExtra(IMAGE_PATH);Bitmap bitmap=BitmapFactory.decodeByteArray(bis, 0, bis.length);imageView.setImageBitmap(bitmap);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intent </tag>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法总结与java实现</title>
      <link href="/2018/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h3><p>排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序通过重复地走访过要排序的元素列，一次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。</p><p>这个算法的名字由来是因为越大（小）的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列）。</p><p>冒泡排序算法的原理如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>用一个图来表示一下这个过程：</p><p><img src="http://dengw.xyz/blog/180816/bdEkD9F5E0.gif" alt="enter image description here"></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 <code>C</code>和记录移动次数 <code>M</code> 均达到最小值 <code>C</code> = n - 1 ，<code>M</code> = 0 。<br>所以，冒泡排序最好的时间复杂度为 <code>O(n)</code>。</p><p>若初始文件是反序的，需要进行 n - 1 趟排序。每趟排序要进行 n - i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p><p>$$ C_{max} = n(n - 1) / 2  = O(n^2) $$</p><p>$$ M_{max} = 3n(n - 1) / 2  = O(n^2) $$</p><p>冒泡排序的最坏时间复杂度为 $O(n^2)$。<br>综上，因此冒泡排序总的平均时间复杂度为$ O(n^2) $ 。</p><h4 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。（这儿看一下下面代码中的注释）</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">    // 冒泡排序    public static void bubble_sort(int []array) {        int len = array.length;        int temp;        for(int i = 1; i &lt; len; i++) {            for(int j = 0; j &lt; len - i; j++) {                // 这里使用&gt;符号而不是&gt;=符号可以保证冒泡排序的稳定性                if(array[j] &gt; array[j + 1]) {                    temp = array[j];                    array[j] = array[j+1];                    array[j+1] = temp;                }            }        }    }</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 （或者说就简单理解为每一次都从原数组中挑选出剩余部分最小的元素插入到一个新的数组中）</p><p>用一个图来表示一下这个过程：</p><p><img src="http://dengw.xyz/blog/180816/EdFiLk3f1L.gif" alt="enter image description here"></p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>选择排序的交换操作介于 0 和 (n - 1) 次之间。选择排序的比较操作为 n (n - 1) / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1) 次之间。<br>比较次数 O(n^2)，比较次数与关键字的初始状态无关，总的比较次数 $N=(n-1)+(n-2)+…+1=n*(n-1) / 2$ 交换次数 O(n)，最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p><h4 id="算法稳定性-1"><a href="#算法稳定性-1" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>选择排序是稳定的排序算法，举个例子说明它不是稳定的，有一个序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">    // 选择排序    public static void select_sort(int []array) {        int len = array.length, temp;        int index;   // 记录当前轮最小数的下标        for(int i = 0; i &lt; len - 1; i++) {            index = i;            for(int j = i + 1; j &lt; len; j++) {                if(array[j] &lt; array[index]) {                    index = j;                }                temp = array[i];                array[i] = array[index];                array[index] = temp;            }        }    }</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序工作的时候将一个数组分为两个部分：已排序序列和未排序序列，插入排序基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据序列。</p><p>具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><p>用一个图来表示一下这个过程：</p><p><img src="http://dengw.xyz/blog/180816/jaimELb72B.gif" alt="enter image description here"></p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。</p><p>最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 (n-1) 次即可。<br>最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 n(n-1)/2 次。插入排序的赋值操作是比较操作的次数加上 (n-1) 次。</p><p>平均来说插入排序算法的时间复杂度为O(n^2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。</p><h4 id="算法稳定性-2"><a href="#算法稳定性-2" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">    // 插入排序    public static void insert_sort(int []array) {        int len = array.length, temp;        int index;  //记录已排序部分最右边的下标        for(int i = 1; i &lt; len; i++) {            index = i - 1;            temp = array[i];            while(index &gt;= 0 &amp;&amp; array[index] &gt; temp) {                array[index + 1] = array[index];                index--;            }            array[index + 1] = temp;        }    }</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>用一个来表示一下这个过程：</p><p><img src="http://dengw.xyz/blog/180816/A3CCKI4Lk9.gif" alt="enter image description here"></p><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Shell排序的时间性能优于直接插入排序</p><p>希尔排序的时间性能优于直接插入排序的原因：</p><ol><li>当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。</li><li>当n值较小时，n 和  n^2 的差别也较小，即直接插入排序的最好时间复杂度 O(n) 和最坏时间复杂度 0( n^2 ) 差别不大。</li><li>在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。</li></ol><p>所以当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比 o(n^2) 好一些。</p><h4 id="算法稳定性-3"><a href="#算法稳定性-3" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>希尔排序是非稳定排序算法，因为最开始 gap 的值是大于1的，那么就很可能让两个相等数的相对位置发生改变。</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">    // 希尔排序    public static void shell_sort(int []array) {        int len = array.length, tem;        int gap = 1;        int index;        while(gap &lt; len) {            gap = gap * 3 + 1;        }        while(gap &gt;= 1) {            for(int i = gap; i &lt; len; i++) {                index = i - gap;                tem = array[i];                while(index &gt;= 0 &amp;&amp; array[index] &gt; tem) {                    array[index + gap] = array[index];                    index -= gap;                }                array[index + gap] = tem;            }            gap = (gap - 1) / 3;        }    }</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p>用一个图来表示一下这个过程：</p><p><img src="http://dengw.xyz/blog/180816/KB7c48Lh2m.gif" alt="enter image description here"></p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>当基数值不能很好地分割数组，即基准值将数组分成一个子数组中有一个记录，而另一个子组组有 n -1 个记录时，下一次的子数组只比原来数组小 1，这是快速排序的最差的情况。如果这种情况发生在每次划分过程中，那么快速排序就退化成了冒泡排序，其时间复杂度为 O(n2)。</p><p>如果基准值都能讲数组分成相等的两部分，则出现快速排序的最佳情况。在这种情况下，我们还要对每个大小约为 n/2 的两个子数组进行排序。在一个大小为 n 的记录中确定一个记录的位置所需要的时间为 O(n)。 若T(n)为对n个记录进行排序所需要的时间，则每当一个记录得到其正确位置，整组大致分成两个相等的两部分时，我们得到快速排序算法的最佳时间复杂性。</p><pre><code>T(n) &lt;= cn + 2T(n/2)　　 &lt;= cn + 2(cn/2+2T(n/4)) = 2cn+ 4T(n/4)　　 &lt;= 2cn + 4(cn/4+ 2T(n/8)) = 3cn + 8T(n/8)    …… ……　　 &lt;= cnlogn + nT(1) = O(nlogn)</code></pre><p>其中cn 是一次划分所用的时间，c是一个常数.</p><p>最坏的情况，每次划分都得到一个子序列，时间复杂度为：</p><pre><code>T(n) = cn + T(n-1)     = cn + c(n-1) + T(n - 2) = 2cn -c + T(n-2)     = 2cn -c + c(n - 2) + T(n-3) = 3cn -3c + T(n-3)     ……     = c[n(n+1)/2-1] + T(1) =  O(n^2)</code></pre><p>快速排序的时间复杂度在平均情况下介于最佳与最差情况之间，假设每一次分割时，基准值处于最终排序好的位置的概率是一样的，基准值将数组分成长度为0 和 n-1，1 和 n-2，…… 的概率都是 1/n。在这种假设下，快速排序的平均时间复杂性为：</p><pre><code>        T(n) = cn + 1/n(T(k)+ T(n-k-1))         T(1) = c        T(0) = c</code></pre><p>这是一个递推公式，T(k)和T(n-k-1)是指处理长度为 k 和 n-k-1 数组是快速排序算法所花费的时间， 根据公式所推算出来的时间为 O(nlogn)。因此快速排序的平均时间复杂性为O(nlogn)。</p><h4 id="算法稳定性-4"><a href="#算法稳定性-4" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>因为快速排序在进行交换时，只是根据比较基数值判断是否交换，且不是相邻元素来交换，在交换过程中可能改变相同元素的顺序，因此是一种不稳定的排序算法</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">    // 快速排序函数    public static void quick_sort(int []array) {        sort(array, 0, array.length - 1);    }    // 快速排序递归部分    private static void sort(int []array, int left, int right) {        if(left &lt; right) {            int pivot = partition(array, left, right);            sort(array, left, pivot - 1);            sort(array, pivot + 1, right);        }    }    //以下标为l的元素为基准对数组进行分区并返回其在新数组中对应的位置下标    private static int partition(int[] array, int l, int r) {        int num = array[l];        while(l &lt; r) {            while(l &lt; r &amp;&amp; array[r] &gt; num) r--;            swap(array, l, r);            while(l &lt; r &amp;&amp; num &gt;= array[l]) l++;            swap(array, l ,r);        }        return l;    }    // 将特定下标的元素交换    private static void swap(int[] array, int l, int r) {        int tem = array[l];        array[l] = array[r];        array[r] = tem;    }</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p>用一个图来表示一下这个过程：<br><img src="http://dengw.xyz/blog/180816/I0D6cjDgf8.gif" alt="enter image description here"></p><p>分治的思想：<br><img src="http://dengw.xyz/blog/180816/Kjd4bA0EbK.png?imageslim" alt="enter image description here"></p><h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>归并排序的时间复杂度是O(N*lgN)。</p><p>假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？<br>归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的特点可以得到遍历次数为 O(logN)<br>可以得出它的时间复杂度是 O(N*logN)。</p><h4 id="稳定分析"><a href="#稳定分析" class="headerlink" title="稳定分析"></a>稳定分析</h4><p>归并排序是稳定的算法，当两个元素相等时，进行相等比较不会改变他们之间的相对位置。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">    // 归并排序（分治的思想）    public static void merge_sort(int []array)  {        int len = array.length;        //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间        int []temp = new int[len];        sort(array, 0, len - 1, temp);    }    // “分”的部分    private static void sort(int []array, int left, int right, int []temp) {        if(left &lt; right) {            int mid = (left + right) / 2;            // 左边归并排序，使得左子序列有序            sort(array, left, mid, temp);            // 右边归并排序，使得右子序列有序            sort(array, mid + 1, right, temp);            // 将两个有序子数组合并操作            merge(array, left, mid, right, temp);        }    }    // “治”的部分    private static void merge(int []array, int left, int mid, int right, int []temp) {        int i = left, j = mid + 1;        int index = 0;        // 依次将两个子数组中的较小值填入新数组        while(i &lt;= mid &amp;&amp; j &lt;= right) {            if(array[i] &lt;= array[j]) {                temp[index++] = array[i++];            } else {                temp[index++] = array[j++];            }        }        // 当其中一个子数组已经将所有数填入新数组后        while(i &lt;= mid) {            temp[index++] = array[i++];        }        while(j &lt;= right) {            temp[index++] = array[j++];        }        // 长度为right - left        index = 0;        while(left &lt;= right) {            array[left++] = temp[index++];        }    }</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序也是第一次接触，贴一下自己的学习博客吧；<br><a href="http://www.cnblogs.com/MOBIN/p/5374217.html" target="_blank" rel="noopener">参考文章1</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">参考文章2</a></p><p>用一张图片来表示一下这个过程：<br><img src="http://dengw.xyz/blog/180816/Gji4ajH90E.gif" alt="enter image description here"></p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="java">    // 堆排序    public static void heap_sort(int []array) {        int tail = array.length - 1;  //当前尾部元素的下标        // 从tail / 2 - 1到0的下标对应的元素才有子节点        for (int i = tail / 2 - 1; i &gt;= 0; i--) {            headAdjust(array, i, tail);        }        while(tail &gt;= 0) {            // 堆顶元素和tail下标对应的元素交换(堆顶元素为当前0~tail中的最大值)            swap(array, 0, tail--);            headAdjust(array, 0, tail);        }    }    private static void headAdjust(int []array, int index, int tail) {        int left, right, i;  //left表示index下标对应元素的左子节点的下标，right同理        while((left = 2 * index + 1) &lt;= tail) {            right = left + 1;            i = left;            if(i &lt; tail &amp;&amp; array[left] &lt; array[right]) i++;  // 此时i表示两个子节点的较大值的下标            if(array[index] &lt; array[i]) {   // 保证父节点的值大于两个子节点的值                swap(array, index, i);            } else {                // 如果父节点已经大于两个子节点直接跳出循环                break;            }            /**             * 交换后的子节点还有父节点的情况             * 这种情况发生在整个树的根节点发生一下交换后             * 继续执行while循环             */            index = i;        }    }    // 将特定下标的元素交换    private static void swap(int[] array, int i, int j) {        int tem = array[i];        array[i] = array[j];        array[j] = tem;    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解HTTP学习笔记—第五章</title>
      <link href="/2018/08/14/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2018/08/14/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><p>今天继续我们HTTP的学习，今天的内容是HTTP报文中一个重要的组成部分—HTTP 首部字段；</p><p>前面我们分析HTTP报文的时候说到HTTP报文就由首部和实体两个部分组成，而首部字段就是首部的组要组成成分之一，可以说首部字段包含了HTTP报文丰富的信息，是构成HTTP的重要要素，下面详细介绍一下：</p><h2 id="HTTP-首部字段的通用结构"><a href="#HTTP-首部字段的通用结构" class="headerlink" title="HTTP 首部字段的通用结构"></a>HTTP 首部字段的通用结构</h2><p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。<br><code>首部字段名: 字段值</code></p><p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。<br><code>Content-Type: text/html</code><br>就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。</p><p>另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。<br><code>Keep-Alive: timeout=15, max=100</code></p><h2 id="HTTP-首部字段的分类"><a href="#HTTP-首部字段的分类" class="headerlink" title="HTTP 首部字段的分类"></a>HTTP 首部字段的分类</h2><ul><li><p><strong>通用首部字段</strong><br>请求报文和响应报文两方都会使用的首部字段。</p></li><li><p><strong>请求首部字段</strong><br>从客户端向服务器端发送请求报文时使用的首部字段。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p></li><li><p><strong>相应首部字段</strong><br>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p></li><li><p><strong>实体首部字段</strong><br>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p></li></ul><p>下面就详细介绍一下 HTTP/1.1 版本中各类型都包含了哪些首部字段以及各自的含义：</p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p><p>指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。</p><h5 id="Cache-Control-指令一览"><a href="#Cache-Control-指令一览" class="headerlink" title="Cache-Control 指令一览"></a>Cache-Control 指令一览</h5><p>可用的指令按请求和响应分类如下所示。</p><p>缓存请求指令：<br><img src="http://dengw.xyz/blog/180814/GjlklGhAdI.png?imageslim" alt="缓存请求指令"></p><p>缓存响应指令：<br><img src="http://dengw.xyz/blog/180814/LHeemC3Ihk.png?imageslim" alt="enter image description here"></p><h6 id="表示是否能缓存的指令包括："><a href="#表示是否能缓存的指令包括：" class="headerlink" title="表示是否能缓存的指令包括："></a>表示是否能缓存的指令包括：</h6><ul><li><p>public 指令</p><pre><code>Cache-Control: public</code></pre><p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。 </p></li><li><p>private 指令</p><pre><code>Cache-Control: private</code></pre><p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。<br>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。</p></li><li><p>no-cache 指令</p><pre><code>Cache-Control: no-cache</code></pre><p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。<br>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。</p></li></ul><pre><code>Cache-Control: no-cache=Location</code></pre><p>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首 部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首 部字段可以使用缓存。只能在响应指令中指定该参数。</p><ul><li>no-store 指令<pre><code>Cache-Control: no-store </code></pre>当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。</li></ul><p>从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓 存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存。</p><h6 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h6><ul><li><p>s-maxage 指令</p><pre><code>Cache-Control: s-maxage=604800（单位 ：秒）</code></pre><p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何 作用。另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。 </p></li><li><p>max-age 指令</p><pre><code>Cache-Control: max-age=604800（单位：秒）</code></pre><p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。 另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发 给源服务器。<br>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源 的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时 间。<br>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情 况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略。</p></li><li><p>min-fresh 指令</p><pre><code>Cache-Control: min-fresh=60（单位：秒）</code></pre><p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。 比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响 应返回了。</p></li><li><p>max-stale 指令</p><pre><code>Cache-Control: max-stale=3600（单位：秒）</code></pre><p>使用 max-stale 可指示缓存资源，即使过期也照常接收。<br>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收</p></li><li><p>only-if-cached 指令</p><pre><code>Cache-Control: only-if-cached</code></pre><p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资 源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout。</p></li><li><p>must-revalidate 指令</p><pre><code>Cache-Control: must-revalidate</code></pre><p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。<br>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）。</p><ul><li>proxy-revalidate 指令</li></ul></li></ul><pre><code>Cache-Control: proxy-revalidate</code></pre><p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。</p><ul><li>no-transform 指令<pre><code>Cache-Control: no-transform</code></pre>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</li></ul><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>Connection 首部字段具备如下两个作用。</p><ul><li><p>控制不再转发给代理的首部字段<br><img src="http://dengw.xyz/blog/180814/gDAj4083Dm.png?imageslim" alt="enter image description here"></p><pre><code>Connection: 不再转发的首部字段名</code></pre><p>在客户端发送请求和服务器返回响应内，使用 Connection 首部字 段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首 部）。</p></li><li><p>管理持久连接<br><img src="http://dengw.xyz/blog/180814/6dKcfJ4DlG.png?imageslim" alt="enter image description here"><br>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</p></li></ul><pre><code>Connection: Keep-Alive</code></pre><p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。<br>如上图①所示，客户端发送请求给服务器时，服务器端会像上图 ②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回 响应。</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>首部字段 Date 表明创建 HTTP 报文的日期和时间。<br>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式，如下 示 例。</p><pre><code>Date: Tue, 03 Jul 2012 04:40:59 GMT</code></pre><p>之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示。</p><pre><code>Date: Tue, 03-Jul-12 04:40:59 GMT</code></pre><p>除此之外，还有一种格式。它与 C 标准库内的 asctime() 函数的输出 格式一致。</p><pre><code>Date: Tue Jul 03 04:40:59 2012</code></pre><h4 id="Pragma-Pragma"><a href="#Pragma-Pragma" class="headerlink" title="Pragma Pragma"></a>Pragma Pragma</h4><p>是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br>规范定义的形式唯一，如下所示。</p><pre><code>Pragma: no-cache</code></pre><p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p><p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握 全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的 请求会同时含有下面两个首部字段。</p><pre><code>Cache-Control: no-cache Pragma: no-cache</code></pre><h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p><img src="http://dengw.xyz/blog/180814/CbHA8jjk5b.png?imageslim" alt="enter image description here"><br>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。</p><pre><code>HTTP/1.1 200 OK Date: Tue, 03 Jul 2012 04:40:56 GMT Content-Type: text/html ... Transfer-Encoding: chunked Trailer: Expires ...(报文主体)... 0Expires: Tue, 28 Sep 2004 23:59:59 GMT </code></pre><p> 以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后 （分块长度 0 之后）出现了首部字段 Expires。 </p><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p><pre><code>HTTP/1.1 200 OK Date: Tue, 03 Jul 2012 04:40:56 GMT Cache-Control: public, max-age=604800 Content-Type: text/javascript; charset=utf-8Expires: Tue, 10 Jul 2012 04:40:56 GMT X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Content-Encoding: gzip Transfer-Encoding: chunked Connection: keep-alive cf0    ←16进制(10进制为3312) ...3312字节分块数据... 392    ←16进制(10进制为914) ...914字节分块数据... 0</code></pre><p>以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据</p><h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。<br><img src="http://dengw.xyz/blog/180814/2hhFg4e9if.png?imageslim" alt="enter image description here"></p><p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两 个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。 Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务 器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 <code>Connection:Upgrade</code>。 对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p><h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。</p><p>报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信 息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。</p><p>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 所以必须在经过代理时附加该首部字段内容。<br><img src="http://dengw.xyz/blog/180814/FbKhJEBha2.png?imageslim" alt="enter image description here"></p><p>上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如 此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服 务器信息。</p><p>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使 用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况 下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响 应。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演 变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p><pre><code>Warning: 113 gw.hackr.jp:8080 &quot;Heuristic expiration&quot; Tue, 03 Jul 2012 </code></pre><p>Warning 首部的格式如下。最后的日期时间部分可省略。</p><pre><code>Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</code></pre><p>HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。 另外，警告码具备扩展性，今后有可能追加新的警告码。</p><p>HTTP/1.1 警告码<br><img src="http://dengw.xyz/blog/180814/9kfjGdCIb8.png?imageslim" alt="enter image description here"></p><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段， 用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p><img src="http://dengw.xyz/blog/180814/edHDf3hm1h.png?imageslim" alt="enter image description here"></p><pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.</code></pre><p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒 体类型。</p><p>下面我们试举几个媒体类型的例子。</p><ul><li>文本文件<br>text/html, text/plain, text/css … application/xhtml+xml, application/xml …</li><li>图片文件<br>image/jpeg, image/gif, image/png …</li><li>视频文件<br>video/mpeg, video/quicktime …</li><li>应用程序使用的二进制文件<br>application/octet-stream, application/zip …</li></ul><p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。 </p><p>若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点 后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。</p><h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p><img src="http://dengw.xyz/blog/180814/ff5fad71C2.png?imageslim" alt="enter image description here"></p><pre><code>Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</code></pre><p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及 字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字 段 Accept 相同的是可用权重 q 值来表示相对优先级。</p><p>该首部字段应用于内容协商机制的服务器驱动协商。</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p><img src="http://dengw.xyz/blog/180814/g6fJLcg1Jm.png?imageslim" alt="enter image description here"></p><pre><code>Accept-Encoding: gzip, deflate</code></pre><p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。</p><p>下面试举出几个内容编码的例子。</p><ul><li>gzip<br>由文件压缩程序 gzip（GNU zip）生成的编码格式 （RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余 校验（Cyclic Redundancy Check，通称 CRC）。 </li><li>compress<br>由 UNIX 文件压缩程序 compress 生成的编码格式，采用 LempelZiv-Welch 算法（LZW）。</li><li>deflate 组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法 （RFC1951）生成的编码格式。 </li><li>identity<br>不执行压缩或不会变化的默认编码格式</li></ul><p>采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另 外，也可使用星号（*）作为通配符，指定任意的编码格式。</p><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><pre><code>Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3`</code></pre><p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级。可一次 指定多种自然语言集。</p><p>和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图 例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版 对应的响应，没有中文版时，则请求返回英文版响应。 </p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p><img src="http://dengw.xyz/blog/180814/lCihFcF7CJ.png?imageslim" alt="enter image description here"></p><pre><code>Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</code></pre><p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证 书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存 在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p><h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><pre><code>Expect: 100-continue</code></pre><p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行 为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回 状态码 417 Expectation Failed。 </p><p>客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规 范只定义了 100-continue（状态码 100 Continue 之意）。 </p><p>等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100continue。 </p><h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的 电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但 可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段 内）。</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p><img src="http://dengw.xyz/blog/180814/GkGBgE5gLB.png?imageslim" alt="enter image description here"><br>图：虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以 区分</p><pre><code>Host: www.hackr.jp</code></pre><p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端 口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请 求内的首部字段。</p><p>首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制 有很密切的关联，这是首部字段 Host 必须存在的意义。 </p><p>请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解 决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务 器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部 字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直 接发送一个空值即可。如下所示。</p><pre><code>Host:</code></pre><h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p><img src="http://dengw.xyz/blog/180814/8d828JcJK6.png?imageslim" alt="enter image description here"><br>附带条件请求</p><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。<br><img src="http://dengw.xyz/blog/180814/haFIJHdbC8.png?imageslim" alt="enter image description here"><br>图：只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求</p><pre><code>If-Match: &quot;123456&quot;</code></pre><p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用 的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。</p><p>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致 时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响 应。</p><p>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务 器将会忽略 ETag 的值，只要资源存在就处理请求。 </p><h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p><img src="http://dengw.xyz/blog/180814/3B3clL8Bc9.png?imageslim" alt="enter image description here"><br>图：如果在 If-Modified-Since 字段指定的日期时间后，资源发生了 更新，服务器会接受请求</p><pre><code>If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT</code></pre><p>首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 IfModified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应。</p><p> If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确 定。</p><h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p><img src="http://dengw.xyz/blog/180814/I8C1lchidL.png?imageslim" alt="enter image description here"><br>图：只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理 该请求。与 If-Match 首部字段的作用相反</p><p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。 </p><p>在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资 源。因此，这与使用首部字段 If-Modified-Since 时有些类似。 </p><h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p><img src="http://dengw.xyz/blog/180814/fDA2m8E1gB.png?imageslim" alt="enter image description here"></p><p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 IfRange 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。反之，则返回全体资源。</p><p><img src="http://dengw.xyz/blog/180814/eAkI5LiHHH.png?imageslim" alt="enter image description here"></p><p>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器 端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当 然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请 求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的 功夫。</p><h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><pre><code class="`">If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT</code></pre><p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相 反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定 日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应 返回。</p><h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h4><p><img src="http://dengw.xyz/blog/180814/bKi3fcK210.png?imageslim" alt="enter image description here"><br>图：每次转发数值减 1。当数值变 0 时返回响应</p><pre><code>Max-Forwards: 10</code></pre><p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最 大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的 值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求 时，则不再进行转发，而是直接返回响应。</p><p>使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中， 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到 服务器返回的响应了。对此，我们无从可知。</p><p>可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展 开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回 响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状 况有所把握。<br><img src="http://dengw.xyz/blog/180814/2bBGldEkff.png?imageslim" alt="enter image description here"></p><p>图：代理 B 到源服务器的请求失败了，但客户端不知道<br><img src="http://dengw.xyz/blog/180814/FB6KL0eLjK.png?imageslim" alt="enter image description here"><br>图：由于未知原因，导致请求陷入代理之间的循环，但客户端不 知道</p><h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><pre><code>Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</code></pre><p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。 </p><p>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同 之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间 的认证，使用首部字段 Authorization 可起到相同作用。</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><pre><code>Range: bytes=5001-10000</code></pre><p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。</p><p>上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p><img src="http://dengw.xyz/blog/180814/e9b450hJ3I.png?imageslim" alt="enter image description here"></p><pre><code>Referer: http://www.hackr.jp/index.htm</code></pre><p>首部字段 Referer 会告知服务器请求的原始资源的 URI。 客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器 的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字 段。</p><p>因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信 息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的 泄露。</p><p>另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直 沿用这个错误的拼写。</p><h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><pre><code>TE: gzip, deflate;q=0.5</code></pre><p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相 对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于 传输编码。</p><p>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分 块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。</p><pre><code>TE: trailers</code></pre><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><pre><code>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010</code></pre><p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传 达给服务器。</p><p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件 地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服 务器的名称。 </p><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p><img src="http://dengw.xyz/blog/180814/H1f57jFldI.png?imageslim" alt="enter image description here"><br>图：当不能处理范围请求时，Accept-Ranges: none</p><pre><code>Accept-Ranges: bytes</code></pre><p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。</p><p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则 指定其为 none。 </p><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p><img src="http://dengw.xyz/blog/180814/8C1Fb7gCGF.png?imageslim" alt="enter image description here"></p><p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。</p><p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次 发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。 </p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p><img src="http://dengw.xyz/blog/180814/H5DGaBaIG7.png?imageslim" alt="enter image description here"></p><pre><code>ETag: &quot;82e22293907ce725faf67773957acd12&quot;</code></pre><p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串 形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p><p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有 统一的算法规则，而仅仅是由服务器来分配</p><p><img src="http://dengw.xyz/blog/180814/bf6ClBl94A.png?imageslim" alt="enter image description here"></p><p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览 器访问 <a href="http://www.google.com/" target="_blank" rel="noopener">http://www.google.com/</a> 时，就会返回中文版对应的资源，而 使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的 URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下 载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。</p><p>强 ETag 值和弱 Tag 值 : ETag 中有强 ETag 值和弱 ETag 值之分。 </p><ul><li><p>强 ETag 值<br>强 ETag 值，不论实体发生多么细微的变化都会改变其值。</p><pre><code>ETag: &quot;usagi-1234&quot;</code></pre></li><li><p>弱 ETag 值<br>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产 生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。</p><pre><code>ETag: W/&quot;usagi-1234&quot;</code></pre></li></ul><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p><img src="http://dengw.xyz/blog/180814/EgblJ49c5k.png?imageslim" alt="enter image description here"></p><pre><code>Location: http://www.usagidesign.jp/sample.html</code></pre><p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置 不同的资源。</p><p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强 制性地尝试对已提示的重定向资源的访问。</p><h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><pre><code>Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</code></pre><p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送 给客户端。</p><p>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在 于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间 进行认证时，首部字段 WWW-Authorization 有着相同的作用。</p><h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="　Retry-After"></a>　Retry-After</h4><p><img src="http://dengw.xyz/blog/180814/9gDiD7A7ih.png?imageslim" alt="enter image description here"></p><pre><code>Retry-After: 120</code></pre><p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要 配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使 用。</p><p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。 </p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p><img src="http://dengw.xyz/blog/180814/8DgmmKBdla.png?imageslim" alt="enter image description here"></p><pre><code>Server: Apache/2.2.17 (Unix)</code></pre><p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程 序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版 本号和安装时启用的可选项。</p><pre><code>Server: Apache/2.2.6 (Unix) PHP/5.2.5</code></pre><h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p><img src="http://dengw.xyz/blog/180814/fFE3hbf2FE.png?imageslim" alt="enter image description here"><br>图：当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓 存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回</p><pre><code>Vary: Accept-Language</code></pre><p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关 于本地缓存使用方法的命令。</p><p>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若 再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回 缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相 同，因此必须要从源服务器重新获取资源。</p><h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><pre><code>WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</code></pre><p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端 适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和 带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。 </p><p>上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。</p><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p><img src="http://dengw.xyz/blog/180814/cif77Ghaj5.png?imageslim" alt="enter image description here"></p><pre><code>Allow: GET, HEAD</code></pre><p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支 持的 HTTP 方法写入首部字段 Allow 后返回。 </p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><pre><code>Content-Encoding: gzip`</code></pre><p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p><p>主要采用以下 4 种内容编码的方式。（各方式的说明请参考请求首部字段中 Accept-Encoding 字段）。</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity </li></ul><h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><pre><code>Content-Language: zh-CN</code></pre><p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言 （指中文或英文等语言）。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><pre><code>Content-Length: 15000</code></pre><p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字 节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。</p><h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><pre><code>Content-Location: http://www.hackr.jp/index-ja.html</code></pre><p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。 比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当 返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。（访问 <a href="http://www.hackr.jp/" target="_blank" rel="noopener">http://www.hackr.jp/</a> 返回的对象却是 <a href="http://www.hackr.jp/index-ja.html" target="_blank" rel="noopener">http://www.hackr.jp/index-ja.html</a> 等类似情况） </p><h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><p><img src="http://dengw.xyz/blog/180814/c70A6j3A9F.png?imageslim" alt="enter image description here"><br>图：客户端会对接收的报文主体执行相同的 MD5 算法，然后与首 部字段 Content-MD5 的字段值比较</p><pre><code>Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</code></pre><p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检 查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><p>对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编 码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进 制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接 收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p><p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出 恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味 着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户 端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过 的。</p><h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p><img src="http://dengw.xyz/blog/180814/6FhfB3241j.png?imageslim" alt="enter image description here"></p><pre><code>Content-Range: bytes 5001-10000/10000</code></pre><p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为 单位，表示当前发送部分及整个实体大小。</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><pre><code>Content-Type: text/html; charset=UTF-8</code></pre><p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样，字段值用 type/subtype 形式赋值。 </p><p>参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。 </p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><img src="http://dengw.xyz/blog/180814/jHg7ekA857.png?imageslim" alt="enter image description here"></p><pre><code>Expires: Wed, 04 Jul 2012 08:26:05 GMT</code></pre><p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接 收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过 指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求 资源。</p><p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。 </p><p>但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令。 </p><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p><img src="http://dengw.xyz/blog/180814/Ki1fECLmfD.png?imageslim" alt="enter image description here"></p><pre><code>Last-Modified: Wed, 23 May 2012 09:59:55 GMT</code></pre><p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个 值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进 行动态数据处理时，该值有可能会变成数据最终修改时的时间。 </p><h3 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h3><p>上面列的这些首部字段都是被编入标准化 HTTP/1.1 的 RFC2616 中的字段，但是还有一些很重要的，经常使用的，却没有列入该标准的字段，管理服务器与客户端之间状态的 Cookie 就包括了这些字段。</p><p>Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的 状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。 </p><p>调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路 径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露。<br>为 Cookie 服务的首部字段包括：</p><ul><li>Set-Cookie：开始状态管理所使用的Cookie信息，是一种响应首部字段 </li><li>Cookie：服务器接收到的Cookie信息，是一种请求首部字段</li></ul><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><pre><code>Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path</code></pre><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p><p>下面的表格列举了 Set-Cookie 的字段值。<br>| 属性 | 说明 |<br>| :——– | :——– |<br>| NAME=VALUE | 赋予 Cookie 的名称和其值（必需项）|<br>| expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|<br>| path=PATH | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默 认为文档所在的文件目录）|<br>| domain=域名 | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名）|<br>| Secure | 仅在 HTTPS 安全通信时才会发送 Cookie |<br>| HttpOnly | 加以限制，使 Cookie 不能被 JavaScript 脚本访问 |</p><ul><li>expires 属性</li></ul><p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。 </p><p>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session） 时间段内。这通常限于浏览器应用程序被关闭之前。</p><p>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可 以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对 客户端 Cookie 的实质性删除操作。</p><ul><li>path 属性</li></ul><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。 不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱 有期待。</p><ul><li>domain 属性 </li></ul><p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比 如，当指定 example.com 后，除 example.com 以外，<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 或 www2.example.com 等都可以发送 Cookie。 </p><p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</p><ul><li>secure 属性 </li></ul><p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才 可以发送 Cookie。</p><p>发送 Cookie 时，指定 secure 属性的方法如下所示。</p><pre><code>Set-Cookie: name=value; secure</code></pre><p>以上例子仅当在 <a href="https://www.example.com/（HTTPS）安全连接的情况" target="_blank" rel="noopener">https://www.example.com/（HTTPS）安全连接的情况</a> 下才会进行 Cookie 的回收。也就是说，即使域名相同， <a href="http://www.example.com/（HTTP）也不会发生" target="_blank" rel="noopener">http://www.example.com/（HTTP）也不会发生</a> Cookie 回收行为。 </p><p>当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行 回收。</p><ul><li>HttpOnly 属性 </li></ul><p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本 无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。 </p><p>发送指定 HttpOnly 属性的 Cookie 的方法如下所示。</p><pre><code>Set-Cookie: name=value; HttpOnly</code></pre><p>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。 但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后 的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p><p> 虽然是独立的扩展功能，但 Internet Explorer 6 SP1 以上版本等当下的 主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了 防止 XSS 而开发的。 </p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><pre><code>Cookie: status=enable</code></pre><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支 持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。 </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树三种遍历方式的Java实现</title>
      <link href="/2018/08/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>之前学习数据结构的时候使用过 C++ 实现过二叉树的三种遍历方法，其中包括递归实现和非递归实现。现在在准备秋招，感觉这部分还是非常重要的，就想用 java 再实现一下。</p><p>这里就不再对什么是现需、中序和后序遍历解释了，着重代码实现，一些重要的代码会给出注释。</p><p>树的节点定义：</p><pre><code class="java">public class TreeNode {    int val = 0;    TreeNode left = null;    TreeNode right = null;    public TreeNode(int val) {        this.val = val;    }}</code></pre><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><h5 id="实现方法1"><a href="#实现方法1" class="headerlink" title="实现方法1"></a>实现方法1</h5><p>　　根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下：</p><p>　　对于任一结点P：</p><ol><li>访问结点P，并将结点P入栈;</li><li>判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1);若不为空，则将P的左孩子置为当前的结点P;</li><li>直到P为NULL并且栈为空，则遍历结束。</li><li><pre><code class="java">public static ArrayList&lt;Integer&gt; preOrder1(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode tem = root; while(tem != null || !stack.empty()) {     while( tem != null) {         res.add(tem.val);         stack.push(tem);         tem = tem.left;     }     if(!stack.empty()) {         tem = stack.pop();         tem = tem.right;     } } return res;}</code></pre><h5 id="实现方法2"><a href="#实现方法2" class="headerlink" title="实现方法2"></a>实现方法2</h5><p>这就是充分利用栈的特点了，体会一下先进后出的体现。</p><pre><code class="java"> // 前序遍历的非递归实现 public static ArrayList&lt;Integer&gt; preOrder2(TreeNode root) {     ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();     if(root == null) return res;     Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();     stack.push(root);     TreeNode tem;     while(!stack.empty()) {    // 进入循环的条件是栈不为空         tem = stack.pop();     // 获取并弹出栈顶元素         res.add(tem.val);         /*          * 注意因为使用的是栈结构，先入后出,          * 所以先把右边的节点入栈          */         if (tem.right != null) {             stack.push(tem.right);         }         if (tem.left != null) {             stack.push(tem.left);         }     }     return res; }</code></pre></li></ol><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>递归就很简单了，直接在代码层面就可以体现出前序遍历的特点。</p><pre><code class="java">    // 前序遍历的递归实现    public static ArrayList&lt;Integer&gt; preOrder_recursion(TreeNode root)  {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();        if(root == null) return res;        // 开始递归调用        preOrder_recursion_body(root, res);        return res;    }    private static void preOrder_recursion_body(TreeNode root, ArrayList&lt;Integer&gt; res) {        if(root != null) {            res.add(root.val);            preOrder_recursion_body(root.left, res);            preOrder_recursion_body(root.right, res);        }    }</code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h4><h5 id="实现方法1-1"><a href="#实现方法1-1" class="headerlink" title="实现方法1"></a>实现方法1</h5><p>　　根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。因此其处理过程如下：</p><p>　　对于任一结点P: </p><ol><li>若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；</li><li>若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；</li><li><p>直到P为NULL并且栈为空则遍历结束。</p><pre><code class="java"> public static ArrayList&lt;Integer&gt; inOrder1(TreeNode root) {     ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();     if(root == null) return res;     Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();     TreeNode tem = root;     while(tem != null || !stack.empty()) {         while(tem != null) {             stack.push(tem);             tem = tem.left;         }         if(!stack.empty()) {             tem = stack.pop();             res.add(tem.val);             tem = tem.right;         }     }     return res; }</code></pre><h5 id="实现方法2-1"><a href="#实现方法2-1" class="headerlink" title="实现方法2"></a>实现方法2</h5><p>跟上面的思路类似，只是实现方式有点区别。</p><pre><code class="java"> // 中序遍历的非递归实现 public static ArrayList&lt;Integer&gt; inOrder2(TreeNode root) {     ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();     if (root == null) return res;     Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();     stack.push(root);     TreeNode temp;     while (!stack.empty())     {         temp = stack.peek();         if (temp.left != null) {    //一直遍历左节点             stack.push(temp.left);             temp.left = null;         } else {             TreeNode p = stack.pop();             res.add(p.val);             if (p.right != null) {                 stack.push(p.right);             }         }     }     return res; }</code></pre><h4 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h4><p>很形象了。</p><pre><code class="java"> // 中序遍历的递归实现 public static ArrayList&lt;Integer&gt; inOrder_recursion(TreeNode root)  {     ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();     if (root == null) return res;     inOrder_recursion_body(root, res);     return res; } private static void inOrder_recursion_body(TreeNode root, ArrayList&lt;Integer&gt; res) {     if(root != null) {         inOrder_recursion_body(root.left, res);         res.add(root.val);         inOrder_recursion_body(root.right, res);     } }</code></pre></li></ol><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h4><p>思路: 要保证根结点在其左孩子和右孩子访问之后才能访问，因此对于任一结点p，先将其入栈。如果 p 不存在左孩子和右孩子（左子树和右子树都指向空的时候），则可直接访问；否则将 p 的右孩子和左孩子依次入栈然后把 p 的左右孩子结点赋值null，这样就保证了每次取栈顶的元素的时候左孩子在右孩子前面被访问, 左孩子和右孩子都在根结点前面被访问。</p><pre><code class="java">    // 后序遍历的非递归实现    public static ArrayList&lt;Integer&gt; postOrder(TreeNode root) {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();        if(root == null) return res;        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();        stack.push(root);        TreeNode temp;        while (!stack.isEmpty())        {            temp = stack.peek();            if (temp.left == null &amp;&amp; temp.right == null)            {                TreeNode pop = stack.pop();                res.add(pop.val);            } else {                if (temp.right != null) {                    stack.push(temp.right);                    temp.right = null;                }                if (temp.left != null) {                    stack.push(temp.left);                    temp.left = null;                }            }        }        return res;    }</code></pre><h4 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h4><pre><code class="java">    // 后序遍历的递归实现    public static ArrayList&lt;Integer&gt; postOrder_recursion(TreeNode root)  {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();        if(root == null) return res;        postOrder_recursion_body(root, res);        return res;    }    public static void postOrder_recursion_body(TreeNode root, ArrayList&lt;Integer&gt; res) {        if(root != null) {            postOrder_recursion_body(root.left, res);            postOrder_recursion_body(root.right, res);            res.add(root.val);        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer刷题总结</title>
      <link href="/2018/08/09/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/09/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>今天开始刷算法题了，本来想刷LeetCode上面的题的，但是想到时间比较紧，LeetCode上的题太多了，剑指Offer上面的66道题涵盖的题型也比较全，对付秋招应该足够了，本博客主要记录一下自己的答案，如果有什么比较新奇的想法的话也记录一下，希望能有收获。</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>第一天刷了4道题，还是挺快的，前3道都是十分钟之内AC，第4题花的时间稍长一点。</p><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public static boolean Find(int target, int [][] array)     {        int m = array.length;        int n = array[0].length;        for(int i = m - 1; i &gt;= 0; i--) {            for(int j = 0; j &lt; n; j++) {                if (array[i][j] == target){                    return true;                } else if (array[i][j] &gt; target) {                    break;                }            }        }        return false;    }}</code></pre><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public String replaceSpace(StringBuffer str) {        String strs = str.toString();        return strs.replaceAll(&quot; &quot;, &quot;%20&quot;);    }}</code></pre><p>用了一个比较巧妙的方法，直接只用 java 中 String 类的 replaceAll 函数，作用是将一个字符串中某个字符串用另外一个字符串代替。</p><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">/***    public class ListNode {*        int val;*        ListNode next = null;**        ListNode(int val) {*            this.val = val;*        }*    }**/public class Solution {    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        while(listNode != null)  {            list.add(0, listNode.val);            listNode = listNode.next;        }        return list;    }}</code></pre><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code>public class Solution {    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {        TreeNode root = run(pre, 0, pre.length - 1, in, 0, pre.length - 1);        return root;    }        public static TreeNode run(int [] pre, int pl, int pr, int [] in, int il, int ir) {        if(pl &gt; pr || il &gt; ir) return null;        TreeNode node = new TreeNode(pre[pl]);        int i;        for(i = il; i&lt;= ir; i++) {            if(pre[pl] == in[i]) {                break;            }        }        int len = i - il;        node.left = run(pre, pl + 1, pl + len, in, il, i - 1);        node.right = run(pre, pl + len + 1, pr, in, i + 1, ir);        return node;    }}</code></pre><ol><li>先求出根节点（前序序列第一个元素）。</li><li>将根节点带入到中序遍历序列中求出左右子树的中序遍历序列。</li><li>通过左右子树的中序序列元素集合带入前序遍历序列可以求出左右子树的前序序列。</li><li>左右子树的前序序列第一个元素分别是根节点的左右儿子</li><li>求出了左右子树的4种序列可以递归上述步骤</li></ol><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>今天没什么事就多做了几道题，总的来说不难，花的时间都不多，不过还是发现了问题，个人对java中的引用感觉还不是很熟悉，感觉和 C++ 中的指针挺像的，在链表中结构中两个对象赋值传递还分不太清楚，还需要额外花一点时间练习一下。</p><h3 id="用两个栈来实现一个队列"><a href="#用两个栈来实现一个队列" class="headerlink" title="用两个栈来实现一个队列"></a>用两个栈来实现一个队列</h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();    public void push(int node) {        stack1.push(node);    }    public int pop() {        if(stack2.size() &gt; 0) return stack2.pop();        while(stack1.size() &gt; 0) {            stack2.push(stack1.pop());        }        return stack2.pop();    }}</code></pre><p>直接把stack1当作队列尾，stack2当作队列头，具体的做法就是添加元素的时候直接加到stack1中，取出元素的时候做一个判断，如果stack2中没有元素的话就把stack1中的所有元素倒腾到stack2中，如果stack2中还有元素的话就直接pop栈顶部的元素。</p><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public int minNumberInRotateArray(int [] array) {        int len = array.length;        if(len == 0) return 0;        for(int i = 0; i &lt; len; i++) {            if(array[i] &gt; array[i + 1]) {                return array[i + 1];            }        }        return array[0];    }}</code></pre><p>这道题时间复杂度为 O(N) 的方法有很多，一种方法就是直接查找数组的最小数字即可。但是为了使用到旋转数组的特点，我们知道一个旋转数组套么就是一个非完全递增数组，要么就是两个非完全递增数组组合起来的并且前一个数组的每一个值都大于后面一个数组的值，利用这个特点构建算法。</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public int Fibonacci(int n) {        if(n == 0) return 0;        if(n == 1) return 1;        int a = 1; int b = 0;        for(int i = 2; i &lt;= n; i++) {            int tem = a;            a += b;            b = tem;        }        return a;    }}</code></pre><p>f(n) = f(n - 1) + f(n - 2)</p><p>###跳台阶</p><h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public int JumpFloor(int target) {        if(target == 0) return 0;        if(target == 1) return 1;        int a = 1, b = 1;        for(int i = 2; i &lt;= target; i++) {            int tem = a;            a += b;            b = tem;        }        return a;    }}</code></pre><p>斐波那契数列的应用</p><h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><h4 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution {public:    int jumpFloorII(int number) {        if(number == 1) return 1;        return 2 * jumpFloorII(number- 1);    }};</code></pre><p>f(0) = 1;<br>f(1) = f(0);<br>f(2) = f(0) + f(1) ;<br>f(3) = f(0) + f(1) + f(2);<br>….<br>f(n - 1) = f(0) + f(1) + f(2) + f(3) + … + f(n-2);<br>f(n) = f(0) + f(1) + f(2) + f(3) +…+ f(n-2) + f(n - 1) = f(n - 1) + f(n - 1) = 2 f(n - 1);</p><h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h3><h4 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h4><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">class Solution {public:    int rectCover(int number) {        if(number &lt;= 2) return number;        return rectCover(number-1) + rectCover(number-2);    }};</code></pre><p>斐波那契数列的应用</p><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><h4 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public int NumberOf1(int n) {        int count = 0;        while(n != 0) {            count++;            n = n &amp; (n - 1);        }        return count;    }}</code></pre><p>位运算，想通了就很简单了</p><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><h4 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a>描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public void reOrderArray(int [] array) {        List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();        List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();        for(int i = 0; i &lt; array.length; i++) {            if(array[i] % 2 == 0) {                list2.add(array[i]);            } else {                list1.add(array[i]);            }        }        int n = list1.size();        for(int i = 0; i &lt; n; i++) {            array[i] = list1.get(i);        }        for(int i = 0; i &lt; list2.size(); i++) {            array[i + n] = list2.get(i);        }    }}</code></pre><h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h3><h4 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a>描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。</p><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public ListNode FindKthToTail(ListNode head, int k) {        if(head == null || k == 0) return null;        Stack&lt;ListNode&gt; list = new Stack&lt;&gt;();        int count = 0;        while(head != null) {            count++;            list.push(head);            head = head.next;        }        if(count &lt; k) return null;        while((k - 1) != 0 &amp;&amp; count &gt; 0) {            count--;            list.pop();            k--;        }        return list.peek();    }}</code></pre><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="描述-13"><a href="#描述-13" class="headerlink" title="描述"></a>描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">public class Solution {    public ListNode ReverseList(ListNode head) {        if(head == null) return null;        // pre和pos分别为链表翻转前head的前一个节点和后一个节点        ListNode pre = null, pos;        while(head != null) {            pos = head.next;            head.next = pre;            pre = head;            head = pos;        }        return pre;    }}</code></pre><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><h4 id="描述-14"><a href="#描述-14" class="headerlink" title="描述"></a>描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则</p><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><ul><li>递归版本<pre><code class="java">public class Solution {  public ListNode Merge(ListNode list1, ListNode list2) {      ListNode head;      if(list1 == null) {          return list2;      }      if(list2 == null) {          return list1;      }      if(list1.val &lt; list2.val) {          list1.next = Merge(list1.next, list2);          return list1;      } else {          list2.next = Merge(list1, list2.next);          return list2;      }  }}</code></pre></li><li>非递归版本<pre><code class="java">  public ListNode Merge(ListNode list1, ListNode list2) {      ListNode tem = new ListNode(-1);      ListNode head = tem;      while(list1 != null || list2 != null) {          if(list1 == null) {              tem.next = list2;              break;          }          if(list2 == null) {              tem.next = list1;              break;          }          if(list1 != null &amp;&amp; list2 != null) {              if(list1.val &lt; list2.val) {                  tem.next = list1;                  tem = tem.next;                  list1 = list1.next;              } else {                  tem.next = list2;                  tem = tem.next;                  list2 = list2.next;              }          }      }      return head.next;  }</code></pre>重点注意一下这种操作对象引用进行传递的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java泛型总结</title>
      <link href="/2018/08/01/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/01/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>贴几篇博客，介绍的很详细，也就不增加学习成本了</p><p><a href="https://segmentfault.com/a/1190000005179142" target="_blank" rel="noopener">Java 泛型总结（一）：基本用法与类型擦除</a></p><p><a href="https://segmentfault.com/a/1190000005179147" target="_blank" rel="noopener">Java 泛型总结（二）：泛型与数组</a></p><p><a href="https://segmentfault.com/a/1190000005337789" target="_blank" rel="noopener">Java 泛型总结（三）：通配符的使用</a></p><p><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>结合反射机制理解动态代理</title>
      <link href="/2018/07/31/%E7%BB%93%E5%90%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2018/07/31/%E7%BB%93%E5%90%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>先给一个动态代理的实例，按照下面这种姿势来使用动态调用，可以很好地体现出动态调用的特性。</p><p>先定义两个父接口：</p><pre><code class="java">public interface Sub1 {    public void sub1Act(String str);}public interface Sub2 {    public void sub2Act(String str);}</code></pre><p>两个父接口各自的实现类</p><pre><code class="java">public class RealSub1 implements Sub1{    @Override    public void sub1Act(String str) {        System.out.println(&quot;act2 of sub1 in realSub1：&quot; + str);    }}public class RealSub2 implements Sub2{    @Override    public void sub2Act(String str) {        System.out.println(&quot;act2 of sub2 in realSub2：&quot; + str);    }}</code></pre><p>动态代理类：</p><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class DynamicProxy implements InvocationHandler {    private Object subject;    public Object newProxyInstance(Object subject) {        this.subject = subject;        return Proxy.newProxyInstance(subject.getClass().getClassLoader(),                subject.getClass().getInterfaces(),this);    }    @Override    public Object invoke(Object proxy, Method method, Object[] args)            throws Throwable    {        return method.invoke(subject, args);    }}</code></pre><p>客户端调用：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        DynamicProxy proxy = new DynamicProxy();        // 代理Sub1        System.out.println(&quot;代理Sub1接口&quot;);        Sub1 obj1 = (Sub1) proxy.newProxyInstance(new RealSub1());        System.out.println(obj1.getClass().getName());        obj1.sub1Act(&quot;参数 for sub1&quot;);        System.out.println();        // 代理 Sub2        System.out.println(&quot;代理Sub2接口&quot;);        Sub2 obj2 = (Sub2) proxy.newProxyInstance(new RealSub2());        System.out.println(obj2.getClass().getName());        obj2.sub2Act(&quot;参数 for sub2&quot;);    }}</code></pre><h3 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h3><p>每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法：</p><pre><code class="java">public Object invoke(Object proxy, Method method, Object[] args)    throws Throwable;</code></pre><ul><li>第一个参数 proxy：代理类实例，<strong>注意这里不是被代理类</strong>，很容易用错</li><li>第二个参数 method：被调用的方法</li><li>第三参数 args： method 方法的参数</li></ul><h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><pre><code class="java">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)  throws IllegalArgumentException</code></pre><ul><li>loader：加载代理对象的类加载器</li><li>interfaces：一个Interface对象的数组，表示将要给需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法</li><li>InvocationHandler 对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler 对象上</li></ul><h3 id="动态代理过程分析"><a href="#动态代理过程分析" class="headerlink" title="动态代理过程分析"></a>动态代理过程分析</h3><p>我们先看一下上面的 Main 方法的输出结果，然后根据结果分析动态代理的过程。</p><pre><code>代理Sub1接口com.sun.proxy.$Proxy0act2 of sub1 in realSub1：参数 for sub1代理Sub2接口com.sun.proxy.$Proxy1act2 of sub2 in realSub2：参数 for sub2</code></pre><p>首先看看<code>com.sun.proxy.$Proxy0</code>和<code>com.sun.proxy.$Proxy1</code>，通过 Proxy.newProxyInstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p><p>然后我们再思考一个问题：为什么我们这里可以将 Proxy.newProxyInstance 创建的对象转化为 Sub1  类型或者 Sub2类型的对象呢？原因就是在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是被代理类类型的，所以就可以将其转化为被代理类的类型。</p><p>然后当我们使用  Proxy.newProxyInstance 创建的代理对象来调用被代理类的方法时，会告诉 InvocationHandler 具体执行哪一个函数，然后在 InvocationHandler 内部的 invoke方法，通过反射执行真实对象的该方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载之类加载器</title>
      <link href="/2018/07/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2018/07/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在前面介绍类加载过程中的加载步骤时提到“通过一个类的全限定名来获取描述此类的二进制字节流‘，这个操作就是类加载器完成的。</p><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在 Java 虚拟机中的唯一性，每一个类加载器都有唯一的标识，拥有一个独立的类名称空间。要比较两个类是否”相等“，只有在这两个类是由同一个类加载器加载的前提下才有意义。不然，即使两个类源于同一个Class文件，这两个类也不相等。</p><p>注：这里说的相等包括类的 Class 对象的 equals() 方法、isAssignableFrom()方法、isInstance() 方法返回的结果。</p><h3 id="类加载器的层次结构—双亲委派模型"><a href="#类加载器的层次结构—双亲委派模型" class="headerlink" title="类加载器的层次结构—双亲委派模型"></a>类加载器的层次结构—双亲委派模型</h3><h4 id="启动（Bootstrap）类加载器"><a href="#启动（Bootstrap）类加载器" class="headerlink" title="启动（Bootstrap）类加载器"></a>启动（Bootstrap）类加载器</h4><p>启动类加载器主要加载的是 JVM 自身需要的类，它负责将 <code>&lt;JAVA_HOME&gt;/lib</code>路径下的核心类库或 -Xbootclasspath 参数指定的路径下的 jar 包加载到内存中，注意必须是由虚拟机按照文件名识别加载 jar 包的，如rt.jar，我们非常熟悉的 Object 类就位于 rt.jar 包中。如果文件名不被虚拟机识别，名字不符合的即使把 jar 包丢到 lib 目录下也不会被加载(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。启动类加载器无法被 java 程序直接打开。</p><h4 id="扩展（Extension）类加载器"><a href="#扩展（Extension）类加载器" class="headerlink" title="扩展（Extension）类加载器"></a>扩展（Extension）类加载器</h4><p>扩展类加载器是指 Sun 公司实现的 sun.misc.Launcher$ExtClassLoader 类，由 Java 语言实现的，是 Launcher 的静态内部类，它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下或者由系统变量 -Djava.ext.dir 指定位路径中的类库。开发者可以直接使用扩展类加载器。</p><h4 id="系统（System）类加载器"><a href="#系统（System）类加载器" class="headerlink" title="系统（System）类加载器"></a>系统（System）类加载器</h4><p>也称应用程序加载器，是由 Sun 公司实现的 sun.misc.Launcher$AppClassLoader 。它负责加载系统类路径 java -classpath 或 -D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过 ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器。 </p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>Java 应用程序的加载几乎是由上述 3 种类加载器相互配合执行的，如果有必要，我们还可以自定义类加载器，需要注意的是，Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成 class 对象。加载某个具体类的 class 文件时，Java 虚拟机采用的是双亲委派模型，下面我们进一步了解它。</p><p><img src="http://dengw.xyz/blog/180731/5gE6ld6BCe.png?imageslim" alt="enter image description here"></p><p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。除了顶层的类加载器之外，其余的类加载器都有自己的父类加载器。</p><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是 Java 类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要。例如，类java.lang.Object 类存放在 JDK\jre\lib 下的 rt.jar 之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了 Object 类在程序中的各种类加载器中都是同一个类。</p><h4 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h4><p>双亲委派模型使 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要让子类加载器再加载一次。其次是考虑到安全因素，java核心 api 中定义类型不会被随意替换，假设通过网络传递一个名为 java.lang.Integer 的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的 java.lang.Integer，而直接返回已加载过的 Integer.class，这样便可以防止核心API库被随意篡改。</p><h4 id="双亲委派模型的代码实现"><a href="#双亲委派模型的代码实现" class="headerlink" title="双亲委派模型的代码实现"></a>双亲委派模型的代码实现</h4><p><img src="http://dengw.xyz/blog/180731/LLj42C2HIi.png?imageslim" alt="enter image description here"></p><p>从图可以看出顶层的类加载器是一个抽象类，其后所有的类加载器都继承自该类加载器（不包括启动类加载器），我们介绍一下几个比较重要的方法。</p><ul><li>loadClass(String)<br>该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。</li></ul><pre><code class="java">protected Class&lt;?&gt; loadClass(String name, boolean resolve)      throws ClassNotFoundException  {    synchronized (getClassLoadingLock(name)) {        // 先从缓存查找该class对象，找到就不用重新加载        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) {            long t0 = System.nanoTime();            try {                if (parent != null) {                    //如果找不到，则委托给父类加载器去加载                    c = parent.loadClass(name, false);                } else {                    //如果没有父类，则委托给启动加载器去加载                    c = findBootstrapClassOrNull(name);                }            } catch (ClassNotFoundException e) {                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            }            if (c == null) {                // If still not found, then invoke findClass in order                // 如果都没有找到，则通过自定义实现的findClass去查找并加载                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            }        }        if (resolve) {//是否需要在加载时进行解析            resolveClass(c);        }        return c;    }}</code></pre><ul><li>findClass(String)<br>在JDK1.2之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖 loadClass() 方法，而是建议<strong>把自定义的类加载逻辑写在 findClass() 方法中</strong>，从前面的分析可知，findClass() 方法是在 loadClass() 方法中被调用的，当 loadClass() 方法中父加载器加载失败后，则会调用自己的 findClass() 方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是 ClassLoader 类中并没有实现 findClass() 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 findClass 方法通常是和 defineClass 方法一起使用的，ClassLoader类中findClass()方法源码如下：</li></ul><pre><code class="java">//直接抛出异常protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {        throw new ClassNotFoundException(name);}</code></pre><ul><li><p>defineClass(byte[] b, int off, int len)<br>defineClass() 方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象<strong>(ClassLoader中已实现该方法逻辑)</strong>，通过这个方法不仅能够通过 class 文件实例化 class 对象，也可以通过其他方式实例化 class 对象，如通过网络接收一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象，defineClass() 方法通常与 findClass() 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass()方法生成类的Class对象，简单例子如下：</p><pre><code class="java">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {    // 获取类的字节数组    byte[] classData = getClassData(name);      if (classData == null) {        throw new ClassNotFoundException();    } else {        //使用defineClass生成class对象        return defineClass(name, classData, 0, classData.length);    }}</code></pre><p>需要注意的是，如果直接调用defineClass()方法生成类的Class对象，这个类的Class对象并没有解析(也可以理解为链接阶段，毕竟解析是链接的最后一步)，其解析操作需要等待初始化阶段进行。</p></li><li><p>resolveClass(Class≺?≻ c)<br>使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p></li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>一个比较好的自定义类加载器的实践就是直接继承 URLClassLoader 类，URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节码流等功能，在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p>需要注意的是如果我们在定义类加载器时选择继承 ClassLoader 类而非 URLClassLoader，必须手动编写 findclass() 方法的加载逻辑以及获取字节码流的逻辑。</p><h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p><img src="http://dengw.xyz/blog/180731/54f3593fm9.png?imageslim" alt="enter image description here"></p><p>从类图结构看出 URLClassLoader 内部存在一个 URLClassPath 类，通过这个类就可以找到要加载的字节码流，也就是说 URLClassPath 类负责找到要加载的字节码，再读取成字节流，最后通过 defineClass() 方法创建类的Class对象。从 URLClassLoader 类的结构图可以看出其构造方法都有一个必须传递的参数 URL[]，该参数的元素是代表字节码文件的路径，换句话说在创建 URLClassLoader 对象时必须要指定这个类加载器到哪个目录下找 class 文件。同时也应该注意 URL[] 也是 URLClassPath 类的必传参数，在创建 URLClassPath 对象时，会根据传递过来的 URL 数组中的路径判断是文件还是 jar 包，然后根据不同的路径创建 FileLoader 或者 JarLoader 或默认 Loader 类去加载相应路径下的 class 文件，而当 JVM 调用 findClass() 方法时，就由这3个加载器中的一个将 class 文件的字节码流加载到内存中，最后利用字节码流创建类的 class 对象。</p><p>下面是一些需要自定义类加载器场景：</p><ul><li><p>当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。</p></li><li><p>当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。</p></li><li><p>当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)，需要实现自定义ClassLoader的逻辑。</p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="noopener">大部分内容从这儿搬的： 深入理解Java类加载器(ClassLoader)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载之类加载过程</title>
      <link href="/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>现在还记得春招的时候有一个面试官问过我一个问题：你了解过Java的类加载过程吗？</p><p>现在来看觉得当初自己答得并不是很好，如果现在让我来回答这个问题，我想这样回答应该还算比较满意。</p><p>首先，我们写好一个 java 程序，从编码到最终的执行，一般包括两个过程：编译和运行。</p><p>编译阶段的主要任务就是把我们写好的 java 代码通过 javac 命令编译成字节码，输出保存到一个 <code>.class</code> 文件。<br>运行阶段就是 jvm 虚拟机把<code>.class</code>文件执行并输出最终的结果。一个类从被加载到 JVM 中开始到最后卸载，整个生命周期包括：加载、验证、准备、解析、初始化、使用以及卸载七个阶段。</p><p>而类加载过程就是指在运行阶段 JVM 虚拟机把 .class 文件中类信息加载进内存，并进行解析生成对应的 class 对象的过程，包括：加载、链接、初始化三个步骤。</p><ul><li><p>加载：类加载过程的第一个阶段，通过一个类的完全限定符查找此类字节码文件，并利用字节码文件创建一个Class对象。</p></li><li><p>链接：验证字节码的安全性和完整性，准备阶段正式为静态域分配存储空间，注意此时只是分配静态成员变量的存储空间，不包含实例成员变量，如果必要的话，解析这个类创建的对其他类的所有引用。</p></li><li><p>初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量。</p></li></ul><p><img src="http://dengw.xyz/blog/180730/9C2a0DbBB6.png?imageslim" alt="enter image description here"></p><p>下面就详细分析一下整个过程。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li></ul><p>注意，这里第 1 条中的二进制字节流并不只是单纯地从 Class 文件中获取，比如它还可以从 Jar 包中获取、从网络中获取（最典型的应用便是 Applet）、由其他文件生成（JSP 应用）等。</p><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。关于类加载器的介绍将放在本系列的第三篇博客<a href="https://www.dengw.xyz/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" target="_blank" rel="noopener">Java类加载之类加载器</a>中详细介绍。</p><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>从上面画的图可以看出，链接又可以分为：验证、准备、解析三个步骤。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p><h5 id="文件格式的验证"><a href="#文件格式的验证" class="headerlink" title="文件格式的验证"></a>文件格式的验证</h5><p>这一阶段主要验证字节流是否符合 Class 文件格式的规范，验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，可能包括以下验证点：</p><ul><li>魔数是否以 0xCAFFBABE 开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）</li><li>指向常量的各种索引值中是否有指向不存在的常量和不符合类型的常量</li><li>CONSTRANT_Utf8_info 型的常量是否有不符合 Utf8 编码的数据</li><li>Class 文件中的各个部分及其文件本身是否有被删除的或者附加的信息<br>……</li></ul><h5 id="元数据的验证"><a href="#元数据的验证" class="headerlink" title="元数据的验证"></a>元数据的验证</h5><p>这一阶段是对字节码描述的信息进行<strong>语义分析</strong>，以保证不存在不符合 Java 语言规范的元数据信息。这个阶段可能的验证点如下：</p><ul><li>这个类是否有父类（除了 Object 之外，所有类都应该有父类） </li><li>这个类的是否继承了不允许被继承的类（被 final 修饰的类）</li><li>如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，或者出现了不符合规则的重载等）<br>……</li></ul><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>这一阶段的主要目的是通过数据流和控制流分析，确定程序的语义是合法的、符合逻辑的。在上一阶段对元数据信息的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。可能的验证点包括：</p><ul><li>保证任何时候，操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放入了一个int类型数据，使用时却按 long 类型加载到本地变量表中</li><li>保证跳转指令不会跳转到方法体外的字节码指令上</li><li>保证方法体中类型转换是有效的(比如把父类对象赋值给子类型数据，甚至把两个不相关的数据类型进行赋值，是危险和不合法的)<br>……</li></ul><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>这个阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在链接的第三个阶段—解析阶段中发生，符号引用验证主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验，可能包括的验证点有：</p><ul><li>符号引用中通过字节符串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性是否可以被当前类访问<br>……</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。有两点需要注意：</p><ul><li>这阶段进行内存分配的仅包括类变量（即被 static 修饰的变量），不包括实例变量，实例变量会在对象实例化时随着对象一起分配在 Java 堆中；</li><li>这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义如下：<br>  <pre> public static int value = 123;</pre><br>那变量 value 在准备阶段过后的零值为 0 而不是 123，因为这时候并未执行任何Java方法，把 value 赋值为123的动作是在初始化阶段才会进行。对于“非通常情况”，是指定义为常量的那些变量（即final修饰的），会在这一阶段就被赋值，如：<br>  <pre> public static final int value = 123;</pre><br>此时在准备阶段过后，value的值将会被赋值为123。</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在 Class 文件结构中多次提到过符号引用，它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。在解析阶段的符号引用和直接引用的区别如下：</p><ul><li><p>符号引用（Symbolic References）：符号引用以一组符号来描述索引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用都是一样的。</p></li><li><p>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同的虚拟机上翻译出来的直接引用一般不相同。如果有了直接引用，那么引用的目标一定在内存中。</p></li></ul><p>需要注意的是解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</p><p>解析动作主要是对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行解析，分别对应CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info7种常量类型。这里仅仅介绍前四种，因为后三种和动态类型语言支持有关。</p><ol><li>类或接口的解析<br>假设当前代码处于类 D 中，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，虚拟机将经历如下的过程：</li></ol><ul><li>如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器区加载这个类。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载，比如这个类的父类或实现的接口。如果加载过程出现异常，解析过程就失败。</li><li>如果 C 是一个数组类型，并且数组的元素类型是对象，就会按照第一点加载数组元素类型。接着由虚拟机生成一个代表着数组维度和元素的数组对象。</li><li>如果上面的步骤没有异常，那么C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认 D 是否具备对 C 的访问权限。</li></ul><ol start="2"><li>字段解析<br>要解析一个未被解析过的字段符号引用，首先将会对字段表内 class_index项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或借口的符号引用。如果解析这个类或接口时发生异常，都会导致解析字段的失败。如果解析成功，才会继续解析这个字段。具体的规则如下：</li></ol><ul><li>如果类或接口 C 本身就包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束；</li><li>否则，如果在 C 中实现了接口，将会按照继承关系从下到上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束；</li><li>否则，如果 C 不是 Object 的话，将会按照继承关系从下到上递归搜索父类，如果父类中包含了简单名称和字段描述符都与目标匹配的字段，返回这个字段的直接引用，查找结束；</li><li><p>否则，查找失败。</p><p>之后，还会对返回的字段进行权限验证，如果不具备对字段的访问权限，将抛出 java.lang.IllegalAccessError 异常。</p></li></ul><ol start="3"><li>类方法解析<br>类方法解析的第一个步骤和字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，按照如下步骤继续（同样以 C 来表示这个类）：</li></ol><ul><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_index 中索引的 C 是一个接口，直接失败；</li><li>如果通过第一步，接着会在类 C 中查找这个方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在类 C 的父类中递归查找这个方法，如果有则直接返回这个方法的直接引用，查找结束</li><li>否则，在类 C 实现的接口列表中递归查找这个方法。如果找到一个匹配的方法，说明类 C 是一个抽象类，查找结束，抛出 java.lang.AbstractMethodError 异常；</li><li><p>否则，查找失败，抛出 java.lang.NoSuchMethodError 异常。</p><p>同样，成功返回后还要进行权限验证。</p></li></ul><ol start="4"><li>接口方法解析<br>接口方法也要解析接口方法表的 class_index 所属的类或接口引用，如果解析成功，用 C 表示这个类或接口，虚拟机按照如下的规则搜索：</li></ol><ul><li>与类方法解析不同，如果在接口方法表中发现 class_index 是一个类而不是接口，直接抛出java.lang.IncompatibleClassChangeError 异常；</li><li>否则，在接口 C 中查找这个方法；</li><li>否则，在接口 C 的父接口中递归查找；</li><li>否则，查找失败，抛出 java.lang.NoSuchMethodError 异常。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序（或者说字节码）。</p><p>前面已经知道，在准备阶段变量已经赋值过一次系统初始值了，而在初始化阶段，则会根据程序员通过程序制定的主观计划去初始化类变量和其它内容。或者可以从另一个角度来表达：初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code>方法的过程。下面是<code>&lt;clinit&gt;()</code>方法的特点：</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中 (static {}) 的语句合并产生的，编译器收集的顺序由语句块在源文件中的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量不能访问，但能赋值(参考下面的代码清单#1)。</li><li><code>&lt;clinit&gt;()</code>方法与类构造器<code>&lt;init&gt;()</code>不同，它不需要显式调用父类的<code>&lt;clinit&gt;()</code>方法，虚拟机保证在子类<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这一点可以确保虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是 java.lang.Object.</li><li>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li><li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变脸的赋值操作，那么编译器就不会生成<clinit>()方法。</clinit></li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。即，只有使用一个接口中的变量时，才会执行这个接口的<code>&lt;clinit&gt;()</code>方法。</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程会去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li></ul><pre><code class="java"># 代码清单#1public class Test {    static {        i = 0;                  // 给变量的赋值可以正常编译过        System.out.println(i);  // 访问编辑器会报“非法向前引用”的错误    }    static int i = 1;           // 静态语句块之后的变量}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java类加载之Class文件结构</title>
      <link href="/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8BClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8BClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>抱着《深入理解Java虚拟机》这本书啃了两天时间，再结合网上相关的博客，虽然好几次看着看着就差点就睡着了，不过坚持下来终于对这部分的内容终于有一个大致的了解了，今天下午借着这个空闲时间，就把这部分内容总结一下，希望有所收获。</p><h3 id="关于Class文件"><a href="#关于Class文件" class="headerlink" title="关于Class文件"></a>关于Class文件</h3><p>我们现在知道在Java中每个类都会对应一个Class对象，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象并且这个Class对象会被保存在同名.class文件里(编译后的字节码文件保存的就是Class对象)。当我们new 一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。</p><p>所以在使用一个类时，类加载器首先会检查这个类的 Class 对象是否已被加载，如果还没有加载，默认的类加载器就会先根据类名查找.class文件，加载完成后 Class 对象也就被载入内存，也就可以被用来创建这个类的所有实例对象。</p><h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><p>根据《深入理解Java虚拟机》一书上的说法，Class 文件是由一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序<strong>紧凑地</strong>排列在Class文件之中，中间没有任何分隔符，这样整个Class文件全都是程序运行时的必要数据。</p><p>对于那些空间大于8位的数据则会分为若干个8位字节按照”高位在前(Big-Endian)”进行存储，比如的16位、32位和64位长度的数据将被构造成 2个、4个和8个8字节单位来表示。</p><p><strong>NOTE</strong>: 注意：Big-Endian 顺序是指按高位字节在地址最低位，最低字节在地址最高位来存储数据，它是 SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反的Little-Endian顺序来存储数据。</p><p>Class文件格式采用类似C语言结构体的伪结构来描述Class文件格式。在这种结构体只有两种数据类型：无符号数和表。</p><p>其中无符号数属于基本的数据类型，以u1、u2、u4、u8来分别表示1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。表是由多个无符号或者其他表作为数据项构成的复合数据类型，习惯性地以”_info”结尾，这样来看，整个Class文件本质上也就是一张表。</p><pre><code class="cpp">ClassFile {     u4 magic;     u2 minor_version;     u2 major_version;     u2 constant_pool_count;     cp_info constant_pool[constant_pool_count-1];     u2 access_flags;     u2 this_class;     u2 super_class;     u2 interfaces_count;     u2 interfaces[interfaces_count];     u2 fields_count;     field_info fields[fields_count];     u2 methods_count;     method_info methods[methods_count];     u2 attributes_count;     attribute_info attributes[attributes_count]; }</code></pre><p>我们使用表格的形式表示一下：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">U4</td><td style="text-align:left">magic</td><td style="text-align:left">魔数</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">minor_version</td><td style="text-align:left">副版本号</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">major_version</td><td style="text-align:left">主版本号</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">constant_pool_count</td><td style="text-align:left">常量池计数器</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">cp_info</td><td style="text-align:left">constant_pool</td><td style="text-align:left">常量池</td><td style="text-align:left">constant_pool_count - 1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">access_flags</td><td style="text-align:left">访问标志</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">this_class</td><td style="text-align:left">类索引</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">super_class</td><td style="text-align:left">父类索引</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">interfaces_count</td><td style="text-align:left">接口索引计数器</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">interfaces</td><td style="text-align:left">接口索引</td><td style="text-align:left">interfaces_count</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">fields_count</td><td style="text-align:left">字段表计数器</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">field_info</td><td style="text-align:left">fields</td><td style="text-align:left">字段表</td><td style="text-align:left">fields_count</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">methods_count</td><td style="text-align:left">方法表计数器</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">method_info</td><td style="text-align:left">methods</td><td style="text-align:left">方法表</td><td style="text-align:left">methods_count</td></tr><tr><td style="text-align:left">U2</td><td style="text-align:left">attributes_count</td><td style="text-align:left">属性表计数器</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes</td><td style="text-align:left">属性表</td><td style="text-align:left">attributes_count</td></tr></tbody></table><p>而我们接下要做的就是结合一个实际的Class文件字节码来逐个理解这些字段。</p><h5 id="测试类代码："><a href="#测试类代码：" class="headerlink" title="测试类代码："></a>测试类代码：</h5><pre><code class="java">public class Test {    private String name;    private int m;    public void setName(String name) {        this.name = name;    }    public int calcM() {        return m + 1;    }}</code></pre><h5 id="Test-class对应的二进制流（使用WinHex软件打开）"><a href="#Test-class对应的二进制流（使用WinHex软件打开）" class="headerlink" title="Test.class对应的二进制流（使用WinHex软件打开）"></a>Test.class对应的二进制流（使用WinHex软件打开）</h5><p><img src="http://dengw.xyz/blog/180728/K9c9Lef045.png?imageslim" alt="enter image description here"></p><h4 id="使用javap反汇编命令生成的字节码："><a href="#使用javap反汇编命令生成的字节码：" class="headerlink" title="使用javap反汇编命令生成的字节码："></a>使用<code>javap</code>反汇编命令生成的字节码：</h4><pre><code>PS C:\Users\Administrator\Desktop&gt; Javap -verbose TestClassfile /C:/Users/Administrator/Desktop/Test.class  Last modified 2018-7-28; size 395 bytes  MD5 checksum edee74c07502d68f5e7aea198366f496  Compiled from &quot;Test.java&quot;public class Test  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #5.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #4.#21         // Test.name:Ljava/lang/String;   #3 = Fieldref           #4.#22         // Test.m:I   #4 = Class              #23            // Test   #5 = Class              #24            // java/lang/Object   #6 = Utf8               name   #7 = Utf8               Ljava/lang/String;   #8 = Utf8               m   #9 = Utf8               I  #10 = Utf8               &lt;init&gt;  #11 = Utf8               ()V  #12 = Utf8               Code  #13 = Utf8               LineNumberTable  #14 = Utf8               setName  #15 = Utf8               (Ljava/lang/String;)V  #16 = Utf8               calcM  #17 = Utf8               ()I  #18 = Utf8               SourceFile  #19 = Utf8               Test.java  #20 = NameAndType        #10:#11        // &quot;&lt;init&gt;&quot;:()V  #21 = NameAndType        #6:#7          // name:Ljava/lang/String;  #22 = NameAndType        #8:#9          // m:I  #23 = Utf8               Test  #24 = Utf8               java/lang/Object{  public Test();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 1: 0  public void setName(java.lang.String);    descriptor: (Ljava/lang/String;)V    flags: ACC_PUBLIC    Code:      stack=2, locals=2, args_size=2         0: aload_0         1: aload_1         2: putfield      #2                  // Field name:Ljava/lang/String;         5: return      LineNumberTable:        line 7: 0        line 8: 5  public int calcM();    descriptor: ()I    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: getfield      #3                  // Field m:I         4: iconst_1         5: iadd         6: ireturn      LineNumberTable:        line 11: 0}SourceFile: &quot;Test.java&quot;</code></pre><p>准备工作做完了下面就开始解析了：</p><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>class文件的头4个字节称为魔数，它的唯一作用就是确定这个文件时候是一个能被虚拟机接受的class文件。使用魔数而不是用文件扩展名来区别Class文件的原因在于魔数不可更改，而文件扩展名可以随意更改。在java中魔数为一个常量: 0xCAFEBABE</p><p><img src="http://dengw.xyz/blog/180728/K2dl8FG5D7.png?imageslim" alt="enter image description here"></p><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>接下来就是class文件的版本号，第5、6个字节是次版本号，第7、8个字节是主版本号。</p><p>如上图所示，副版本号是：0x0000，主版本号是 0x0034，也就是十进制的52，java 的版本号是从45开始，高版本的 JDK 能向下兼容以前版本的 Class 文件，虚拟机拒绝执行超过其版本号的 Class 文件。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>常量池的数量不是固定的，所以常量池的入口需要放置一个u2类型的数据来代表常量池的容量计数器。由于这个容器的计数是从1开始的而不是从0开始的，常量池的常量个数与常量池计数器的关系是 <code>count = counter - 1</code>。根据 WinHex 软件打开看到的字节流显示容量计数器的十六进制数为 0x0019，即十进制的25，这就代表常量池中有24项常量，索引范围是1~24。这个也可以从我们上面的 <code>javap</code> 反汇编命令生成的字节码中看到。</p><p>常量池可以理解为结构中文件之中的资源仓库，主要存放两大类常量：字面量和符号引用。</p><blockquote><p>字面量：接近java语言层面的常量概念，如文本字符串、final常量值等。</p></blockquote><blockquote><p>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</p></blockquote><p>常量池中的每一项都是一个表，现在的 JDK 版本中一共有14种表。这14个表都有一个特点，第一项均为 u1 类型的 tag，代表常量池项目的类型，这14种常量类型所代表的具体含义如下：<br><img src="http://dengw.xyz/blog/180728/A3Lkidc9Hm.png?imageslim" alt="enter image description here"><br><img src="http://dengw.xyz/blog/180728/391KEbGbkg.png?imageslim" alt="enter image description here"></p><p>下面来根据我们的字节码来分析常量池（蓝色背景部分）。<br><img src="http://dengw.xyz/blog/180728/EI0BH4JFim.png?imageslim" alt="enter image description here"></p><p>然后把每个常量的字节流截取出来，显示如下(实际上字节之间是不存在空格的，这里方便查看)：</p><pre><code>#1: 0A 00 05 00 14#2: O9 00 04 00 15#3: 09 00 04 00 16#4: 07 00 17#5: 07 00 18#6: 01 00 04 6E 61 6D 65#7: 01 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B#8: 01 00 01 6D#9: 01 00 01 49#10: 01 00 06 3C 69 6E 69 74 3E#11: 01 00 03 28 29 56#12: 01 00 04 43 6F 64 65#13: 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65#14: 01 00 07 73 65 74 4E 61 6D 65#15: 01 00 15 28 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56#16: 01 00 05 63 61 6C 63 4D#17: 01 00 03 28 29 49 #18: 01 00 0A 53 6F 75 72 63 65 46 69 6C 65#19: 01 00 09 54 65 73 74 2E 6A 61 76 61#20: 0C 00 0A 00 0B#21: 0C 00 06 00 07#22: 0C 00 08 00 09#23: 01 00 04 54 65 73 74#24: 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</code></pre><p>可以看到第一项常量的 tag 为 0x0A，即十进制的10，查表得知这个常量属于 CONSTANT_Methordref_info 类型，表示对一个类中方法的符号引用，该项常量占用的字节流为 0x0A(tag)、 0x0005(index)、0x0014(index)，即分别指向第5个常量和第20个常量，对应的字节流分别为 0x07 00 18 和 0x0C 00 0A 00 0B，然后通过 tag 又知道了这两个常量的类型分别为CONSTANT_Class_info 和 CONSTANT_NameAndType_info 类型，这样第一个常量就解析完成了。而我们再看一下反编译结果中的常量表发现确实也是这样。</p><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>在常量池结束之后，紧接着的两个字节代表访问标志，用于识别类或接口层次的访问信息，包括这个 Class 是类还是接口，是否定义为 public 类型、abstract 类型等等。具体的标志位以及标志的含义见下表：</p><table><thead><tr><th style="text-align:left">标志名称</th><th style="text-align:left">标志值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ACC_PUBLIC</td><td style="text-align:left">0x0001</td><td style="text-align:left">是否为public类型</td></tr><tr><td style="text-align:left">ACC_FINAL</td><td style="text-align:left">0x0010</td><td style="text-align:left">是否被声明为final，只有类可设置</td></tr><tr><td style="text-align:left">ACC_SUPER</td><td style="text-align:left">0x0020</td><td style="text-align:left">是否允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类这个标志必须为真</td></tr><tr><td style="text-align:left">ACC_INTERFACE</td><td style="text-align:left">0x0200</td><td style="text-align:left">标识这是一个接口</td></tr><tr><td style="text-align:left">ACC_ABSTRACT</td><td style="text-align:left">0x0400</td><td style="text-align:left">是否为abstract类型，对于接口或抽象类来说此值为真，其他类值为假</td></tr><tr><td style="text-align:left">ACC_SYNTHETIC</td><td style="text-align:left">0x1000</td><td style="text-align:left">标识这个类并非由用户代码产生的</td></tr><tr><td style="text-align:left">ACC_ANNOTATION</td><td style="text-align:left">0x2000</td><td style="text-align:left">标识这个一个注解</td></tr><tr><td style="text-align:left">ACC_ENUM</td><td style="text-align:left">0x4000</td><td style="text-align:left">标识这是一个枚举</td></tr></tbody></table><p>我们定义的 Test 类被 public 关键字修饰，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，因此其 access_flags 值应为<code>0x0001|0x0020=0x0021</code>,字节流显示的也确实是<code>0x0021</code><br><img src="http://dengw.xyz/blog/180728/a4689fG3Gf.png?imageslim" alt="enter image description here"></p><h4 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h4><p>在访问标志 access_flags 后接下来就是类索引（this_class）和父类索引（super_class），这两个数据都是u2类型的，他们各自指向一个类型为  CONSTANT_Class_info 的类描述符常量，而接下来的接口索引集合是一个 u2 类型的集合，class 文件由这三个数据项来确定类的继承关系。由于 Java 中是单继承，所以父类索引只有一个；但Java类可以实现多个接口，所以接口索引是一个集合。</p><p>类索引用来确定这个类的全限定名，父类索引确定这个类的父类的全限定名，除了 Object 之外，所有的类都有父类，接口索引集合存储了implements 语句后面按照从左到右的顺序的接口。</p><p><img src="http://dengw.xyz/blog/180728/KBda0EIfjj.png?imageslim" alt="enter image description here"></p><p>从上图可以看出3个 u2 类型的值分别为 0x0004、0x0005、0x0000。也就是类索引指向常量表的第4个常量，父类索引指向常量表的第5个常量，接口索引为0，也就是没有实现接口。</p><pre><code>   #4 = Class              #23            // Test   #5 = Class              #24            // java/lang/Object</code></pre><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>字段表用来描述接口或类中声明的变量。字段包括类级变量和实例级变量，但不包括方法内变量，也就是局部变量。所谓的类级变量就是静态变量，这个变量不属于这个类的任何实例，可以不用定义类实例就可以使用；实例级变量不是静态变量，是和类实例相关联的，需要定义类实例才能使用。</p><p>我们可以先想一下一个字段包含有哪些信息呢？</p><p>可以包含的信息有：字段的作用域（public、private和protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final修饰符）、并发可见性（volatile修饰符）、是否可被序列化（transient修饰符）、字段的数据类型（基本类型、对象、数组）以及字段名称。对于上述这些信息，每一个修饰符都是布尔值，有或者没有，字段名引用常量池的常量来进行描述。下表是字段表的最终格式：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">access_flags</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">name_index</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">descriptor_index</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">attributes_count</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes</td><td style="text-align:left">attributes_count</td></tr></tbody></table><p>其中的字段修饰符 access_flags，和类中的 access_flags 类似，对于字段来说可以设置的标志位及含义如下：</p><table><thead><tr><th style="text-align:left">标志名称</th><th style="text-align:left">标志值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ACC_PUBLIC</td><td style="text-align:left">0x0001</td><td style="text-align:left">字段是否是public</td></tr><tr><td style="text-align:left">ACC_PRIVATE</td><td style="text-align:left">0x0002</td><td style="text-align:left">字段是否是private</td></tr><tr><td style="text-align:left">ACC_PROTECTED</td><td style="text-align:left">0x0004</td><td style="text-align:left">字段是否是protected</td></tr><tr><td style="text-align:left">ACC_STATIC</td><td style="text-align:left">0x0008</td><td style="text-align:left">字段是否是static</td></tr><tr><td style="text-align:left">ACC_FINAL</td><td style="text-align:left">0x0010</td><td style="text-align:left">字段是否是final</td></tr><tr><td style="text-align:left">ACC_VOLATILE</td><td style="text-align:left">0x0040</td><td style="text-align:left">字段是否是volatile</td></tr><tr><td style="text-align:left">ACC_TRANSIENT</td><td style="text-align:left">0x0080</td><td style="text-align:left">字段是否是transient</td></tr><tr><td style="text-align:left">ACC_SYNTHETIC</td><td style="text-align:left">0x1000</td><td style="text-align:left">字段是否是由编译器自动产生的</td></tr><tr><td style="text-align:left">ACC_ENUM</td><td style="text-align:left">0x4000</td><td style="text-align:left">字段是否是enum</td></tr></tbody></table><p>显然，ACC_PUBLIC、ACC_PRIVATE 和 ACC_PROTECTED 只能选择一个，ACC_FINAL 和 ACC_VOLATILE 不能同时选择。接口中的字段必须有 ACC_PUBLIC、ACC_STATIC 和 ACC_FINAL 标志，这是Java语言本身的规则决定的。</p><p>access_flags 后面的是 name_index 和descriptor_index，前者是字段简单名称名的常量池索引，后者是字段描述符的常量池索引。</p><blockquote><p>全限定名：就是把带路径类名中的”.”替换成“/”后的字符串，比如<code>java/lang/Object</code>或者<code>Test</code>就是两个全限定名。</p><p>简单名称：是指没有类型和参数修饰的方法或者字段名称。</p><p>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值。</p></blockquote><p>对于方法的描述符，参数类型都使用一个大写字母来表示，具体表示如下表：<br><img src="http://dengw.xyz/blog/180728/fh36JhJ0ga.png?imageslim" alt="enter image description here"></p><p>对于数组类型，每一个维度将使用一个前置的“[”字符来描述。比如定义一个<code>java.lang.String[][]</code>类型的二维数组，将记录为<code>[[Ljava/lang/String</code>，一个 double 数组<code>double[]</code>将标记为<code>[D</code>。</p><p>当描述符用来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>()</code>内。比如方法<code>void setName(String name)</code>的描述符是<code>(S)V</code>。方法<code>java.lang.String toString()</code>的描述符是<code>()Ljava/lang/String</code>；方法<code>int indexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)</code>的描述符是<code>([CII[CIII)I</code>。</p><p>descriptor_info后面是属性信息，对于字段，可以使用属性表描述一下额外信息，比如如果将字段<code>m</code>的声明改为<code>final static int m = 123;</code>，那就会存在一个项名称为<code>ConstantValue</code>的属性，值指向常量123。关于属性表后面还会详细介绍。</p><p>我们回到字节流中再详细地分析一下：<br><img src="http://dengw.xyz/blog/180728/dJ6hijm4am.png?imageslim" alt="enter image description here"></p><pre><code>00 02  // fileds_count:代表有两个字段// 第一个字段，下同00 02  // access_flag: 具备的所有访问权限按位或运算的结果00 06  // name_index: 指向常量池的第6个常量00 07  // description_index: 指向常量池的第7个常量00 00  // attribute_count: 属性数量// 第二个字段00 02 00 08 00 0900 00</code></pre><p>这里需要注意的是字段表集合中不会列出从父类或接口中继承来的字段，但有可能会出现原本Java程序中没有的字段。比较典型的例子是内部类，为了在内部类中保持对外部类的访问性，会增加一个指向外部类实例的字段<code>this</code>。另外，在Java语言中字段无法重载，也就是字段名不能重复，即使两个字段的数据类型、修饰符都不相同。不过对于字节码来说，如果两个字段的描述符不一致，那么就可以有重复的字段名。</p><h4 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h4><p>class文件存储格式中对方法的描述和对字段的描述几乎相同，方法表的结构也和字段表相同。</p><p>不过因为 volatile 和 transient 关键字不能修饰方法，而synchronized、native、strictfp 和 abstract 关键字可以修饰方法，所以方法表的标志位及其取值如下：<br><img src="http://dengw.xyz/blog/180728/B96a8GAgig.png?imageslim" alt="enter image description here"></p><p>另外一点方法肯定就包括代码了，如果方法表和字段表的结构相同，那代码去哪儿了呢？答案是经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为<code>Code</code>的属性里面，关于属性表后面再详细介绍。</p><p>我们再结合字节流详细了解一下：</p><p><img src="http://dengw.xyz/blog/180728/c3c6G06F40.png?imageslim" alt="enter image description here"></p><pre><code>00 03 //表示有三个方法，这里只介绍第一个方法00 01 // 访问标志： 具备的所有访问权限按位或运算的结果00 0A // 名称索引：指向第10个常量00 0B // 描述符索引：指向第11个常量00 01 // 有一项属性00 0C //属性名称索引，指向第12个常量，值为&quot;Code&quot;,即方法的字节码描述</code></pre><p>在Java中，要重载一个方法，除了要与原方法具有相同的方法名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是特征签名只包含参数个数和类型，并不包含返回值类型，所以Java语言中是无法仅仅依靠返回值的不同来对一个方法重载的。但是在class文件格式中，特征签名还包括返回值类型，也就是说只有返回值类型不同的两个方法也可以存在。这一点在泛型中编译后类型擦除后生成的桥接方法上有所体现。不过这里就不过多介绍了。</p><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>属性表在前面出现了多次，在class文件、字段表和方法表都可以携带自己的属性表集合，来描述某些场景专有的信息。</p><p>与class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制比较少，不要求严格的顺序，只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机会在运行时忽略掉那些不认识的信息。为了能正确解析class文件，《Java虚拟机规范（第二版）》中预定义了9项虚拟机应当识别的属性。现在，属性已经达到了21项。具体信息如下表：<br><img src="http://dengw.xyz/blog/180730/6G557DKfGj.png?imageslim" alt="enter image description here"><br><img src="http://dengw.xyz/blog/180730/I2GllEllmf.png?imageslim" alt="enter image description here"><br><img src="http://dengw.xyz/blog/180730/2fF1EFG133.png?imageslim" alt="enter image description here"></p><p>从上表可以看出，属性表集合存在的位置也是不确定的，不仅可以存储在class文件结尾处，还可以作为数据项存在于类、方法表集合和字段表集合中。对于存在于class类文件中的属性表集合很好理解，毕竟在开头的class文件结构图中的最后一部分就是属性表集合，这时属性表集合作为构成class文件结构的一个大部分。剩下的存在于类中、方法表集合与字段表集合中的属性表集合，其实是作为它们的一个数据项存在的。</p><p>存在于类中的属性表集合，存储了关于这个类的一些信息。比如这个类是否是过时的（Deprecated）、在泛型中保存类的类型参数（由于生成class文件后会进行类型擦除，Java中的泛型是一种伪泛型）和动态注解等信息；存放在方法表集合中的属性表集合存储了关于方法的信息，最主要的就是Code属性，存储了字节码指令；存放于字段表集合中的属性表集合存储了关于字段的信息，我们这里的例子没有涉及到字段的属性，不过当在类中定义了静态常量（static final）并且这个常量有初始值时会将这个值作为属性存储在字段表中的属性表集合中。</p><p>对于每个属性，class文件规定的属性格式只有前6个字节：2字节的属性名称的索引和4个字节的属性长度，名称是指向 CONSTANT_Utf8_info 类型常量的索引，一个 u4 的长度属性 attribute_length 说明属性值作用的占用位数，接下来就要按照这个长度存储属性值。一个符合规则的属性表的结构如下：<br><img src="http://dengw.xyz/blog/180730/Fd3hDFcA7J.png?imageslim" alt="enter image description here"></p><p>下面我们着重学习一下 Code 属性。</p><h5 id="属性表集合之Code属性"><a href="#属性表集合之Code属性" class="headerlink" title="属性表集合之Code属性"></a>属性表集合之Code属性</h5><p>Java 程序方法体中的代码经过 Javac 编译处理后，最终变为字节码指令存储在 Code 属性中，Code 属性出现在方法表的属性集合之中。但是需要注意的是也并非所有方法表都有 Code 属性，例如抽象类或接口，Code 属性的结构如下：<br><img src="http://dengw.xyz/blog/180730/BhIcG6G9kk.png?imageslim" alt="enter image description here"></p><p>其中 attribute_name_index 和 attribute_length 前面已经介绍过了。</p><p>max_stack代表了操作数栈的最大深度。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机执行时需要根据这个值来分配栈帧中的操作栈深度。</p><p>max_locals代表了局部变量表所需要的存储空间。在这里，max_locals的单位是slot，HotSpot虚拟机在分配对象时使用的单位就是slot。方法参数（包括隐式参数this）、显式异常处理器的参数（try-catch块中catch块中定义的异常）以及方法体中定义的局部变量都需要局部变量表来存放。需要注意的是，由于局部变量表中的slot可以重用，所以并不是所有的局部变量的总slot就是max_locals。编译器会根据变量的作用域来分配 slot 给各个变量使用，然后计算 max_locals 的大小。</p><p>code_length 和code用来存储字节码指令。Java的字节码指令的长度都是一个字节，即最多可以有256个指令，实际上一共有大约200条指令。对于字节码指令这里不过多介绍。</p><p>code_length和 code是用来存储 Java源程序编译后产生的字节码指令，code_length代表字节码长度。既然叫字节码，每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。一个字节取值范围为0~255，所以字节码指令肯定不会超过256个指令，目前Java虚拟机规范定义了其中约200条编码值对应指令的含义。</p><p>因为 code_length 是一个 u4 类型，所以理论上每个方法的字节长度不能超过2^23-1，但是虚拟机规范中明确限定了一个方法不能超过65535条字节码指令，即实际只用到了u2的长度，如果超过这个限制，Javac 编译器会拒绝编译。</p><p>最后我们再结合 Test.Class 文件的二进制流来具体分析一下。</p><p>上面我们分析方法表的时候，看到有一个指向常量池中值为 Code 的索引值，这就是该方法 Code 表的 attribute_name_index 属性，下面我们接着那儿分析吧：<br><img src="http://dengw.xyz/blog/180730/Df4Ck86AAC.png?imageslim" alt="enter image description here"></p><pre><code>00 0C // attribute_name_index00 00 00 1D // attribute_length00 01 // max_stack00 01 // max_locals00 00 00 05 // code_length2A B7 00 01 B1 // code(对应指令)00000001000D00000006000100000001  // 剩下的部分</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射机制的初步了解</title>
      <link href="/2018/07/25/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/"/>
      <url>/2018/07/25/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>RTTI（Run-Time Type Identification）运行时类型识别，其作用是在运行时识别一个对象的类型和类的信息。这里分两种：传统的”RRTI”，它假定我们在编译期已知道了所有类型(如new对象时该类必须已定义好)，另外一种是反射机制，它允许我们在运行时发现和使用类型的信息。</p><p>JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种<strong>动态获取</strong>的信息以及<strong>动态调用</strong>对象的方法的功能称为java语言的反射机制，即采用动态编译的方式。</p><p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。</p><p><strong>反射的本质</strong>：就是在得到类的<code>class</code>文件后，反响获取类对象的各种信息。</p><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><p>在使用Java反射机制时，主要步骤包括： </p><ol><li>获取 目标类型的Class对象 </li><li>通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象 </li><li>通过 Constructor类对象、Method类对象、Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作</li></ol><p>获取到 Class 对象，有以下三种方式：</p><ul><li>Object 类中的 getClass 方法</li><li>任何数据类型（包括基本数据类型）都有一个“静态”的class属性</li><li>通过Class类的静态方法：forName（String  className）(常用)</li></ul><pre><code class="java">public class Fanshe {    public static void main(String[] args) {        // way1        Student stu1 = new Student();        Class class1 = stu1.getClass();        System.out.println(&quot;way1: &quot; + class1.getName());        // way2        Class class2 = Student.class;        System.out.println(&quot;way2: &quot; + class2.getName());        // way3        try{            Class class3 = Class.forName(&quot;Student&quot;);            System.out.println(&quot;way3: &quot; + class3.getName());        } catch (ClassNotFoundException e) {            System.out.println(&quot;way3: &quot; + &quot;Class not found&quot;);        }    }}</code></pre><p>三种方式常用第三种，第一种方法对象都有了还要反射干什么，反射的目的就是回去类的对象。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p><h4 id="获取构造方法并调用"><a href="#获取构造方法并调用" class="headerlink" title="获取构造方法并调用"></a>获取构造方法并调用</h4><pre><code class="java">// 所有&quot;公有的&quot;构造方法public Constructor[] getConstructors()// 获取所有的构造方法(包括私有、受保护、默认、公有)public Constructor[] getDeclaredConstructors()// 获取单个的&quot;公有的&quot;构造方法，参数是构造方法中参数类型public Constructor getConstructor(Class... parameterTypes)// 获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有，参数是构造方法中参数类型public Constructor getDeclaredConstructor(Class... parameterTypes)</code></pre><p>示例：Student类中有一个参数为<code>int</code>类型的私有构造函数，而其他类型的构造函数与私有构造函数相比处理要更简单，因此拿私有构造函数来进行处理：</p><pre><code>private Student(int grade) {    this.grade = grade;    System.out.println(&quot;调用了私有构造方法&quot;);}</code></pre><p>然后使用反射使用该构造函数实例化一个Student的示例并输出 grade 参数的值：</p><pre><code class="java">try {    Class class3 = Class.forName(&quot;Student&quot;);    Constructor con = class3.getDeclaredConstructor(int.class);    con.setAccessible(true);    Student obj = (Student) con.newInstance(2);    System.out.println(obj.getGrade());} catch(Exception e) {    e.printStackTrace();}</code></pre><p>上面使用到 Constructor 类的一些方法：</p><pre><code class="java">// 重新设置该构造函数的访问权限setAccessible(boolean);// 使用构造器构造一个示例，参数与你调用的构造函数的参数相同newInstance()</code></pre><h4 id="获取成员变量并调用"><a href="#获取成员变量并调用" class="headerlink" title="获取成员变量并调用"></a>获取成员变量并调用</h4><pre><code class="java">// 获取所有的公有字段public Field[] getFields()// 获取所有字段，包括：私有、受保护、默认、公有public Field[] getDeclaredFields()// 获取某个&quot;公有的&quot;字段public Field getField(String fieldName)// 获取所有类型中的某个字段(私有、受保护、默认、公有)public Field getDeclaredField(String fieldName)</code></pre><p>示例：Student 类中有一个私有参数：name，其他类型的参数与私有参数相比处理更简单一点，因此拿私有参数来举例：</p><pre><code class="java">    private String name;</code></pre><p>然后使用反射机制，不调用Student 类提供的 setName() 函数，直接改变 name 字段的值：</p><pre><code class="java">try {    Object obj = class3.getConstructor().newInstance();    Student student = (Student) obj;    Field name = class3.getDeclaredField(&quot;name&quot;);    name.setAccessible(true);    name.set(student, &quot;刘德华&quot;);    System.out.println(name.get(student));} catch (Exception e) {    e.printStackTrace();}</code></pre><p>上面使用到Field 类的一些方法：</p><pre><code class="java">// 重新设置该字段的访问权限setAccessible(boolean);// 重新设置实例 Object 中该字段的值set(Object, newValue)// 获取实例 Object 中该字段的值get(Object)</code></pre><p><strong>NOTE:  </strong> 在上面的代码中<code>System.out.println(student.getName());</code>我最开始使用的是<code>System.out.println(studnet.name);</code>，我的想法是因为我已经重新设置了 name 属性的访问权限，所有可以直接访问该属性。但是发现这样会报错。之前一直觉得发射破坏了java 类的访问规则，但是现在来看，及时使用反射还是要遵守 java 的语法规则的，你不用像我这样直接使用属性名来访问字段的值，因为这样是违背java语法规则的，只能够使用反射的方法来进行访问。同理，类的私有方法也有这个规则。</p><h4 id="获取成员方法并调用"><a href="#获取成员方法并调用" class="headerlink" title="获取成员方法并调用"></a>获取成员方法并调用</h4><pre><code class="java">// 获取所有公有方法（包含了父类的方法也包含Object类）public Method[] getMethods()// 获取所有的成员方法，包括私有的(不包括继承的)public Method[] getDeclaredMethods()// 获取单个公有方法 (参考上面)public Method getMethod(String name, Class&lt;?&gt;... parameterTypes):* 参数说明：* name : 方法名；* parameterTypes : 方法形参的Class类型对象// 获取单个成员方法（参考上面）public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></pre><p>示例：Student类中有一个私有方法 <code>funB</code>，如下：</p><pre><code class="java">private String funB(String a, int b) {    return b + &quot;年级的&quot; + a + &quot; 执行了私有方法：B&quot;;}</code></pre><p>然后使用反射机制获取到该方法并执行，然后输出返回结果</p><pre><code class="java">try {    Object obj = class3.getConstructor().newInstance();    Method m = class3.getDeclaredMethod(&quot;funB&quot;, String.class, int.class);    System.out.println(m);    m.setAccessible(true);    Object re = m.invoke(obj, &quot;刘德华&quot;, 2);    String out = (String) re;    System.out.println(out);} catch(Exception e) {    e.printStackTrace();}</code></pre><p>输出结果：</p><pre><code class="java">private java.lang.String Student.funB(java.lang.String,int)2年级的刘德华 执行了私有方法：B</code></pre><p>上面使用到 Method 类的一些方法：</p><pre><code class="java">// 调用方法，返回值是要执行方法的返回结果public Object invoke(Object obj, Object... args)* 参数说明：* obj: 要调用方法的对象实例；* args: 要执行方法的具体参数// 重新设置该方法的访问权限setAccessible(boolean flag)</code></pre><p><br><br><br><br><strong>同样的，我们也可以通过反射来获取一个类的 main 方法；</strong><br><br><br><br></p><p>假如 Student 方法中有一个如下格式的 main 方法：</p><pre><code class="java">public static void main(String[] args) {    System.out.println(&quot;Student类的main方法执行了&quot;);    for(String str : args) {        System.out.println(str);    }}</code></pre><p>使用反射调用：</p><pre><code class="java">try {    Method main = class3.getMethod(&quot;main&quot;, String[].class);    main.invoke(null, (Object)new String[]{&quot;刘德华&quot;, &quot;张学友&quot;, &quot;郭富城&quot;} );} catch(Exception e) {    e.printStackTrace();}</code></pre><p>输出结果：</p><pre><code>Student类的main方法执行了刘德华张学友郭富城</code></pre><h4 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h4><p>我们知道，Java 的泛型在编译期有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被清除掉。而我们的反射是动态编译的，也就是在运行期才确定类型的，通过这个原理，我们就可以通过反射来越过编译器的泛型检查。</p><p>示例：有一个 String 泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</p><pre><code class="java">    public static void main(String[] args) {        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;aaa&quot;);        list.add(&quot;bbb&quot;);        Class listClass = list.getClass();        try {            Method m = listClass.getMethod(&quot;add&quot;, Object.class);        m.invoke(list, 100);        } catch(Exception e) {            e.printStackTrace();        }        for(Object obj : list) {            System.out.println(obj);        }      }</code></pre><p>运行结果：</p><pre><code>aaabbb100</code></pre><h4 id="反射包中的Array类"><a href="#反射包中的Array类" class="headerlink" title="反射包中的Array类"></a>反射包中的Array类</h4><p>在Java的 java.lang.reflect 包中存在着一个可以动态操作数组的类: Array，它提供了动态创建和访问 Java 数组的方法。Array 允许在执行 get 或 set 操作进行取值和赋值。在Class类中与数组关联的方法是：</p><pre><code class="java">// 返回表示数组元素类型的 Class，即数组的类型Class&lt;?&gt; getComponentType()    // 判定此 Class 对象是否表示一个数组类boolean    isArray()</code></pre><p>java.lang.reflect.Array中的常用静态方法如下：</p><pre><code class="java">// 返回指定数组对象中索引组件的值。static Object get(Object array, int index)    // 以 int 形式返回指定数组对象的长度static int getLength(Object array)    // 创建一个具有指定类型和维度的新数组static object newInstance(Class&lt;?&gt; componentType, int... dimensions)    // 创建一个具有指定的组件类型和长度的新数组static Object newInstance(Class&lt;?&gt; componentType, int length)    // 将指定数组对象中索引组件的值设置为指定的新值static void set(Object array, int index, Object value)    </code></pre>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git学习总结</title>
      <link href="/2018/07/24/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/24/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>##概念区分</p><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>就是你在电脑里能看到的目录</p><h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="http://dengw.xyz/blog/180801/Jk8j0eFKLg.png?imageslim" alt="enter image description here"></p><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>存在于本地电脑上的一个分布式 git 版本库</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>很好理解啦，就比如你的 github 上的一个项目（repository）。远程仓库的默认名称是origin</p><h3 id="HEAD-和-master"><a href="#HEAD-和-master" class="headerlink" title="HEAD 和 master"></a>HEAD 和 master</h3><p>HEAD 指向当前分支，比如当你创建一个新的分支的时候，HEAD指向新的分支。<br>master 表示一个分支，一般代表的是主分支。</p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">参考链接: 创建与合并分支</a></p><h2 id="常用Git命令"><a href="#常用Git命令" class="headerlink" title="常用Git命令"></a>常用Git命令</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ul><li>git init<br>初始化一个 git 仓库，并将该文件夹格式化为一个工作区<br><br></li><li>git add file<br>添加特定文件到暂存区，其中 <code>git add .</code> 添加工作区的所有文件到暂存区<br><br></li><li>git commit -m message<br>文件提交到本地仓库的当前分支, <code>-m</code> 后面输入的是本次提交的说明<br><br></li></ul><h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><ul><li>git status<br>查看本地仓库当前的状态，显示工作区和暂存区是否有还没提交的内容<br><br></li><li>git diff<br>查看工作区和暂存区中文件的具体差异，不会显示暂存区和仓库中文件的差异<br><br></li><li><p>git log<br>显示从最近到最远的提交日志<br><img src="http://dengw.xyz/blog/180801/H9lK7egebh.png?imageslim" alt="enter image description here"></p></li><li><p>git log –pretty=oneline<br>显示从最近到最远的提交日志，差别是这里会将一次提交的日志信息在一行输出，最前面的字符串是 commit 的版本号。<br><img src="http://dengw.xyz/blog/180801/D8L4eci81H.png?imageslim" alt="enter image description here"></p></li><li><p>git reset –hard HEAD^<br>向前回退一个版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100<br><br></p></li><li>git reset –hard commit_id<br>版本回退，即回退到 commit 的版本号为 commit_id 的那次提交。<br><br></li><li>git reflog<br>查看命令历史，注意这里指挥显示关于版本前进或者后退相关的命令，比如<code>git add .</code>这种类型的命令就不会显示。<br><img src="http://dengw.xyz/blog/180801/aCl24Hkg96.png?imageslim" alt="enter image description here"> </li></ul><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><ul><li><p>git checkout – file<br>丢弃工作区该文件的修改这里有两种情况：<br>第一种是 file 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>第二种是 file 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br><br></p></li><li><p>git reset HEAD file<br>可以把暂存区的修改撤销掉（unstage），重新放回工作区（即回到git add命令之前的状态，工作区保留修改之后的状态）<br><br></p></li></ul><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>现在有一个场景，在上次已经把所有内容推送到仓库之中后，你删除了工作区的一个文件：</p><ul><li>git checkout – file<br>将工作区删除的文件恢复<br><br></li><li>git rm file<br>从版本库中删除该文件，然后再 git commit </li></ul><h3 id="远程仓库-1"><a href="#远程仓库-1" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul><li>git clone URL<br>从远程仓库URL加载创建一个与远程仓库一样的本地仓库<br><br></li><li>git push -u origin master<br>第一次推送本地仓库master分支的所有内容到远程仓库<br><br></li><li>git push orign master<br>推送本地仓库master分支的所有内容到远程仓库的master分支<br><br></li><li>git push origin dev<br>推送本地仓库master分支的所有内容到远程仓库的 dev 分支</li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h4><ul><li>git branch dev<br>创建一个名字为dev的分支<br><br></li><li>git checkout dev<br>切换到 dev 分支<br><br></li><li>git checkout -b dev<br>相当于上面两条命令的合集。创建并切换到 dev 分支<br><br></li><li>git branch<br>查看当前分支：会列出所有分支，当前分支前面会标一个 * 号<br><br></li><li>git merge dev<br>在 master 分支上执行这条命令的时候，相当于把 dev 分支的内容合并到 master分支上<br><br></li><li>git branch -d dev<br>删除 dev 这个分支<br><br></li></ul><h4 id="查看冲突"><a href="#查看冲突" class="headerlink" title="查看冲突"></a>查看冲突</h4><ul><li>git merge<br>如果合并过程中存在冲突的话会报错<br><br></li><li>git status<br>可以告诉我们冲突的文件<br><br></li><li>git log –graph<br>查看分支合并图<br><br></li></ul><h4 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h4><h5 id="Fast-forward模式："><a href="#Fast-forward模式：" class="headerlink" title="Fast forward模式："></a>Fast forward模式：</h5><p><img src="http://dengw.xyz/blog/180801/K9kG5JeEld.png?imageslim" alt="enter image description here"></p><h5 id="非-Fast-forward-模式：生成了一个新的-commit-对象"><a href="#非-Fast-forward-模式：生成了一个新的-commit-对象" class="headerlink" title="非 Fast forward 模式：生成了一个新的 commit 对象"></a>非 Fast forward 模式：生成了一个新的 commit 对象</h5><p><img src="http://dengw.xyz/blog/180801/1dde13h11J.png?imageslim" alt="enter image description here"></p><ul><li>git merge –no-ff -m “merge with no-ff” dev<br>使用非 Fast forward 模式合并一个分支<br><br></li></ul><h4 id="贮藏-Bug分支"><a href="#贮藏-Bug分支" class="headerlink" title="贮藏(Bug分支)"></a>贮藏(Bug分支)</h4><ul><li>git stash<br>把当前工作现场“储藏”起来，等以后恢复现场后继续工作，这个时候使用 git status 命令，显示是干净的，没有未提交的内容。<br><br></li><li>git stash list<br>查看保存的工作现场<br><br></li><li>git stash apply<br>恢复之前 stash 的内容，但是恢复后，stash内容并不删除，使用 git stash list 命令还是可以看到保存的工作现场，你需要用 git stash drop 来删除<br><br></li><li>git stash pop<br>恢复的同时删除保存的工作现场<br><br></li><li>git stash apply stash@{0}<br>当你你多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash<br><br></li></ul><h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><ul><li>git branch -D dev<br>丢弃一个没有被合并过的分支dev ，可以通过该命令强行删除，使用<code>git branch -d</code>命令不能删除没有合并的分支</li></ul><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><blockquote><p><strong>master分支: </strong>主分支，要时刻与远程同步；</p></blockquote><blockquote><p><strong>dev分支: </strong>开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p><p><strong>bug分支: </strong>只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></blockquote><blockquote><p><strong>feature分支: </strong>是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></blockquote><ul><li>git remote<br>查看远程库的信息， <code>git remote -v</code>显示更详细的信息。<br><br></li><li>git checkout -b dev origin/dev<br>创建远程origin的dev分支到本地。当你使用git clone 命令从远程克隆到本地仓库时，默认情况下，你只能看到本地的master分支<br><br></li><li>git pull<br>把最新的提交从远程仓库拉取下来，在本地仓库合并（如果有冲突需要先在本地解决冲突）<br><br></li><li>git branch –set-upstream-to=origin/dev dev<br>指定本地dev分支与远程 origin/dev 分支的链接，不然会 git pull 失败。这个命令的使用场景是当你从远程克隆一个仓库到本地，然后新建了一个和远程仓库一样名字的仓库，比如叫做dev，当你想要 dev 推送到远程仓库的时候，使用git pull拉取就会失败，因为本地dev分支与远程 origin/dev 分支之间没有链接。<br><br></li></ul><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<strong>本质上它就是指向某个 commit的指针</strong>。</p><p>思考这样一个问题，已经有了 commit 为什么还要有 tag 呢？主要是 commit 的版本号是一对很长的无规则的字符串，很难记，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul><li>git tag tag_name<br>切换到需要打标签的分支，创建一个标签，默认标签是打在最新提交的commit上的。<br><br></li><li>git tag tag_name commit_id<br>将名字为 tag_name 的标签和 id 为 commit_id 的 commit 关联起来<br><br></li><li>git tag -a tag_name -m “commit” commit_id<br>创建带有说明的标签，<code>-m</code>指定说明文字。<br><br></li><li>git tag<br>查看所有标签，注意<strong>标签不是按时间顺序列出，而是按字母排序</strong>的<br><br></li><li>git show tag_name<br>查看对应标签的具体信息<br><br></li></ul><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul><li>git tag -d tag_name<br>根据标签名删除指定标签</li><li>git push origin tag_name<br>推送某个标签到远程</li><li>git push origin –tags<br>一次性推送全部尚未推送的标签到远程</li></ul><p>一个场景：如果标签已经推送到远程，先要删除远程标签。</p><ul><li>先从本地删除：<code>git tag -d tag_name</code></li><li>然后，从远程删除，删除命令也是push，格式如下：<code>git push origin :refs/tags/tag_name</code><br><br></li></ul><h3 id="SourceTree-对应到-Git-部分名词解释"><a href="#SourceTree-对应到-Git-部分名词解释" class="headerlink" title="SourceTree 对应到 Git 部分名词解释"></a>SourceTree 对应到 Git 部分名词解释</h3><ul><li>克隆(clone)：从远程仓库URL加载创建一个与远程仓库一样的本地仓库</li><li>提交(commit)：将暂存文件上传到本地仓库（我们在Finder中对本地仓库做修改后一般都得先提交一次，再推送）</li><li>合并(merge)：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消</li><li>抓取(fetch)：从远程仓库获取信息并同步至本地仓库</li><li>拉取(pull)：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作，即 pull=fetch+merge</li><li>推送(push)：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致</li><li>检出(checkout)：切换不同分支</li><li>添加(add)：添加文件到暂存区</li><li>移除(remove)：移除文件至暂存区</li><li>储藏/贮藏(git stash)：保存工作现场</li><li>重置(reset)：回到最近添加(add)/提交(commit)状态</li><li>分支(branch)：创建/修改/删除分支</li><li>标签(tag): 给项目增添标签</li><li>工作流(Git Flow): 团队工作时，每个人创建属于自己的分支（branch），确定无误后提交到master分枝</li><li>终端(terminal): 可以输入git命令行</li></ul><h3 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h3><p><a href="https://blog.csdn.net/zyw0713/article/details/80083431" target="_blank" rel="noopener">git 的工作流程（纯干货）</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解HTTP学习笔记—第三、四章</title>
      <link href="/2018/07/23/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E7%AB%A0/"/>
      <url>/2018/07/23/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%89%E3%80%81%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的<br>空行（CR+LF）来划分。通常，并不一定要有报文主体。<br><img src="http://dengw.xyz/blog/180723/00Kmk484a2.png?imageslim" alt="enter image description here"></p><p>具体到请求报文和响应报文如下：<br><img src="http://dengw.xyz/blog/180723/hege5iFAKF.png?imageslim" alt="enter image description here"></p><h3 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h3><p><img src="http://dengw.xyz/blog/180722/5mDJkLj6fe.png?imageslim" alt="enter image description here"></p><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>请求行由请求方法，URL字段和HTTP协议的版本组成，格式如下：</p><pre><code>Method Request-URI HTTP-Version CRLF</code></pre><p>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p><p><strong>请求方法</strong>： 表示向请求资源指定的资源发送请求报文的方法，其作用是可以指定请求的资源按期望产生某种行为。HTTP 请求方法有8种，分别是GET、POST、DELETE、PUT、HEAD、TRACE、CONNECT 、OPTIONS。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th><th style="text-align:left">支持的HTTP协议版本</th></tr></thead><tbody><tr><td style="text-align:left">GET</td><td style="text-align:left">请求获取Request-URI所标识的资源</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">POST</td><td style="text-align:left">在Request-URI所标识的资源后附加新的数据</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">HEAD</td><td style="text-align:left">请求获取由Request-URI所标识的资源的响应消息报头</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">请求服务器存储一个资源，并用Request-URI作为其标识</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">请求服务器删除Request-URI所标识的资源</td><td style="text-align:left">1.0、1.1</td></tr><tr><td style="text-align:left">OPTIONS</td><td style="text-align:left">查询针对请求URI指定的资源支持的方法</td><td style="text-align:left">1.1</td></tr><tr><td style="text-align:left">TRACE</td><td style="text-align:left">请求服务器将之前的请求通信返回给客户端，主要用于测试或诊断</td><td style="text-align:left">1.1</td></tr><tr><td style="text-align:left">CONNECT</td><td style="text-align:left">要求在与代理服务器通信时建立隧道，实现用隧道的方式进行TCP通信。主要是使用SSL和TLS协议把通信内容加密后经网络隧道传输</td><td style="text-align:left">1.1</td></tr><tr><td style="text-align:left">LINK</td><td style="text-align:left">建立和资源之间的连接</td><td style="text-align:left">1.0</td></tr><tr><td style="text-align:left">UNLINK</td><td style="text-align:left">断开和资源之间的连接</td><td style="text-align:left">1.0</td></tr></tbody></table><p><strong>Request-URI</strong>：这个部分我们已经在本系列的第一篇博客中介绍了。</p><p><strong>HTTP协议版本</strong>：两种：HTTP1.0/HTTP1.1，两者的区别在于HTTP1.0对于每个连接都只能传送一个请求和响应，请求就会关闭，HTTP1.0没有Host字段；而HTTP1.1在同一个连接中可以传送多个请求和响应，多个请求可以重叠和同时进行，HTTP1.1必须有Host字段。</p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>即请求报文的首部除去请求行的部分，从本博客的第二张图可以看出，这部分可以分为：请求首部字段、通用首部字段以及实体首部字段，由<code>key/value</code>键值对组成，每行一对，key和value用冒号”:”分隔。</p><p>常见的首部字段及其含义见本文尾。</p><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>若方法字段是GET，则此项为空，没有数据；若方法字段是POST,则通常来说此处放置的就是要提交的数据。</p><p>比如要使用POST方法提交一个表单，其中有user字段中数据为“admin”, password字段为123456，那么这里的请求数据就是 user=admin&amp;password=123456，使用&amp;来连接各个字段。</p><p>下面是一个典型的GET方法的请求报文，可以对照上面的介绍进行理解。</p><pre><code>GET http://blog.csdn.net/itachi85 HTTP/1.1                                //请求行Host: blog.csdn.net                                                       //请求报头Connection: keep-aliveCache-Control: max-age=0       Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36 QQBrowser/9.3.6872.400Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8Cookie: bdshare_firstime=1443768140949</code></pre><h3 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h3><p><img src="http://dengw.xyz/blog/180722/4hG7C2cjJD.png?imageslim" alt="enter image description here"></p><p>HTTP的响应报文由响应行、响应头、响应数据组成。</p><h4 id="状态行（响应行）"><a href="#状态行（响应行）" class="headerlink" title="状态行（响应行）"></a>状态行（响应行）</h4><p>状态行格式如下：</p><pre><code>HTTP-Version Status-Code Reason-Phrase CRLF</code></pre><p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。</p><p>HTTP协议版本上面已经介绍过了。</p><p><strong>状态码</strong>：状态代码由三位数字组成，，第一位数字定义了响应的类别，有以下五种：</p><blockquote><p>1XX：信息提示。表示请求已被服务器接受，但需要继续处理，范围为100~101。</p><p>2XX：请求成功。服务器成功处理了请求。范围为200~206。</p><p>3XX：客户端重定向。重定向状态码用于告诉客户端浏览器，它们访问的资源已被移动，并告诉客户端新的资源位置。客户端收到重定向会重新对新资源发起请求。范围为300~305。</p><p>4XX：客户端信息错误。客户端可能发送了服务器无法处理的东西，比如请求的格式错误，或者请求了一个不存在的资源。范围为400~415。</p><p>5XX：服务器出错。客户端发送了有效的请求，但是服务器自身出现错误，比如Web程序运行出错。范围是500~505。</p></blockquote><p>部分状态码及其文本描述和所表示的意义如下：</p><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">状态码英文名称</th><th style="text-align:left">中文描述</th></tr></thead><tbody><tr><td style="text-align:left">100</td><td style="text-align:left">Continue</td><td style="text-align:left">这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</td></tr><tr><td style="text-align:left">200</td><td style="text-align:left">OK</td><td style="text-align:left">表示从客户端发来的请求在服务器端被正常处理了</td></tr><tr><td style="text-align:left">204</td><td style="text-align:left">No Content</td><td style="text-align:left">代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</td></tr><tr><td style="text-align:left">206</td><td style="text-align:left">Partial Content</td><td style="text-align:left">表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求</td></tr><tr><td style="text-align:left">301</td><td style="text-align:left">Moved Permanently</td><td style="text-align:left">永久性重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td style="text-align:left">302</td><td style="text-align:left">Found</td><td style="text-align:left">临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问</td></tr><tr><td style="text-align:left">303</td><td style="text-align:left">See Other</td><td style="text-align:left">表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源</td></tr><tr><td style="text-align:left">304</td><td style="text-align:left">Not Modified</td><td style="text-align:left">表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分</td></tr><tr><td style="text-align:left">307</td><td style="text-align:left">Temporary Redirect</td><td style="text-align:left">临时重定向。该状态码与 302 有着相同的含义，307 会遵照浏览器标准，不会从 POST 变成 GET</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">Bad Request</td><td style="text-align:left">表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码</td></tr><tr><td style="text-align:left">401</td><td style="text-align:left">Unauthorized</td><td style="text-align:left">发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息</td></tr><tr><td style="text-align:left">403</td><td style="text-align:left">Forbidden</td><td style="text-align:left">表明对请求资源的访问被服务器拒绝了,未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因</td></tr><tr><td style="text-align:left">404</td><td style="text-align:left">Not Found</td><td style="text-align:left">服务器无法根据客户端的请求找到资源（网页)</td></tr><tr><td style="text-align:left">408</td><td style="text-align:left">Request Time-out</td><td style="text-align:left">服务器等待客户端发送的请求时间过长超时</td></tr><tr><td style="text-align:left">500</td><td style="text-align:left">Internal Server Error</td><td style="text-align:left">表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障</td></tr><tr><td style="text-align:left">503</td><td style="text-align:left">Service Unavailable</td><td style="text-align:left">表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</td></tr></tbody></table><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>即响应报文的首部除去状态行的部分，从本博客的第二张图可以看出，这部分可以分为：响应首部字段、通用首部字段以及实体首部字段，由<code>key/value</code>键值对组成，每行一对，key和value用冒号”:”分隔。</p><p>常见的首部字段及其含义见本文尾。</p><h4 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h4><p>也就是响应体，响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。</p><h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。</p><h4 id="报文和实体的区别"><a href="#报文和实体的区别" class="headerlink" title="报文和实体的区别"></a>报文和实体的区别</h4><ul><li>如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。</li><li>报文实体由实体首部和实体主体组成，实体首部描述了 HTTP 报文的内容，实体主体中就是货物：</li></ul><p>在整个报文中实体的位置：<br><img src="http://dengw.xyz/blog/180723/j9IF2cjJcD.png?imageslim" alt="enter image description here"></p><h4 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p><ul><li>内容编码的过程<br><img src="http://dengw.xyz/blog/180723/6kD8LJj3j3.png?imageslim" alt="enter image description here"></li></ul><p>常用的内容编码有以下几种。</p><ul><li>gzip（GNU zip）</li><li>compress（UNIX 系统的标准压缩）</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ul><h4 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h4><p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p><p>这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。<br><img src="http://dengw.xyz/blog/180723/5b5gG3Ecbk.png?imageslim" alt="enter image description here"></p><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。</p><p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。</p><h3 id="获取部分内容的范围获取"><a href="#获取部分内容的范围获取" class="headerlink" title="获取部分内容的范围获取"></a>获取部分内容的范围获取</h3><p>指定下载的实体范围，指定范围发送的请求叫做范围发送。</p><p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10000 字节内的资源。<br><img src="http://dengw.xyz/blog/180723/2i8Cd276mL.png?imageslim" alt="enter image description here"></p><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p><ul><li>5001~10 000 字节<pre><code>Range: bytes=5001-10000</code></pre></li><li>从 5001 字节之后全部的<pre><code>Range: bytes=5001-</code></pre></li><li>从一开始到 3000 字节和 5000~7000 字节的多重范围<pre><code>Range: bytes=-3000, 5000-7000</code></pre>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</li></ul><p>如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。</p><h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于ANR欧老师有话要说</title>
      <link href="/2018/07/20/%E5%85%B3%E4%BA%8EANR%E6%AC%A7%E8%80%81%E5%B8%88%E6%9C%89%E8%AF%9D%E8%A6%81%E8%AF%B4/"/>
      <url>/2018/07/20/%E5%85%B3%E4%BA%8EANR%E6%AC%A7%E8%80%81%E5%B8%88%E6%9C%89%E8%AF%9D%E8%A6%81%E8%AF%B4/</url>
      
        <content type="html"><![CDATA[<p>这篇博客是在欧老师关于ANR的ppt之上总结出来，觉得很有价值，所以想记录一下。</p><p>这篇文章主要从以下四个方面介绍ANR，包括：什么是ANR、怎么发现ANR、如何解决ANR、以及怎么避免ANR。</p><h3 id="什么是ANR"><a href="#什么是ANR" class="headerlink" title="什么是ANR"></a>什么是ANR</h3><p>Application Not Responding：应用无响应</p><h4 id="广义的设计"><a href="#广义的设计" class="headerlink" title="广义的设计"></a>广义的设计</h4><ul><li><p>ANR背后体现了大部分的GUI应用机制;</p></li><li><p>从远古的MiniGUI、Win32到Android，大部分的GUI设计中都存在一个“严格”意义上的主线程;</p></li><li><p>ANR并不可怕，它本身是GUI应用的一种应用的机制；</p></li><li><p>Android 主线程其实“背负”着重要的任务;</p></li></ul><p>这里有一个很启发性的问题：为什么一个GUI程序中为什么要有ANR？</p><h4 id="Watchdog与观察机制"><a href="#Watchdog与观察机制" class="headerlink" title="Watchdog与观察机制"></a>Watchdog与观察机制</h4><p>谁来监控应用ANR？</p><p>ActivityManager 和 WindowManager 系统服务进行监控；它是一个轻量Watchdog机制，用于看护ANR发生的可能性；因此观察ANR是系统层面的事务，它为各应用做了统一的屏障与监控；</p><p>发生ANR的时候，用户只能选择等待或者结束进程；</p><h4 id="从时间角度看ANR"><a href="#从时间角度看ANR" class="headerlink" title="从时间角度看ANR"></a>从时间角度看ANR</h4><p><img src="http://dengw.xyz/blog/180720/LB8e8abi2l.png?imageslim" alt="enter image description here"></p><h4 id="从引发角度看ANR"><a href="#从引发角度看ANR" class="headerlink" title="从引发角度看ANR"></a>从引发角度看ANR</h4><p><img src="http://dengw.xyz/blog/180720/0D9CEHga6E.png?imageslim" alt="enter image description here"></p><h3 id="发现ANR"><a href="#发现ANR" class="headerlink" title="发现ANR"></a>发现ANR</h3><pre><code>04-06 15:58:46.215 23480-23483/com.example.testanr I/art: Thread[2,tid=23483,WaitingInMainSignalCatcherLoop,Thread*=0x7fa2307000,peer=0x12cb40a0,&quot;Signal Catcher&quot;]: reacting to signal 304-06 15:58:46.364 23480-23483/com.example.testanr I/art: Wrote stack traces to &#39;/data/anr/traces.txt‘</code></pre><p>应用发生ANR的时候<br>1、Logcat中会抛出日志<br>2、系统会向指定路径写入日志，路径为/data/anr/traces.txt</p><p>特别注意：<br>正常情况下，每一次新的ANR日志，会把之前的ANR信息覆盖掉；比如微信产生的ANR和QQ产生的ANR可能会在同一个ANR日志文件中生成，后生成的会把先生成的覆盖掉。</p><p>因此ANR日志的处理和收集，要及时，即包括了Logcat日志，也包括了ANR的traces.txt文件；</p><p><img src="http://dengw.xyz/blog/180720/I4l62EdiGl.png?imageslim" alt="enter image description here"></p><p>获取的方式有多种：</p><ul><li><p>adb pull /data/anr/traces.txt -&gt; xxx </p></li><li><p>Root下可以使用ES文件管理器直接取到其它环境</p></li></ul><p>一个标准的ANR日志:</p><ul><li>确定发生ANR所在的进程和时间<br><img src="http://dengw.xyz/blog/180720/Dm9LIhAkb1.png?imageslim" alt="enter image description here"></li></ul><p><img src="http://dengw.xyz/blog/180720/33I4aC1cA1.png?imageslim" alt="enter image description here"></p><ul><li>发生ANR的线程信息，可以快速确定责任方<br><img src="http://dengw.xyz/blog/180720/26C3H57Ekd.png?imageslim" alt="enter image description here"></li></ul><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><ul><li><p>Java线程状态<br><img src="http://dengw.xyz/blog/180720/el796HICe8.png?imageslim" alt="enter image description here"></p></li><li><p>c线程状态<br><img src="http://dengw.xyz/blog/180720/L5gFc9dLmi.png?imageslim" alt="enter image description here"></p></li></ul><p>两者可以看出在C代码中定义更为详细,<strong>Traces中显示的线程状态都是C代码定义的</strong>。我们可以通过查看线程状态对应的信息分析ANR问题。</p><p>例如: </p><ul><li><strong>TimedWaiting</strong>       // 对应的线程状态是TIMED_WAITING</li><li><strong>kTimedWaiting</strong>     // TIMED_WAITING TS_WAIT in Object.wait() with a timeout 执行了无超时参数的wait函数</li><li><strong>kSleeping</strong>             // TIMED_WAITING TS_SLEEPING in Thread.sleep() 执行了带有超时参数的sleep函数</li></ul><h3 id="解决ANR"><a href="#解决ANR" class="headerlink" title="解决ANR"></a>解决ANR</h3><p>核心实战思路（三步走）：</p><p>1、最大限度抓取日志<br>          一切的前提</p><p>2、分析问题的内因<br>          主线程阻塞、挂起、死循环；应用进程的其他线程的CPU占用率高，使得主线程无法抢占到CPU时间片</p><p>3、分析问题外因<br>          当前应用进程进行进程间通信请求其他进程，其他进程的操作长时间没有反馈；其他进程的CPU占用率高，使得当前应用进程无法抢占到CPU时间片。</p><h3 id="避免ANR"><a href="#避免ANR" class="headerlink" title="避免ANR"></a>避免ANR</h3><p><strong>预防胜于治疗</strong></p><ul><li>平时就要对代码质量严格要求，充分解耦，结构设计清晰，异常处理规范；</li><li>重视各种静态分析工具找出的“小”问题，做好单元测试等等；</li><li>这些基础工作都做到位了，即便有问题，定位也是分分钟的事情，很少出现诡异的 Bug；否则代码像一团面条，即便各种环境信息充分，甚至当你面重现了问题，也未必能很快搞得清缘由。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解HTTP学习笔记—第二章</title>
      <link href="/2018/07/19/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2018/07/19/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章：简单的-HTTP-协议"><a href="#第二章：简单的-HTTP-协议" class="headerlink" title="第二章：简单的 HTTP 协议"></a>第二章：简单的 HTTP 协议</h2><p>HTTP协议肯定是客户端开始建立通信的，有时候两台计算机作为服务端和客户端的角色是会互换的。</p><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>HTTP协议不对请求和响应之间的通信状态进行保存。<br>HTTP是不会为了下一次连接而维护这次连接所传输的信息，比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。 <strong>这是为了保证服务器内存，更快地处理大量的事物，确保协议的可伸缩性</strong>。 </p><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p><p>可是，现代web有时需要HTTP是有状态的，因为无状态可能会导致业务处理变得更棘手。比如登录到一个购物网站，当你从一个页面跳转到另一个页面，如果是无状态的话登录状态就不会被保存，此时又需要一次登录操作。但如果是有状态的就能够保持登录状态。</p><p>HTTP/1.1虽然也是无状态协议，但是引入了cookie技术，这样就能够管理状态了，有关cookie的介绍后面再学习。</p><h3 id="持久连接和非持久连接的区别"><a href="#持久连接和非持久连接的区别" class="headerlink" title="持久连接和非持久连接的区别"></a>持久连接和非持久连接的区别</h3><ul><li><p>非持久连接<br><img src="http://dengw.xyz/blog/180723/5b7BkCKBD2.png?imageslim" alt="非持久连接"></p></li><li><p>持久连接<br><img src="http://dengw.xyz/blog/180723/Fggl11LF4e.png?imageslim" alt="持久连接"></p></li></ul><h3 id="无状态与-keep-alive的区别"><a href="#无状态与-keep-alive的区别" class="headerlink" title="无状态与 keep alive的区别"></a>无状态与 keep alive的区别</h3><p>无状态不代表HTTP不能保持TCP连接</p><p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，一个tcp连接可以传输多个web对象。<br>而像HTTP/1.0协议使用就是非持久连接，即在非持久连接下,一个tcp连接只传输一个Web对象。</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>管线化技术可以不用等待上一个响应而直接发送下一个请求。<br><img src="http://dengw.xyz/blog/180723/0EliGkam6i.png?imageslim" alt="enter image description here"></p><h3 id="使用Cookie进行状态管理"><a href="#使用Cookie进行状态管理" class="headerlink" title="使用Cookie进行状态管理"></a>使用Cookie进行状态管理</h3><p>前面已经说到HTTP是无状态的，但是有时候我们需要HTTP “有状态”，比如我们之前说到登录状态验证，没跳转一个网页就登陆一次的话用户体验确实非常的不好。</p><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信号来控制客户端的状态。</p><p>Cookie会根据从服务器端发送的<strong>响应报文内</strong>的一个叫做<strong>set-Cookie</strong>的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。服务端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发送过来的请求，然后与服务器上得记录进行对比，最后得到之前的状态信息。</p><ul><li><p>没有Cookie信息状态下的请求<br><img src="http://dengw.xyz/blog/180723/Le8LLkD1GJ.png?imageslim" alt="enter image description here"></p></li><li><p>第2次以后（存在Cookie信息状态）的请求<br><img src="http://dengw.xyz/blog/180723/j8iaLcl5Jb.png?imageslim" alt="enter image description here"></p></li></ul><p>在从报文的角度认识一下这个过程：</p><ol><li><p>请求报文（没有Cookie信息的状态）</p><pre><code>GET /reader/ HTTP/1.1Host: hackr.jp*首部字段内没有Cookie的相关信息</code></pre></li><li><p>响应报文（客户端生成Cookie信息）</p><pre><code>HTTP/1.1 200 OKDate: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞Content-Type: text/plain; charset=UTF-8</code></pre></li><li><p>请求报文（自动发送保存着的Cookie信息）</p><pre><code>GET /image/ HTTP/1.1Host: hackr.jpCookie: sid=1342077140226724</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>验证layout_weight属性</title>
      <link href="/2018/07/19/%E7%90%86%E8%A7%A3layout-weight%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/07/19/%E7%90%86%E8%A7%A3layout-weight%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>今天在看代码的时候看到了<code>layout_weight</code>属性的时候突然想到了一个问题，一直都知道它是让剩余空间按比例划分后再划分给每个View，但是具体是怎么划分的却不是很清楚，参考这篇博客<a href="https://www.cnblogs.com/net168/p/4227144.html" target="_blank" rel="noopener">Android知识点剖析系列：深入了解layout_weight属性</a>的时候也没有明确说，所以就想自己来验证一下。</p><p><strong>开始验证</strong></p><h3 id="使用layout-weight属性前的代码"><a href="#使用layout-weight属性前的代码" class="headerlink" title="使用layout_weight属性前的代码"></a>使用<code>layout_weight</code>属性前的代码</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot; &gt;    &lt;TextView        android:id=&quot;@+id/text1&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;100dp&quot;        android:gravity=&quot;center&quot;        android:text=&quot;区域1&quot;        android:textSize=&quot;22sp&quot;        android:background=&quot;@color/colorAccent&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/text2&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;100dp&quot;        android:gravity=&quot;center&quot;        android:text=&quot;区域2&quot;        android:textSize=&quot;22sp&quot;        android:background=&quot;@color/colorPrimaryDark&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/text3&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;200dp&quot;        android:gravity=&quot;center&quot;        android:text=&quot;区域3&quot;        android:textSize=&quot;22sp&quot;        android:background=&quot;@color/colorAccent&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><p>代码很简单，就是一个竖直布局的Linearlayout，然后在里面添加三个固定高度的<code>TextView</code>,下面是布局效果：<br><img src="http://dengw.xyz/blog/180719/JiKFem9IE6.png?imageslim" alt="enter image description here"></p><p>没什么问题，然后我们可以在Activity中输出一下具体的高度数值，这里需要注意一下是不能直接在Activity的生命周期函数中直接输出View的宽度和高度的，具体的愿意以及方法可以参考一下我的这篇博客：<a href="https://www.dengw.xyz/2018/07/02/%E5%9C%A8Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%8E%B7%E5%8F%96%E6%8E%A7%E4%BB%B6%E5%AE%BD%E9%AB%98%E7%9A%84%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">在Activity生命周期获取控件宽高的探究</a>。</p><p><img src="http://dengw.xyz/blog/180719/mb3e4EC8jk.png?imageslim" alt="enter image description here"></p><p>需要补充一下的是ContentBar是内容栏的高度，就是下面图片中白色部分的高度。</p><p><img src="http://dengw.xyz/blog/180719/lD96aelJDb.png?imageslim" alt="enter image description here"></p><h3 id="使用layout-weight属性后的代码"><a href="#使用layout-weight属性后的代码" class="headerlink" title="使用layout_weight属性后的代码"></a>使用<code>layout_weight</code>属性后的代码</h3><pre><code class="xml">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot; &gt;    &lt;TextView        android:id=&quot;@+id/text1&quot;        android:layout_weight=&quot;1&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;100dp&quot;        android:gravity=&quot;center&quot;        android:text=&quot;区域1&quot;        android:textSize=&quot;22sp&quot;        android:background=&quot;@color/colorAccent&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/text2&quot;        android:layout_weight=&quot;1&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;100dp&quot;        android:gravity=&quot;center&quot;        android:text=&quot;区域2&quot;        android:textSize=&quot;22sp&quot;        android:background=&quot;@color/colorPrimaryDark&quot;/&gt;    &lt;TextView        android:id=&quot;@+id/text3&quot;        android:layout_weight=&quot;1&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;200dp&quot;        android:gravity=&quot;center&quot;        android:text=&quot;区域3&quot;        android:textSize=&quot;22sp&quot;        android:background=&quot;@color/colorAccent&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><p>为了方便我们验证，我们为每个TextView的<code>layout_weight</code>属性都设为1，下面是新的布局效果。</p><p><img src="http://dengw.xyz/blog/180719/g4m77Ch6k8.png?imageslim" alt="enter image description here"></p><p>然后同样输出具体的数值，如下：<br><img src="http://dengw.xyz/blog/180719/49Cbe651Le.png?imageslim" alt="enter image description here"></p><p>可以看到3个TextView的高度分别是459、459、759px，使用这个属性之前的数值分别是300、300、600, 下面我们根据规则来验证一下：</p><p>先按正常布局后剩余高度：1677 - 300 - 300 - 600 = 477；<br>然后按照1 : 1 : 1每一份为159;<br>到这儿了很容易想到459 = 300 + 159, 759 = 600 + 159;</p><p>到这儿我们可以知道<code>layout_weight</code>属性的作用原理了：它是在没有<code>layout_weight</code>属性的基础上，将屏幕剩余空间按比例进行分配，然后将对应的值在原基础上求代数和，得到该属性作用之后控件的高度了。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图解HTTP学习笔记—第一章</title>
      <link href="/2018/07/18/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2018/07/18/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：了解Web及网络基础"><a href="#第一章：了解Web及网络基础" class="headerlink" title="第一章：了解Web及网络基础"></a>第一章：了解Web及网络基础</h2><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>定义：网络通信过程中所使用到的所有协议的统称<br>作用的层次：应用层、传输层、网络层、数据链路层。<br><img src="http://dengw.xyz/blog/180718/D0giEa3c08.png?imageslim" alt="enter image description here"></p><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><p>URI （统一资源标识符）使用字符串标识了某一网络资源，给该资源标记命名。<br><img src="http://dengw.xyz/blog/180718/9j6AGhcmCD.png?imageslim" alt="enter image description here"></p><p>URL（统一资源定位符）是URI的子集，因此也有标识资源的作用，另外还提供一种定位该资源的主要访问机制，表明该资源在互联网上的位置。</p><h4 id="绝对URI格式"><a href="#绝对URI格式" class="headerlink" title="绝对URI格式"></a>绝对URI格式</h4><p><img src="http://dengw.xyz/blog/180718/a8AEDfKCEj.png?imageslim" alt="enter image description here"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Awesome tools for programer</title>
      <link href="/2018/07/06/Awesome%20tools%20for%20programer/"/>
      <url>/2018/07/06/Awesome%20tools%20for%20programer/</url>
      
        <content type="html"><![CDATA[<h2 id="A-list-show-as-a-programer-always-used-tools"><a href="#A-list-show-as-a-programer-always-used-tools" class="headerlink" title="A-list-show-as-a-programer-always-used-tools"></a>A-list-show-as-a-programer-always-used-tools</h2><p>程序员常用工具列表：</p><h3 id="本地磁盘搜索工具："><a href="#本地磁盘搜索工具：" class="headerlink" title="本地磁盘搜索工具："></a>本地磁盘搜索工具：</h3><ul><li><p>Everything：<a href="http://www.voidtools.com/" target="_blank" rel="noopener">http://www.voidtools.com/</a></p></li><li><p>Listary：<a href="http://www.listary.com/" target="_blank" rel="noopener">http://www.listary.com/</a></p></li><li><p>光速搜索：<a href="http://finder.sdo.com/" target="_blank" rel="noopener">http://finder.sdo.com/</a></p></li><li><p>百度硬盘：<a href="http://disk.baidu.com/" target="_blank" rel="noopener">http://disk.baidu.com/</a></p></li><li><p>Alfred(Mac)：<a href="http://www.alfredapp.com" target="_blank" rel="noopener">http://www.alfredapp.com</a></p></li></ul><h3 id="资源管理工具："><a href="#资源管理工具：" class="headerlink" title="资源管理工具："></a>资源管理工具：</h3><ul><li><p>Total Commander：<a href="http://www.ghisler.com/" target="_blank" rel="noopener">http://www.ghisler.com/</a></p></li><li><p>Clover：<a href="http://cn.ejie.me/" target="_blank" rel="noopener">http://cn.ejie.me/</a></p></li></ul><h3 id="个人知识管理工具："><a href="#个人知识管理工具：" class="headerlink" title="个人知识管理工具："></a>个人知识管理工具：</h3><ul><li><p>有道云笔记：<a href="http://note.youdao.com/" target="_blank" rel="noopener">http://note.youdao.com/</a></p></li><li><p>麦库记事：<a href="http://note.sdo.com/" target="_blank" rel="noopener">http://note.sdo.com/</a></p></li><li><p>为知笔记：<a href="http://www.wiz.cn/" target="_blank" rel="noopener">http://www.wiz.cn/</a></p></li><li><p>Evernote：<a href="http://www.yinxiang.com/" target="_blank" rel="noopener">http://www.yinxiang.com/</a></p></li></ul><h3 id="源码阅读工具："><a href="#源码阅读工具：" class="headerlink" title="源码阅读工具："></a>源码阅读工具：</h3><ul><li><p>Source insight：<a href="http://sourceinsight.com/" target="_blank" rel="noopener">http://sourceinsight.com/</a></p></li><li><p>Vim：<a href="http://www.vim.org/" target="_blank" rel="noopener">http://www.vim.org/</a></p></li></ul><h3 id="文件比较工具："><a href="#文件比较工具：" class="headerlink" title="文件比较工具："></a>文件比较工具：</h3><ul><li>Beyond Compare：<a href="http://www.scootersoftware.com/" target="_blank" rel="noopener">http://www.scootersoftware.com/</a></li></ul><h3 id="优秀插件："><a href="#优秀插件：" class="headerlink" title="优秀插件："></a>优秀插件：</h3><ul><li><p>Visual Assist：<a href="http://www.wholetomato.com/" target="_blank" rel="noopener">http://www.wholetomato.com/</a></p></li><li><p>SwitchySharp：<a href="https://code.google.com/p/switchysharp/" target="_blank" rel="noopener">https://code.google.com/p/switchysharp/</a></p></li></ul><h3 id="在线工具："><a href="#在线工具：" class="headerlink" title="在线工具："></a>在线工具：</h3><ul><li>开源在线工具：<a href="http://tool.oschina.net/" target="_blank" rel="noopener">http://tool.oschina.net/</a></li></ul><h3 id="命令行工具："><a href="#命令行工具：" class="headerlink" title="命令行工具："></a>命令行工具：</h3><ul><li>DOS、Git</li></ul><h3 id="源码管理工具："><a href="#源码管理工具：" class="headerlink" title="源码管理工具："></a>源码管理工具：</h3><ul><li><p>Github for Windows：<a href="http://windows.github.com/" target="_blank" rel="noopener">http://windows.github.com/</a></p></li><li><p>Git：<a href="https://code.google.com/p/msysgit/" target="_blank" rel="noopener">https://code.google.com/p/msysgit/</a></p></li><li><p>Svn：<a href="http://tortoisesvn.net/" target="_blank" rel="noopener">http://tortoisesvn.net/</a></p></li><li><p>Cvs：<a href="http://www.tortoisecvs.org/" target="_blank" rel="noopener">http://www.tortoisecvs.org/</a></p></li></ul><h3 id="网盘及网盘资源搜索工具："><a href="#网盘及网盘资源搜索工具：" class="headerlink" title="网盘及网盘资源搜索工具："></a>网盘及网盘资源搜索工具：</h3><ul><li><p>百度网盘：<a href="http://pan.baidu.com/disk/home" target="_blank" rel="noopener">http://pan.baidu.com/disk/home</a></p></li><li><p>网盘搜索工具：<a href="http://so.baiduyun.me/" target="_blank" rel="noopener">http://so.baiduyun.me/</a></p></li><li><p>网盘屋：<a href="http://www.wangpanwu.com/" target="_blank" rel="noopener">http://www.wangpanwu.com/</a></p></li></ul><h3 id="磁盘恢复工具："><a href="#磁盘恢复工具：" class="headerlink" title="磁盘恢复工具："></a>磁盘恢复工具：</h3><ul><li>Diskgenius：<a href="http://www.diskgenius.cn/" target="_blank" rel="noopener">http://www.diskgenius.cn/</a></li></ul><h3 id="文件查看工具："><a href="#文件查看工具：" class="headerlink" title="文件查看工具："></a>文件查看工具：</h3><ul><li><p>Winhex：<a href="http://winhex.en.softonic.com/" target="_blank" rel="noopener">http://winhex.en.softonic.com/</a></p></li><li><p>UltraEdit：<a href="http://www.ultraedit.com/" target="_blank" rel="noopener">http://www.ultraedit.com/</a></p></li></ul><h3 id="流程图工具："><a href="#流程图工具：" class="headerlink" title="流程图工具："></a>流程图工具：</h3><ul><li>Visio：<a href="http://office.microsoft.com/zh-cn/visio/" target="_blank" rel="noopener">http://office.microsoft.com/zh-cn/visio/</a></li></ul><h3 id="FTP服务器："><a href="#FTP服务器：" class="headerlink" title="FTP服务器："></a>FTP服务器：</h3><ul><li>FileZilla：<a href="https://filezilla-project.org/" target="_blank" rel="noopener">https://filezilla-project.org/</a></li></ul><h3 id="思维导图工具："><a href="#思维导图工具：" class="headerlink" title="思维导图工具："></a>思维导图工具：</h3><ul><li>Mindjet：<a href="http://www.mindjet.com/" target="_blank" rel="noopener">http://www.mindjet.com/</a></li></ul><h3 id="电子书阅读工具："><a href="#电子书阅读工具：" class="headerlink" title="电子书阅读工具："></a>电子书阅读工具：</h3><ul><li><p>百度阅读器：<a href="http://yueduqi.baidu.com/" target="_blank" rel="noopener">http://yueduqi.baidu.com/</a></p></li><li><p>福昕阅读器：<a href="http://www.foxitsoftware.cn/" target="_blank" rel="noopener">http://www.foxitsoftware.cn/</a></p></li></ul><h3 id="GTD、备忘工具："><a href="#GTD、备忘工具：" class="headerlink" title="GTD、备忘工具："></a>GTD、备忘工具：</h3><ul><li><p>Doit.im：<a href="http://doitim.com/cn/" target="_blank" rel="noopener">http://doitim.com/cn/</a></p></li><li><p>小孩桌面便签：<a href="http://www.notesmaker.com/" target="_blank" rel="noopener">http://www.notesmaker.com/</a></p></li></ul><h3 id="日历："><a href="#日历：" class="headerlink" title="日历："></a>日历：</h3><ul><li><p>谷歌日历：<a href="https://www.google.com/calendar/render?pli=1" target="_blank" rel="noopener">https://www.google.com/calendar/render?pli=1</a></p></li><li><p>人生日历：<a href="http://rili.160.com/" target="_blank" rel="noopener">http://rili.160.com/</a></p></li></ul><h3 id="网址导航："><a href="#网址导航：" class="headerlink" title="网址导航："></a>网址导航：</h3><ul><li><p>产品经理网址导航：<a href="http://www.pm265.com/" target="_blank" rel="noopener">http://www.pm265.com/</a></p></li><li><p>设计师网址导航：<a href="http://hao.uisdc.com/" target="_blank" rel="noopener">http://hao.uisdc.com/</a></p></li></ul><h3 id="自我提升："><a href="#自我提升：" class="headerlink" title="自我提升："></a>自我提升：</h3><ul><li>外刊IT评论：<a href="http://www.vaikan.com/" target="_blank" rel="noopener">http://www.vaikan.com/</a></li><li></li><li>伯乐在线：<a href="http://blog.jobbole.com/" target="_blank" rel="noopener">http://blog.jobbole.com/</a></li><li></li><li><p>ImportNew：<a href="http://www.importnew.com/" target="_blank" rel="noopener">http://www.importnew.com/</a></p></li><li><p>酷壳：<a href="http://coolshell.cn/" target="_blank" rel="noopener">http://coolshell.cn/</a></p></li><li><p>CSDN博客频道：<a href="http://blog.csdn.net/" target="_blank" rel="noopener">http://blog.csdn.net/</a></p></li><li><p>优米网：<a href="http://www.umiwi.com/" target="_blank" rel="noopener">http://www.umiwi.com/</a></p></li><li><p>网易公开课：<a href="http://open.163.com/" target="_blank" rel="noopener">http://open.163.com/</a></p></li><li><p>InfoQ：<a href="http://www.infoq.com/cn/" target="_blank" rel="noopener">http://www.infoq.com/cn/</a></p></li></ul><h3 id="视野拓展："><a href="#视野拓展：" class="headerlink" title="视野拓展："></a>视野拓展：</h3><ul><li><p>腾讯大讲堂：<a href="http://djt.qq.com/" target="_blank" rel="noopener">http://djt.qq.com/</a></p></li><li><p>极客公园：<a href="http://www.geekpark.net/" target="_blank" rel="noopener">http://www.geekpark.net/</a></p></li><li><p>果壳科技：<a href="http://www.guokr.com/" target="_blank" rel="noopener">http://www.guokr.com/</a></p></li><li><p>知乎：<a href="http://www.zhihu.com/" target="_blank" rel="noopener">http://www.zhihu.com/</a></p></li><li><p>无觅阅读：<a href="http://www.wumii.com/" target="_blank" rel="noopener">http://www.wumii.com/</a></p></li><li><p>鲜果阅读：<a href="http://www.wumii.com/" target="_blank" rel="noopener">http://www.wumii.com/</a></p></li><li><p>杀价帮：<a href="http://www.shajia.cn/" target="_blank" rel="noopener">http://www.shajia.cn/</a></p></li><li><p>网易云阅读：<a href="http://yuedu.163.com/" target="_blank" rel="noopener">http://yuedu.163.com/</a></p></li><li><p>Zealer：<a href="http://www.zealer.com/" target="_blank" rel="noopener">http://www.zealer.com/</a></p></li></ul><h3 id="屏幕取色工具："><a href="#屏幕取色工具：" class="headerlink" title="屏幕取色工具："></a>屏幕取色工具：</h3><ul><li>ColorPix：<a href="http://www.colorschemer.com/colorpix_info.php" target="_blank" rel="noopener">http://www.colorschemer.com/colorpix_info.php</a></li></ul><h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><ul><li><p>F.lux(屏幕颜色自动调整工具)：<a href="https://justgetflux.com" target="_blank" rel="noopener">https://justgetflux.com</a></p></li><li><p>goagent(翻墙工具)：<a href="http://code.google.com/p/goagent/" target="_blank" rel="noopener">http://code.google.com/p/goagent/</a></p></li><li><p>Ditto(Windows 增强版剪贴板工具)：<a href="http://ditto-cp.sourceforge.net" target="_blank" rel="noopener">http://ditto-cp.sourceforge.net</a></p></li><li><p>FreeFileSync(Windows 文件同步工具)：<a href="http://sourceforge.net/projects/freefilesync/" target="_blank" rel="noopener">http://sourceforge.net/projects/freefilesync/</a></p></li><li><p>Altrun(快速启动软件)：<a href="http://altrun.googlecode.com" target="_blank" rel="noopener">http://altrun.googlecode.com</a></p></li><li><p>Auto Hot Key(快捷键管理工具)：<a href="http://www.autohotkey.com/" target="_blank" rel="noopener">http://www.autohotkey.com/</a></p></li><li><p>SourceCounter(代码行数统计工具)：<a href="https://code.google.com/p/boomworks/wiki/SourceCounterCN" target="_blank" rel="noopener">https://code.google.com/p/boomworks/wiki/SourceCounterCN</a></p></li><li><p>PicPick(截屏)：<a href="http://www.picpick.org/en/" target="_blank" rel="noopener">http://www.picpick.org/en/</a></p></li><li><p>tinypng(png图片压缩)：<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p></li><li><p>LICEcap(屏幕录制生成gif动态图工具)：<a href="http://www.cockos.com/licecap/" target="_blank" rel="noopener">http://www.cockos.com/licecap/</a></p></li><li><p>微博是个好图床(图床)：<a href="https://chrome.google.com/webstore/detail/%E5%9B%B4%E8%84%96%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9B%BE%E5%BA%8A/pngmcllbdfgmhdgnnpfaciaolgbjplhe?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/%E5%9B%B4%E8%84%96%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9B%BE%E5%BA%8A/pngmcllbdfgmhdgnnpfaciaolgbjplhe?utm_source=chrome-app-launcher-info-dialog</a></p></li><li><p>StrokeIt(鼠标手势工具)：<a href="http://www.tcbmi.com/strokeit/" target="_blank" rel="noopener">http://www.tcbmi.com/strokeit/</a></p></li><li><p>红杏(代理)：<a href="http://honx.in/i/Utpj7IKo12ffBmGS" target="_blank" rel="noopener">http://honx.in/i/Utpj7IKo12ffBmGS</a></p></li></ul><h3 id="源码查找："><a href="#源码查找：" class="headerlink" title="源码查找："></a>源码查找：</h3><ul><li><p>ppance：<a href="http://www.appance.com/category/android/" target="_blank" rel="noopener">http://www.appance.com/category/android/</a></p></li><li><p>Android Libraries and Resources：<a href="http://alamkanak.github.io/android-libraries-and-resources/" target="_blank" rel="noopener">http://alamkanak.github.io/android-libraries-and-resources/</a></p></li><li><p>The Android Arsenal：<a href="http://android-arsenal.com/" target="_blank" rel="noopener">http://android-arsenal.com/</a></p></li><li><p>Android Elements：<a href="https://github.com/cesards/AndroidElementals" target="_blank" rel="noopener">https://github.com/cesards/AndroidElementals</a></p></li><li><p>F-Droid：<a href="https://f-droid.org/" target="_blank" rel="noopener">https://f-droid.org/</a></p></li><li><p>Appbrain：<a href="http://www.appbrain.com/" target="_blank" rel="noopener">http://www.appbrain.com/</a></p></li><li><p>grepcode：<a href="http://grepcode.com/" target="_blank" rel="noopener">http://grepcode.com/</a></p></li><li><p>Java API Examples：<a href="http://programcreek.com/java-api-examples/" target="_blank" rel="noopener">http://programcreek.com/java-api-examples/</a></p></li><li><p>Android-Open-Project：<a href="https://github.com/android-cn/android-open-project" target="_blank" rel="noopener">https://github.com/android-cn/android-open-project</a></p></li><li><p>Tutorialspoint：<a href="http://www.tutorialspoint.com/" target="_blank" rel="noopener">http://www.tutorialspoint.com/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从源码层面解析Android消息机制</title>
      <link href="/2018/07/03/Handler%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/07/03/Handler%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>之前在看 <strong>Handler#dispatchMessage</strong>方法时，发现有几个判断条件，针对不同的条件</p><pre><code class="java">/** * Handle system messages here. */public void dispatchMessage(Message msg) {    if (msg.callback != null) {        handleCallback(msg);    } else {        if (mCallback != null) {            if (mCallback.handleMessage(msg)) {                return;            }        }        handleMessage(msg);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android消息机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Activity生命周期获取控件宽高的探究</title>
      <link href="/2018/07/02/%E5%9C%A8Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%8E%B7%E5%8F%96%E6%8E%A7%E4%BB%B6%E5%AE%BD%E9%AB%98%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/07/02/%E5%9C%A8Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%8E%B7%E5%8F%96%E6%8E%A7%E4%BB%B6%E5%AE%BD%E9%AB%98%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>在开发的时候经常需要获取控件的宽高进行处理，但是会发现在Activity启动的几个生命周期函数中获取的宽高都是0，这就让人摸不着头脑了。后来有一次面试的时候面试官也闻到了这个问题，自己也说不出个所以然。这几天学学习View绘制和Window相关的时候，发现了其中的奥妙，这里就来总结一下。</p><p>在之前的博客<a href="https://www.dengw.xyz/2018/06/25/%E4%BB%8EXML%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E5%88%B0%20VIew%20%E7%BB%98%E5%88%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">从XML布局文件到 View 绘制的全过程分析</a>中其实对于这个问题已经有一定的启发，我们这里再回顾一下。</p><p>在Activity的启动过程中，onCreate 方法涉及到 UI 的操作主要有3个步骤：</p><ol><li>创建 DecorView 的时候会先设置 System Layout 的一些属性，比如加载预设的主题风格，就解析对应的系统的layout，然后设置是否包含title等等。</li><li>然后把系统layout中的 android.R.id.content 所对应的 ViewGroup 赋给 mContentParent。</li><li>最后把开发者的layout Inflate到 mContentParent，完成整个Activity的view的载入和初始化。</li></ol><p>可以看到这个时候 View 绘制的三大流程都还没有开始，因此View还是可见的，因此获取不到 View 的宽高也是情理之中了。</p><p>那么在 onResume 方法中能够获取到 View 的宽高吗？我们再看一下 onResume 方法的流程。在这个方法中，主要步骤就是通过 WindowManager 的 addView 方法将 decorView 添加进 ViewRootImpl. 但是通过我们之前看源代码发现这是一个异步的过程，这样我们在 onResume 方法调用换取宽高方法的时候，组件并没有执行完绘制流程，因此也无法获取组件的宽和高。</p><p>好现在原因找到了，如果我们确实要在 Avtivity 的启动过程来获取宽高的话，有什么办法呢，这里参考《Android 开发艺术探索》这本书，给出一下几种解决方案。</p><ul><li>Activity\View#onWindowFocusChanged<pre><code class="java">/*** 重写Acitivty的onWindowFocusChanged方法*/ @Overridepublic void onWindowFocusChanged(boolean hasFocus) {  super.onWindowFocusChanged(hasFocus);  /**   * 当hasFocus为true的时候，说明Activity的Window对象已经获取焦点，进而Activity界面已经加载绘制完成   */  if (hasFocus) {      int width = button.getWidth();      int height = button.getHeight();      Log.d(&quot;mydebug&quot;, &quot;width &quot; + width);  }}</code></pre></li></ul><p>onWindowFocusChanged这个方法是指当前的 Activity 的 Windows (窗口)获取或者失去焦点时这个方法就会被调用，并且当回调这个方法时，Activity是完全可见的。所以当这个方法被调用的时候，就可以确保 View 已经绘制完成可见了，因此就可以获取控件的宽高参数。</p><ul><li><p>view.post(runnable) </p><pre><code class="java">@Overrideprotected void onResume() {  super.onResume();  button.post(new Runnable() {      @Override      public void run() {          int width = button.getMeasuredWidth();          Log.d(&quot;mydebug&quot;, &quot;width &quot; + width);      }  });}</code></pre><p>通过post可以将一个 runnable 投递到消息队列的尾部，绘制的绘制也是通过一个handler 发送一个 Runnable 到消息队列进行异步绘制，并且都是使用的 UI 线程的消息队列。这样当执行到获取宽高的runnable的时候，就可以确保之前的进行 View 绘制的 runnable 已经执行完毕了。</p></li><li><p>OnGlobalLayoutListener</p><pre><code class="java">button = findViewById(R.id.button);final ViewTreeObserver viewTreeObserver = this.getWindow().getDecorView().getViewTreeObserver();viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {  @Override  public void onGlobalLayout() {      int width = button.getMeasuredWidth();      Log.d(&quot;mydebug&quot;, &quot;width: &quot; + width);      // 移除GlobalLayoutListener监听          MainActivity.this.getWindow().getDecorView().getViewTreeObserver().removeOnGlobalLayoutListener(this);  }});</code></pre></li></ul><p>为组件添加OnGlobalLayoutListener事件监听,这里的onGlobalLayout方法会在Activity的组件执行完onLayout方法之后执行，这里的onLayout方法主要用于计算组件的宽高操作，这样当我们计算完组件的宽高之后再执行获取组件的宽高操作，自然能够获取到组件的宽度和高度。</p><ul><li>OnPreDrawListener<pre><code class="java">final ViewTreeObserver viewTreeObserver = this.getWindow().getDecorView().getViewTreeObserver();viewTreeObserver.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {  @Override  public boolean onPreDraw() {      int width = button.getMeasuredWidth();      Log.i(&quot;mydubug&quot;, &quot;width: &quot; + width);      // 移除OnPreDrawListener事件监听      MainActivity.this.getWindow().getDecorView().getViewTreeObserver().removeOnPreDrawListener(this);      return true;  }});</code></pre></li></ul><p>为组件添加OnPreDrawListener事件监听，需要说明的是这里的onPreDraw方法会在Activity的组件执行onDraw方法之前执行，熟悉我们Activity组件加载绘制流程的同学应该知道，这里的onDraw方法主要用于执行真正的绘制组件操作，而这时候我们已经计算出来了组件的位置，宽高等操作，这样之后再执行获取组件的宽高操作，自然能够获取到组件的宽度和高度。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android四种布局方式及部分控件属性理解</title>
      <link href="/2018/07/02/Android%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%83%A8%E5%88%86%E6%8E%A7%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/02/Android%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%83%A8%E5%88%86%E6%8E%A7%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="控件属性"><a href="#控件属性" class="headerlink" title="控件属性"></a>控件属性</h2><h3 id="android-gravity"><a href="#android-gravity" class="headerlink" title="android:gravity"></a>android:gravity</h3><p>android:gravity 是控件内部内容相对于控件来说的，用来设置控件内部应该显示在 view 的什么位置，默认值是左侧。也可以使用到父层布局中用来设置子布局或者子控件位置。<br>作用对象是父层概念</p><h3 id="android-layout-gravity"><a href="#android-layout-gravity" class="headerlink" title="android:layout_gravity"></a>android:layout_gravity</h3><p>是相对于包含改元素的父元素来说的，设置该元素在父元素的什么位置；<br>作用对象是子控件<br><em>特殊情况</em><br>当我们采用LinearLayout布局时，有以下特殊情况需要我们注意：<br>(1)当 android:orientation=”vertical”  时， android:layout_gravity只有水平方向的设置才起作用，垂直方向的设置不起作用。即：left，right，center_horizontal 是生效的。<br>(2)当 android:orientation=”horizontal” 时， android:layout_gravity只有垂直方向的设置才起作用，水平方向的设置不起作用。即：top，bottom，center_vertical 是生效的。</p><h3 id="android：layout-weight"><a href="#android：layout-weight" class="headerlink" title="android：layout_weight"></a>android：layout_weight</h3><p>对当前<strong>剩余空间</strong>按权重平分,注意剩余空间可以为负数<br><a href="https://www.cnblogs.com/net168/p/4227144.html" target="_blank" rel="noopener">https://www.cnblogs.com/net168/p/4227144.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从一个示例开始学自定义View</title>
      <link href="/2018/06/28/%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%BC%80%E5%A7%8B%E5%AD%A6%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
      <url>/2018/06/28/%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%BC%80%E5%A7%8B%E5%AD%A6%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
            <tag> 自定义View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View的详细绘制流程</title>
      <link href="/2018/06/28/View%E7%9A%84%E8%AF%A6%E7%BB%86%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/06/28/View%E7%9A%84%E8%AF%A6%E7%BB%86%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>就不再增加阅读成本了，已经有一篇讲的非常详细的博客：<a href="https://www.jianshu.com/p/5a71014e7b1b" target="_blank" rel="noopener">Android View的绘制流程</a>，然后可以再结合<code>Android 开发艺术探索</code>这本书，应该就可以很好地掌握这部分的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从XML布局文件到 View 绘制的全过程分析</title>
      <link href="/2018/06/25/%E4%BB%8EXML%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E5%88%B0%20VIew%20%E7%BB%98%E5%88%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/25/%E4%BB%8EXML%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E5%88%B0%20VIew%20%E7%BB%98%E5%88%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>这篇博客的篇幅可能有点长，最开始本来是想用几个部分分开讲解的，但是我觉得O老师说的很有道理，知识讲究一个体系，所以就想用一篇博客把 Android 中 View 相关的知识一起讲一下，对之前零碎的知识点能有一个整体的认识，从 Window 开始到 View 的绘制，希望通过这个流程，自己能够对这个在 Android 体系中重要性不亚于四大组件的 View 有一个更深刻的理解。</p><h2 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h2><h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><p>Surface 真的不是简单一两句话能够说清楚的，最开始本来是想把 Surface 一起学习了的，但是后来放弃了，它会涉及到 Android 中很底层的东西，比如 SurfaceFlinger的机制，真的挺复杂，也不是现在的我能够 get 得到的。但是为了能够更好地理解 Window 的概念，觉得还是要对 Surface 有一个基本的认识，下面这段话来自<a href="https://www.jianshu.com/p/7897d97d17cc" target="_blank" rel="noopener">Android易混概念辨析之Surface,Window,View,SurfaceView,Bitmap</a>，可以帮助我们更好地理解 Window 的概念。</p><p>一个 Surface 就是一个对象，该对象持有一群像素（pixels），这些像素是要被组合到一起显示到屏幕上的。你在手机屏幕上看到的每一个 Window（如对话框、全屏的activity、状态栏）都有唯一一个自己的 surface，window 将自己的内容（content）绘制到该 surface 中。SurfaceFlinger 根据各个 surface 在Z轴上的顺序（Z-order）将它们渲染到最终的显示屏上。</p><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>Window 即窗口，这个概念在 Android Framework 中的实现为 android.view.Window 这个抽象类，这个抽象类是对 Android 系统中的窗口的抽象。实际上，窗口是一个宏观的思想，它是屏幕上用于绘制各种 UI 元素及响应用户输入事件的一个矩形区域。结合上面介绍的 Surface 概念，窗口就是独占一个 Surface 实例的显示区域。见过一个很形象的比喻：我们可以把 Surface 看作是一块画布，应用可以通过 Canvas 或 OpenGL 在上面作画。画好之后，通过 SurfaceFlinger 将多块 Surface 按照特定的顺序（即Z-order）进行混合，而后输出到 FrameBuffer 中，这样用户界面就得以显示。</p><p>为了对 Window 能有一个更直观的概念，我们可以列举一些我们平时常见的 Window 实例，比如手机顶部的状态栏是一个Window, 全屏的<br>Activity, Toast 是一个窗口, Dialog 是一个窗口, 360卫士创建的悬浮球也是一个窗口。</p><p>下面给出创建一个 Window 的简单代码，这段代码参考了《Android 开发艺术探索》这本书，然后我们再从代码中来学习一些 Window 相关的知识。</p><pre><code class="java">mWn = (WindowManager)getSystemService(Context.WINDOW_SERVICE);mFloatButton = new Button(this);mFloatButton.setText(&quot;Floating&quot;);mFloatButton.setBackgroundColor(getResources().getColor(R.color.colorAccent));layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT);layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION;layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL        | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE        | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;layoutParams.gravity = Gravity.LEFT | Gravity.TOP;layoutParams.x = 200;layoutParams.y = 200;mWn.addView(mFloatButton, layoutParams);</code></pre><p><strong>Flags</strong> 参数表示Window的属性，控制Window的显示特性。</p><p><strong>Type</strong>  参数表示Window的类型，Window 有三种类型，分别是应用 Window、子 Window 和系统 Window。应用类 Window 对应一个 Acitivity，子 Window 不能单独存在，需要依附在特定的父 Window 中，比如常见的一些 Dialog 就是一个子 Window。系统 Window是需要声明权限才能创建的 Window，比如 Toast 和系统状态栏都是系统 Window。</p><p>Window 是分层的，每个 Window 都有对应的 z-order 属性，层级大的会覆盖在层级小的 Window 上面，比如360悬浮球位于 Activity所在 Window 的上层、状态栏也位于 Activity所在 Window 的上层。这一点个人理解是借助 Surface 的 Z-order 属性实现的，不过有待验证。</p><p>在三种 Window 中，应用 Window 层级范围是 1~99，子 Window 层级范围是 1000~1999，系统 Window 层级范围是 2000~2999，我们可以用一个表格来直观的表示：</p><table><thead><tr><th>Window 类型</th><th>层级</th></tr></thead><tbody><tr><td>应用 Window</td><td>1~99</td></tr><tr><td>子 Window</td><td>1000~1999</td></tr><tr><td>系统 Window</td><td>2000~2999</td></tr></tbody></table><h3 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h3><p>Window 是一个抽象类，具体实现就是 PhoneWindow, 目前为止 PhoneWindow 是 Window 类的唯一实现类。</p><h3 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h3><p>DecorView是 FrameLayout 的子类，它可以被认为是 Android 视图树的根节点视图。DecorView 作为顶级 View，一般情况下它内部包含一个竖直方向的 LinearLayout，上面的标题栏(titleBar)，下面是内容栏(FrameLayout)，具体情况和 Android 版本和设置的主题有关。其中内容栏则是下文会提到的 mContentParent，有固定的id: android.R.id.content，通常我们在 Activity 中通过 setContentView 所设置的布局文件就是被加载到内容栏里，成为其唯一子View，在代码中可以通过如下方法来得到对应的布局。</p><pre><code>ViewGroup content = (ViewGroup) findViewById(android.R.id.content);  // 内容栏ViewGroup rootView = (ViewGroup) content.getChildAt(0);        // 布局文件对应的 View</code></pre><h3 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h3><p>是 ViewRoot 的实现类，它是连接 WindowManagerService 和 DecorView 的纽带，View 绘制的三大流程：测量(measure)、布局(layout)、绘制(draw) 均是通过 ViewRoot 来完成的。<br>ViewRoot 从名字上看很容易让人觉得是什么 View 的根节点，然而实际上它并不属于 View树 的一份子，它既非 View 的子类，也非 View 的父类。但是，它实现了 ViewParent 接口，这让它可以作为 View 的名义上的父视图。ViewRoot 继承了 Handler 类，可以接收事件并分发，Android 的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的。</p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h3><p>上面我们说了 Window 是用来装 View 的，那么一个 Window 是如何创建出来的呢？</p><p>带着这个问题我们继续探究，我们看到的手机屏幕上呈现出来的布局，是我们在一个 XML 文件中定义的，然后在 Activity 的 onCreate 函数中通过 setContentView 函数进行加载，我们的探究就是从这儿开始的。</p><pre><code> @Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    ...}</code></pre><p>看一下 <strong>Activity#setContentView</strong> 的源码：</p><pre><code>public void setContentView(@LayoutRes int layoutResID) {    //调用getWindow方法，返回mWindow    getWindow().setContentView(layoutResID);      initWindowDecorActionBar();}</code></pre><p>通过追踪可以发现上面的 mWindow 是一个 Window 类型的对象，但是上面我们也提到了 Window 只是一个抽象类，因此它的 setContentView 也只是一个抽象方法，那么自然想到 Window 的子类了。查询资料发现， Window 有且仅有唯一一个实现类 — PhoneWindow.</p><p>这里需要我们先了解一下 Activity 的启动过程，由 ActivityThread 中的 performLaunchActivity() 来完成整个过程，这个过程会通过类加载器创建 Activity 的实例对象，并调用这个对象的 attach 方法为其关联运行过程中所依赖的一些列上下文环境变量，我们发现在 <strong>Activity#attach</strong> 方法中有如下实现：</p><pre><code>final void attach(Context context, ActivityThread aThread,Instrumentation instr, IBinder token, int ident,Application application, Intent intent, ActivityInfo info,CharSequence title, Activity parent, String id,NonConfigurationInstances lastNonConfigurationInstances,Configuration config, String referrer, IVoiceInteractor voiceInteractor){    ...    mWindow = new PhoneWindow(this);    mWindow.setCallback(this);    mWindow.setOnWindowDismissedCallback(this);    mWindow.getLayoutInflater().setPrivateFactory(this);    ...}</code></pre><p>在 Activity 的 attach 方法中会创建一个 Activity 所属的 Window 的 PhoneWindow 对象并为其设置回调函数。额外提一下由于 Activity 对象实现了 Window 的 Callback 接口，因此当 Window 接收到外界的状态改变时就会回调 Activity 的方法。Window 的 Callback 接口中的方法有很多，列一些比较眼熟的：</p><pre><code> public interface Callback {    public void onAttachedToWindow();    public boolean dispatchTouchEvent(MotionEvent event);    public View onCreatePanelView(int featureId);    public void onContentChanged();    public void onWindowFocusChanged(boolean hasFocus);    public void onDetachedFromWindow();}</code></pre><p>接着看 Window 的创建，Activity 将具体实现交给了 Window，而 Window 的具体实现是 PhoneWindow，所以只需要看 PhoneWindow 的相关逻辑即可，下面给出 PhoneWindow#setContentView 的实现代码：</p><pre><code>@Overridepublic void setContentView(int layoutResID) {    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window    // decor, when theme attributes and the like are crystalized. Do not check the feature    // before this happens.    if (mContentParent == null) {        installDecor();    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {        mContentParent.removeAllViews();    }    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                getContext());        transitionTo(newScene);    } else {        // 如果没有设置了FEATURE_CONTENT_TRANSITIONS，就会将布局文件填充至mContentParent        mLayoutInflater.inflate(layoutResID, mContentParent); // ①    }    // 通知Activity布局改变    final Callback cb = getCallback();    if (cb != null &amp;&amp; !isDestroyed()) {        cb.onContentChanged();    }}</code></pre><p>第一步是确定是否已经实例化 DecorView 和 mContentParent, 在具体的介绍之前，需要先清楚这里 mContentParent 成员是什么。</p><p>先看一下 <strong>mContentParent</strong> 的注解：</p><pre><code>// This is the view in which the window contents are placed. It is either// mDecor itself, or a child of mDecor where the contents go.private ViewGroup mContentParent;</code></pre><p>首先它的数据类型 ViewGroup，再结合<code>①</code>处代码可以得知，这个 mContentParent 是我们设置的布局(即main_activity.xml )的父布局。此外注释还提到了，这个 mContentParent 是 mDecor 本身或者是 mDecor 的一个子元素，mContentParent 是 mDecor 的子元素很好理解，但是为什么是 mDecor 本身呢？对于这一点，个人理解是当设置了 FEATURE_NO_ACTIONBAR，即设置了不显示标题栏的时候，此时 DecorView 内部的Linearlayout 就没有任何的意义，并且 DecorView 和 mContentParent 都采用的是 Framelayout 的布局类型，所以从布局的效果上来看可以认为 mContentParent 就是 mDecor 的本身。</p><p>到这里我们就把 Window 涉及到的所有 View 都介绍了一遍，下面给一张图形象地表示一下他们的关系：<br><img src="http://dengw.xyz/blog/180628/63FeffG9AL.png?imageslim%29" alt="enter image description here"></p><p>对于这个图，还真是花了挺多功夫的，刚开始看了网上挺多的博客，但是发现都比较零散，没有一个比较系统的，完整介绍这个 View Tree 的，而且里面有一些概念很容易混淆，所以对各个 View 之间的关系不是十分的明确。后来通过对比各方面资料以及根据源码自己理解，也算是确定了他们的关系，绘制了上面的图。</p><p>概念清楚了我们接着看在 PhoneWindow 中的 installDecor() 方法：</p><pre><code>private void installDecor() {    if (mDecor == null) {        //调用该方法创建new一个DecorView        mDecor = generateDecor();        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);        mDecor.setIsRootNamespace(true);        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) {            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);        }    }    if (mContentParent == null) {        mContentParent = generateLayout(mDecor);        ...        }     }}</code></pre><p>可以看到，通过 generateDecor 方法创建 DecorView实例.</p><pre><code>protected DecorView generateDecor() {    return new DecorView(getContext(), -1);}</code></pre><p>这个时候得到的 DecorView 还只是一个空白的 FrameLayout, 为了初始化 DecorView 的结构，PhoneWindow 还会通过 generateLayout 方法来加载布局到 DecorView 中，这个过程如下所示：</p><pre><code> protected ViewGroup generateLayout(DecorView decor) {    //将布局layout，添加至DecorView中    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);    //从布局中获取`ID_ANDROID_CONTENT`，并关联至contentParent    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);    ...    //配置完成，DecorView根据已有属性调整布局状态    mDecor.finishChanging();    return contentParent;}</code></pre><p>展示的代码部分将布局添加到 DecorView 中，并且将 contentParent 布局中 id 为 ID_ANDROID_CONTENT 的 FrameLayout 绑定。所以我们可以通过 findViewById(ID_ANDROID_CONTENT) 获取到 contentParent. 其中 ID_ANDROID_CONTENT 的定义如下，这个 id 所对应的 ViewGroup 就是 mContentParent ：</p><pre><code>public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;</code></pre><p>上述整个步骤可以用下面的图表示：</p><p><img src="http://dengw.xyz/blog/180627/4Ag21f0ll3.png?imageslim" alt=""></p><h3 id="Window-的添加"><a href="#Window-的添加" class="headerlink" title="Window 的添加"></a>Window 的添加</h3><p>经过上面的步骤，DecorView 已经被创建并初始化完毕，Activity 的布局文件也已经成功添加到了 DecorView 的 mContentParent 中，但是这个时候 DecorView 还没有被 WindowManager 正式添加到 Window 中，我们的 View 还是不可见的，因为我们仅仅是加载了布局，并没有对View进行任何的测量、布局、绘制工作。在 View 进行测量流程之前，还要进行一个步骤，那就是把 DecorView 添加至 window中。</p><p>下面我们就来讨论这个过程，先上一个图来表示整个过程：<br><img src="http://dengw.xyz/blog/180627/i9ciHJkedj.png?imageslim" alt=""></p><p>我们继续看 Activity 启动的方法 handleLaunchActivity() 中调用的 handleResumeActivity() 方法。</p><pre><code>final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) {     //...    ActivityClientRecord r = performResumeActivity(token, clearHide); // 这里会调用到onResume()方法    if (r != null) {        final Activity a = r.activity;        //...        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {            r.window = r.activity.getWindow(); // 获得window对象            View decor = r.window.getDecorView(); // 获得DecorView对象            decor.setVisibility(View.INVISIBLE);  // 不可见            ViewManager wm = a.getWindowManager(); // 获得windowManager对象            WindowManager.LayoutParams l = r.window.getAttributes();            a.mDecor = decor;            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;            l.softInputMode |= forwardBit;            if (a.mVisibleFromClient) {                a.mWindowAdded = true;                wm.addView(decor, l); // 调用addView方法            }            //...        }    }}</code></pre><p>在上面代码中，首先配置 ActivityClientRecord，之后将 DecorView 设置为 INVISIBLE，因为此时 View 并未绘制完成，当前的 DecorView 只是一个有结构的空壳。 然后通过 WindowManager 将 DecorView 正式的添加到窗口上 wm.addView(decor, l)，这一步非常重要，它包括了2个很重要的过程：Window 的添加过程和 View 的绘制流程。</p><h4 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h4><p>从上面的代码可以看到我们是使用 WindowManager 来添加一个新的 Window的，我们可以通过WindowManager.LayoutParams 参数来设置 Window 的一些属性。WindowManager 是一个接口，它继承自 ViewManager 接口，ViewManager 有三个常用的方法：</p><pre><code>public interface ViewManager{    public void addView(View view, ViewGroup.LayoutParams params);    public void updateViewLayout(View view, ViewGroup.LayoutParams params);    public void removeView(View view);}</code></pre><p>这三个方法其实就是 WindowManager 对外提供的主要功能，它可以创建一个 Window 并向其添加 View， 还可以更新 Window 中的 View, 另外如果想要删除一个 Window 就只要删除其中的 View 即可。</p><h4 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h4><p>上面我们已经知道添加一个 Window 是通过 WindowManager 的 addView 方法来实现的，WindowManager 也只是一个接口，它的实际实现类是 WindowManagerImpl 类。在 WindowManagerImpl 中 Window 的三大操作实现如下：</p><pre><code>@Overridepublic void addView(View view, ViewGroup.LayoutParams params){    mGlobal.addView(view, params, mDisplay, mParentWindow);}@Overridepublic void updateViewLayout(View view, ViewGroup.LayoutParams params){    mGlobal.updateViewLayout(view, params);}@Overridepublic void removeView(View view){    mGlobal.removeView(view, false);}</code></pre><p>可以看到，WindowManagerImpl 并没有直接实现 Window 的三大操作，而是交给了 WindowManagerGlobal 类来处理。通过观察我们可以发现这实际上是使用桥接模式来实现的。WindowManagerImpl 内部含有一个WindowManagerGlobal 的实例，然后把所有操作就可以全部委托给 该实例来实现。</p><h4 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h4><p>我们看一下 WindowManagerGlobal 中的 addView 的部分代码：</p><pre><code>public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {    ...    ViewRootImpl root;    View panelParentView = null;    synchronized (mLock) {        ...        // 创建 ViewRootImpl 并将 View 添加到集合中        root = new ViewRootImpl(view.getContext(), display);        view.setLayoutParams(wparams);        mViews.add(view);        mRoots.add(root);        mParams.add(wparams);    }    // do this last because it fires off messages to start doing things    try {        root.setView(view, wparams, panelParentView);    } catch (RuntimeException e) {        // BadTokenException or InvalidDisplayException, clean up.        synchronized (mLock) {            final int index = findViewLocked(view, false);            if (index &gt;= 0) {                removeViewLocked(index, true);            }        }        throw e;    }}</code></pre><p>在上面代码中有2个比较重要的点</p><ol><li>在WindowManagerGlobal中有如下几个重要的集合</li></ol><pre><code>//存储所有Window对应的Viewprivate final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();//存储所有Window对应的ViewRootImplprivate final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();//存储所有Window对应的布局参数private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();</code></pre><ol start="2"><li>调用 ViewRoot 的 setView 方法， 作用效果是 WindowManagerGlobal 将 View 的操作交给 ViewRootImpl来实现。</li></ol><p><strong>ViewRootImpl#setView</strong></p><pre><code>public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {    ...    requestLayout();    ...    try {        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,        getHostVisibility(), mDisplay.getDisplayId(),        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,        mAttachInfo.mOutsets, mInputChannel);    }    ...｝</code></pre><ul><li>View绘制的入口</li></ul><p>ViewRootImpl 调用 requestLayout() 来完成 View 的绘制操作</p><pre><code>public void requestLayout(){   if(!mHandingLayoutInLayoutRequest){       checkThread();       mLayoutRequested = true;       scheduleTraversals();   }}</code></pre><p>checkThread() 方法判断当前线程是否是主线程，如果是在子线程就会抛出异常。</p><pre><code>void checkThread() {    if (mThread != Thread.currentThread()) {        throw new CalledFromWrongThreadException(            &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);    }}</code></pre><p>接着看，判断完线程后，接着调用 scheduleTraversals()</p><pre><code>void scheduleTraversals() {    if (!mTraversalScheduled) {        ...        mChoreographer.postCallback(            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);        ...    }}</code></pre><p>scheduleTraversals中会通过 handler 去异步调用 mTraversalRunnable 接口</p><pre><code>final class TraversalRunnable implements Runnable {    @Override    public void run() {        doTraversal();    }}void doTraversal() {    ...    performTraversals();    ...}</code></pre><p>而真正调用绘制的是 performTraversals() 方法，这个方法的核心如下：</p><pre><code>private void performTraversals() {      ......      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    ...    performLayout(lp, desiredWindowWidth, desiredWindowHeight);    ......      performDraw();    }    ......  }</code></pre><p>然后就很熟悉了，接着开始 View 的测量、布局、绘制这三大流程。这儿就不具体详细分析这三大流程了，后面会单独写一篇博客来介绍。</p><ul><li>通过 WindowSession 最终来完成 Window 的添加过程。</li></ul><p>在下面的代码中，mWindowSession 的类型是 IWindowSession，查阅资料得知它是一个 Binder 对象，真正的实现类是 Session。</p><pre><code>res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(),mAttachInfo.mContentInsets, mInputChannel);</code></pre><p>在 Session 内部会通过 WindowManagerService 来实现 Window 的添加：</p><pre><code>public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams, attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel){   return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outInputChannel);}</code></pre><p>我们知道 WindowManagerService 运行在系统进程中。所以这里 IWindowSession 执行的 addtoDisplay 方法应该是 IPC 调用，接下来的Window 添加过程，具体 Window 在 WindowManagerService 内部是怎么添加的，就不对其进一步的分析，因为我们侧重的是整个添加 Window 的流程。</p><p>到现在我们就从 WindowManager 开始到具体 WindowManagerService 创建一个Window 的过程完成地过了一遍。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这是第一次写知识面这么广的博客，中间涉及到的过程非常的多，也暴露了自己存在的不足，首先是一个知识系完整的问题，写下来，感觉这些知识是一环扣一环的，是一个完整的链式调用，所以只要有哪一环没有理解透，那么对整个体系的理解就很困难，总之，收获满满。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
            <tag> Window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>获取屏幕、状态栏、标题栏、内容栏高度方法总结</title>
      <link href="/2018/06/20/%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E3%80%81%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E6%A0%87%E9%A2%98%E6%A0%8F%E3%80%81%E5%86%85%E5%AE%B9%E6%A0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/20/%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E3%80%81%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E6%A0%87%E9%A2%98%E6%A0%8F%E3%80%81%E5%86%85%E5%AE%B9%E6%A0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="屏幕区域划分"><a href="#屏幕区域划分" class="headerlink" title="屏幕区域划分"></a>屏幕区域划分</h3><p><img src="http://dengw.xyz/blog/180720/kF7Kef4Hm5.png?imageslim" alt="enter image description here"></p><p>在这张图中：</p><ul><li>紫色区域代表是整个屏幕</li><li>黄色区域是状态栏</li><li>红色区域是标题栏</li><li>绿色区域是内容栏，也是View绘制的区域</li><li>黑色区域是应用域</li></ul><p>从上面可以看出一些简单的数学关系，这些关系有时候可以根据我们的已知情况帮助我们求其他区域的高度。</p><blockquote><p>屏幕高度 = 应用域高度 + 状态栏高度<br>应用域高度 = 标题栏高度 + 内容栏高度</p></blockquote><h3 id="获取屏幕的宽度和高度"><a href="#获取屏幕的宽度和高度" class="headerlink" title="获取屏幕的宽度和高度"></a>获取屏幕的宽度和高度</h3><pre><code class="java">WindowManager manager = this.getWindowManager();DisplayMetrics outMetrics = new DisplayMetrics();manager.getDefaultDisplay().getMetrics(outMetrics);int width = outMetrics.widthPixels;int height = outMetrics.heightPixels;</code></pre><p>或者是：</p><pre><code class="java">DisplayMetrics dm = this.getResources().getDisplayMetrics();float density = dm.density;int width = dm.widthPixels;int height = dm.heightPixels;</code></pre><p><strong>注：这两种方法都可以在Activity的任何生命周期函数中使用。</strong></p><h3 id="获取状态栏的高度"><a href="#获取状态栏的高度" class="headerlink" title="获取状态栏的高度"></a>获取状态栏的高度</h3><pre><code class="java">private int getStatusBarHeight() {    int height = 0;    int resourceId = getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;);    if (resourceId &gt; 0) {        height = getResources().getDimensionPixelSize(resourceId);    }    return height;}</code></pre><p><strong>注：这个方法可以在Activity的任何生命周期函数中使用。</strong></p><p>或者是：</p><pre><code class="java">Rect outRect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect);int height = outRect.top;</code></pre><p>这种方法的思想正式使用了<code>屏幕高度 = 应用域高度 + 状态栏高度</code>这种关系，状态栏的高度正好等于应用区域上边界的横坐标。</p><p><strong>注：这种方法只有确保View已经绘制完成后才能使用。</strong></p><h3 id="获取应用区域的高度"><a href="#获取应用区域的高度" class="headerlink" title="获取应用区域的高度"></a>获取应用区域的高度</h3><p>根据上面的数学关系，这个时候可以使用代数减法求的应用区域的高度，即使用屏幕的高度减去状态栏的高度。</p><p>另外一种方法值先获取到应用区域，然后上下边界纵坐标的差值就是整个应用区域的高度：</p><pre><code class="java">Rect rect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);int height = rect.bottom - rect.top;</code></pre><p><strong>注：这种方法只有确保 View 已经绘制完成后才能使用。</strong></p><h3 id="获取内容栏的高度"><a href="#获取内容栏的高度" class="headerlink" title="获取内容栏的高度"></a>获取内容栏的高度</h3><pre><code class="java">ViewGroup content = (ViewGroup) findViewById(android.R.id.content);  // 内容栏ViewGroup rootView = (ViewGroup) content.getChildAt(0);    // 布局文件对应的 Viewint height = content.getHeight();或者int height = rootView.getHeight();</code></pre><p><strong>注：这种方法只有确保 View 已经绘制完成后才能使用。</strong></p><h3 id="获取标题栏的高度"><a href="#获取标题栏的高度" class="headerlink" title="获取标题栏的高度"></a>获取标题栏的高度</h3><p>根据上面我们的数学关系可以的得到一些标题栏高度的求法，过程中需要用得到的值上面我们已经介绍了求的方法，直接套用就好了，知识需要注意一下使用的条件。</p><blockquote><p>height = 应用区域高度 - 内容栏高度<br>height = 内容栏上边界的纵坐标 - 状态栏的高度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的23种设计模式</title>
      <link href="/2018/06/19/Java%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/19/Java%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这一次我选择站在巨人的肩膀上。</p><p>下面这些链接是我自己在学习设计模式中看到的一些非常好的文章，通俗易懂，同时结合代码理解，可以直接上手使用。</p><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p>单例模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html" target="_blank" rel="noopener">《JAVA与模式》之单例模式 — 博主：java_my_life</a></p><p>简单工厂模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html" target="_blank" rel="noopener">《JAVA与模式》之简单工厂模式 — 博主：java_my_life</a></p><p>工厂方法模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html" target="_blank" rel="noopener">《JAVA与模式》之工厂方法模式 — 博主：java_my_life</a></p><p>抽象工厂模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" target="_blank" rel="noopener">《JAVA与模式》之抽象工厂模式 — 博主：java_my_life</a></p><p>建造者模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" target="_blank" rel="noopener">《JAVA与模式》之建造者模式 — 博主：java_my_life</a></p><p>原型模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html" target="_blank" rel="noopener">《JAVA与模式》之原型模式 — 博主：java_my_life</a></p><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p>适配器模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" target="_blank" rel="noopener">《JAVA与模式》之适配器模式 — 博主：java_my_life</a></p><p>享元模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html" target="_blank" rel="noopener">《JAVA与模式》之享元模式 — 博主：java_my_life</a></p><p>代理模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html" target="_blank" rel="noopener">《JAVA与模式》之代理模式 — 博主：java_my_life</a></p><p>装饰模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener">《JAVA与模式》之装饰模式 — 博主：java_my_life</a></p><p>外观模式: <a href="https://blog.csdn.net/jason0539/article/details/22775311" target="_blank" rel="noopener">《JAVA与模式》之外观模式 — 博主：炸斯特</a></p><p>组合模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html" target="_blank" rel="noopener">《JAVA与模式》之组合模式 — 博主：java_my_life</a></p><p>桥接模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html" target="_blank" rel="noopener">《JAVA与模式》之桥接模式 — 博主：java_my_life</a></p><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p>观察者模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html" target="_blank" rel="noopener">《JAVA与模式》之观察者模式 — 博主：java_my_life</a></p><p>策略模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">《JAVA与模式》之策略模式 — 博主：java_my_life</a></p><p>命令模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html" target="_blank" rel="noopener">《JAVA与模式》之命令模式 — 博主：java_my_life</a></p><p>模板方法模式: <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html" target="_blank" rel="noopener">《JAVA与模式》之模板方法模式 — 博主：java_my_life</a></p><p>中介者(调停者模式)模式: <a href="https://blog.csdn.net/zhengzhb/article/details/7430098" target="_blank" rel="noopener">《JAVA与模式》之模板中介者模式 — 博主：愤怒的韭菜</a></p><p>责任链模式: <a href="https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html" target="_blank" rel="noopener">《JAVA与模式》之责任链模式 — 博主：java_my_life</a></p><p>解释器模式: </p><p>迭代模式: </p><p>备忘录模式: </p><p>状态模式: </p><p>访问者模式: </p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Android坐标系的理解</title>
      <link href="/2018/06/18/%E5%85%B3%E4%BA%8EAndroid%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/06/18/%E5%85%B3%E4%BA%8EAndroid%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>对于坐标系，或者说Android的坐标系，平时在项目中或者说看源码的时候肯定都有接触到，特别是当你自定义控件的时候，发现在<code>onXXX()</code>函数里面很多都是关于坐标系的逻辑处理，因此感觉很有必要系统地学习总结一下Android坐标系相关的知识，这样才能更好更快脱离低级程序员的行列嘛haha</p><h3 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h3><p>首先要明确的一点是Android的坐标系是一个<strong>三维坐标系</strong>，包括X轴、Y轴、Z轴，其中X轴向右，Y轴向下、Z轴向上。Z轴到现在为止我都还没有接触过，这方面的总结以后再补上。</p><h3 id="Android屏幕区域划分"><a href="#Android屏幕区域划分" class="headerlink" title="Android屏幕区域划分"></a>Android屏幕区域划分</h3><p>这里参考了CSDN博主<strong>工匠若水</strong>的一篇博客：<a href="https://blog.csdn.net/yanbober/article/details/50419117" target="_blank" rel="noopener">Android屏幕区域划分</a><br>对于一个Android屏幕，我们可见的部分包括以下几个范围：<br><img src="http://dengw.xyz/blog/180720/aJh6GDiD2j.jpg?imageslim" alt="mark"></p><p>我觉得这个张图真的总结的非常好，可以解决很多开发中的问题，我们可以很直观的看到Android对于屏幕的划分定义。下面我们就给出这些区域里常用区域的一些坐标或者度量方式。如下：</p><pre><code class="java">//获取整个屏幕区域宽度和高度，单位是pxDisplayMetrics metrics = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(metrics);int widthPixels = metrics.widthPixels;int heightPixels = metrics.heightPixels;</code></pre><pre><code>//获取应用程序App区域的宽度和高度，单位是pxRect rect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</code></pre><pre><code class="java">//获取状态栏的高度，单位是pxRect rect= new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);int statusBarHeight = rectangle.top;</code></pre><pre><code class="java">//获取布局区域的宽度和高度，单位是pxRect rect = new Rect();  getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect);  </code></pre><h3 id="View区域的坐标系"><a href="#View区域的坐标系" class="headerlink" title="View区域的坐标系"></a>View区域的坐标系</h3><p>平时我们进行开发的时候主要就是集中在这个区域，这儿就再借鉴一下<strong>工匠若水</strong>的这篇博客，这篇博客真的是做到了授人以渔！<br><img src="http://dengw.xyz/blog/180720/fJGLjIcjI7.jpg?imageslim" alt="enter image description here"></p><p>通过上图我们可以很直观的给出View一些坐标相关的方法解释，不过必须要明确的是上面这些方法必须要在layout之后才有效，另外呢，我们经常可以看见很多getXXX()之类的函数来获取坐标，上面这张图片也给出解释。</p><blockquote><p>getLeft(): 返回View自身左边到父布局左边的距离</p><p>getTop(): 返回View自身顶边到父布局顶边的距离</p><p>getRight(): 返回View自身右边到父布局左边的距离</p><p>getBottom(): 返回View自身底边到父布局顶边的距离</p><p>getX(): 返回值为getLeft()+getTranslationX()，当setTranslationX()时getLeft()不变，getX()变</p><p>getY(): 返回值为getTop()+getTranslationY()，当setTranslationY()时getTop()不变，getY()变</p></blockquote><p>关于Translation相关的坐标理解在下面的移动对Android坐标系的影响部分会进一步的讲解。</p><p>同时也可以看见上图中给出了手指触摸屏幕时MotionEvent提供的一些方法解释，其中关于getX()需要特别注意一下，参考上面给的图片，如下：</p><p>MotionEvent坐标方法:</p><blockquote><p>getX(): 当前触摸事件距离当前View左边的距离 </p><p>getY(): 当前触摸事件距离当前View顶边的距离 </p><p>getRawX(): 当前触摸事件距离整个屏幕左边的距离 </p><p>getRawY():  当前触摸事件距离整个屏幕顶边的距离 </p></blockquote><p>上面解释了自定义View时各种获取宽高的一些含义，下面我们再来看看关于View获取屏幕中位置的一些方法，不过这些方法需要在Activity的 onWindowFocusChanged ()方法之后才能使用。如下图：<br><img src="http://dengw.xyz/blog/180720/76J3kf413J.jpg?imageslim" alt="enter image description here"></p><p>下面我们就给出上面这幅图涉及的View的一些坐标方法的结果（结果采用使用方法返回的实际坐标，不依赖上面实际绝对坐标转换，上面绝对坐标只是为了说明例子中的位置而已），如下：</p><table><thead><tr><th style="text-align:left">View的方法</th><th style="text-align:left">上图View1结果</th><th style="text-align:left">上图View2结果</th><th style="text-align:left">结论描述</th></tr></thead><tbody><tr><td style="text-align:left">getLocalVisibleRect()</td><td style="text-align:left">(0, 0 - 410, 100)</td><td style="text-align:left">(0, 0 - 410, 470)</td><td style="text-align:left">获取View自身可见的坐标区域，坐标以自己的左上角为原点(0,0)，另一点为可见区域右下角相对自己(0,0)点的坐标，其实View2当前height为550，可见height为470</td></tr><tr><td style="text-align:left">getGlobalVisibleRect()</td><td style="text-align:left">(30, 100 - 440, 200)</td><td style="text-align:left">(30, 250 - 440, 720)</td><td style="text-align:left">获取View在屏幕绝对坐标系中的可视区域，坐标以屏幕左上角为原点(0,0)，另一个点为可见区域右下角相对屏幕原点(0,0)点的坐标</td></tr><tr><td style="text-align:left">getLocationOnScreen()</td><td style="text-align:left">(30, 100)</td><td style="text-align:left">(30, 250)</td><td style="text-align:left">坐标是相对整个屏幕而言，Y坐标为View左上角到屏幕顶部的距离</td></tr><tr><td style="text-align:left">getLocationInWindow()</td><td style="text-align:left">(30, 100)</td><td style="text-align:left">(30, 250)</td><td style="text-align:left">如果为普通Activity则Y坐标为View左上角到屏幕顶部（此时Window与屏幕一样大）；如果为对话框式的Activity则Y坐标为当前Dialog模式Activity的标题栏顶部到View左上角</td></tr></tbody></table><h3 id="移动对Android坐标系的影响"><a href="#移动对Android坐标系的影响" class="headerlink" title="移动对Android坐标系的影响"></a>移动对Android坐标系的影响</h3><p>其实这才是我真正想写的部分，进行控件的移动或者给空间添加的动画的时候肯定涉及到控件坐标的改变，并且使用不同的方法作用的结果还不一样，比如view动画和value动画。为了好好研究这个部分，自己尝试写了一个小demo来加深理解。使用了四个方法来改变view在整个视图中的位置，然后研究这些方法作用于view的哪一个参数。</p><p>整个app的布局如下：<br><img src="http://dengw.xyz/blog/180618/L6D5fjkdeG.png?imageslim" alt="enter image description here"></p><p>偏橘色的部分是一个TextView，里面的内容是一个字符串<code>我是内容</code>，它的父布局是一个<code>Linearlayout</code>。下面主要是我们的一些操作按钮，来作用与这个TextView修改它对应的参数，然后法僧位置改变。</p><p>在这个例子中主要是改变X轴方向的位置，Y轴的改变一个道理，使用的方法包括：</p><ul><li>使用View动画</li><li>使用ScollTo方法</li><li>使用属性动画</li><li>修改位置参数</li></ul><p>观察的变量有：</p><ul><li>getLeft() : 获取view左边界到夫层之间的距离</li><li>getX(): 获取view在父层这个相对坐标系里的X坐标</li><li>getTranslationX(): 获取view相对于父层的滑动距离</li><li>getScrollX(): 获取view里面的内容相对于view本身的滑动距离</li><li>getLocationOnScreenX：view相对于整个屏幕的X坐标</li></ul><p>好下面我们就开始，先输初始时的参数：</p><pre><code>Left: 150X:150.0TranslationX: 0.0LocationOnScreenX: 150LocationInWindowX: 150</code></pre><h4 id="使用view动画向右移动150px，过程如下，然后输出参数"><a href="#使用view动画向右移动150px，过程如下，然后输出参数" class="headerlink" title="使用view动画向右移动150px，过程如下，然后输出参数"></a>使用view动画向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/k1A1jcKj03.gif" alt=""></p><pre><code>getLeft: 150getX: 150.0getTranslationX: 0.0getscollX: 0getLocationOnScreenX: 150</code></pre><h4 id="使用ScollTo向右移动150px，过程如下，然后输出参数"><a href="#使用ScollTo向右移动150px，过程如下，然后输出参数" class="headerlink" title="使用ScollTo向右移动150px，过程如下，然后输出参数"></a>使用ScollTo向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/84K2A25EKl.gif" alt=""></p><pre><code>getLeft: 150getX: 150.0getTranslationX: 0.0getscollX: -150getLocationOnScreenX: 150</code></pre><h4 id="使用属性动画向右移动150px，过程如下，然后输出参数"><a href="#使用属性动画向右移动150px，过程如下，然后输出参数" class="headerlink" title="使用属性动画向右移动150px，过程如下，然后输出参数"></a>使用属性动画向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/26gKdbFfLl.gif" alt=""></p><pre><code>getLeft: 150getX: 300.0getTranslationX: 150.0getscollX: 0getLocationOnScreenX: 300</code></pre><h4 id="修改位置参数向右移动150px，过程如下，然后输出参数"><a href="#修改位置参数向右移动150px，过程如下，然后输出参数" class="headerlink" title="修改位置参数向右移动150px，过程如下，然后输出参数"></a>修改位置参数向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/L104ID2BC3.gif" alt=""></p><pre><code>getLeft: 300getX: 300.0getTranslationX: 0.0sgetscollX: 0getLocationOnScreenX: 300</code></pre><p>总结一下：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">视觉效果</th><th style="text-align:left">分析</th></tr></thead><tbody><tr><td style="text-align:left">view动画</td><td style="text-align:left">view整体向右移动</td><td style="text-align:left">参数没有任何改变，所以说只是视图的改变，当你的fillAfter属性设为false的时候，动画结束view还会自动回到之前的位置，这也是为什么在使用view动画后的位置上不能够响应点击事件的原因，可以理解为就是一个影子</td></tr><tr><td style="text-align:left">ScollTo</td><td style="text-align:left">view中的内容向右移动</td><td style="text-align:left">作用于ScollX，view本身的位置不会发生改变，改变的时view中内容为位置，ScollX参数表示view内容相对于view本身的偏移量，从名字看应该是只有scoll类的函数可以改变这个值</td></tr><tr><td style="text-align:left">属性动画</td><td style="text-align:left">view整体向右移动</td><td style="text-align:left">属性动画作用改变的是getTranslationX这个参数，view在父层的相对坐标以及在屏幕上的绝对坐标的改变，从而改变之后的view能够相应点击事件</td></tr><tr><td style="text-align:left">修改位置参数</td><td style="text-align:left">view整体向右移动</td><td style="text-align:left">这个就很好理解了，直接去修改位置参数，相当于把之前的view完全抹掉，然后在新的位置重新添加一个view</td></tr></tbody></table><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>我的理解就是这样了。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中dp与px之间的相互转化</title>
      <link href="/2018/06/15/Android%E4%B8%ADdp%E4%B8%8Epx%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/"/>
      <url>/2018/06/15/Android%E4%B8%ADdp%E4%B8%8Epx%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>写Android程序的时候在布局文件中控件的长度单位一般使用的<code>dp</code>，但是在Java类里面获取的或者处理的长度单位为<code>px</code>，所以经常需要两者之间的转化，下面就总结一下。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p><strong>屏幕大小</strong>：通常指的是屏幕对角线的长度，是一个物理尺寸，使用<code>英寸(in)</code>为单位来衡量，其中1in =2.54cm；</p></li><li><p><strong>分辨率</strong>：指手机屏幕的像素点个数，单位是<code>px</code>。比如说常见的<code>720*1280</code>，指的是宽有720个像素点，高有1280个像素点</p></li><li><p><strong>dpi</strong>：英文名：Dots Per Inch，即每英寸的像素点个数。例如：<code>320X480</code>分辨率的手机，宽2in，高3in，那么每英寸像素点个数(dpi)是:320/2=160. 使用正方形像素点横纵向计算结果一样，原因是大部分手机屏幕使用正方形的像素点，更严格上来说是计算对角线px / 对角线in</p></li><li><p><strong>屏幕密度(density)</strong>: 表示每英寸有多少个显示点，定义和dpi非常像，两者的关系是<code>density = dpi/160</code>, 这个是对dpi的一个规范，160dpi就是密度为1。也可以可以直接理解为dpi是屏幕密度的单位。</p></li><li><p><strong>dp(dip)</strong>：每英寸像素，是一种基于屏幕密度的抽象单位，android特有的。规定在屏幕密度为1也就是 dpi=160 的屏幕上，1dp = 1px, dp与px的一般性关系是<code>px = dp (dpi / 160)</code>，在 Android 开发中使用 dp 作为控件爱的长度单位是为了使得开发者设置的长度能够根据不同屏幕(分辨率/尺寸也就是dpi)获得不同的像素(px)数量，也就是 dp 会随着不同屏幕而改变控件长度的像素数量。</p></li></ul><p>另外呢我们在<code>drawable</code>文件夹下面经常看见好几个dpi相关的文件夹，分别对应的是：</p><blockquote><p>ldpi 文件夹下对应的密度为120dpi, 对应的分辨率为240<em>320；<br>mdpi 文件夹下对应的密度为160dpi, 对应的分辨率为320</em>480；<br>hdpi 文件夹下对应的密度为240dpi, 对应的分辨率为480<em>800；<br>xhdpi 文件夹下对应的密度为320dpi, 对应的分辨率为720</em>1280；<br>xxhdpi 文件夹下对应的密度为480dpi, 对应的分辨率为1080*1920；</p></blockquote><h3 id="转化关系："><a href="#转化关系：" class="headerlink" title="转化关系："></a>转化关系：</h3><p>给出一个两者的转化函数：</p><pre><code class="java">/** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */public static int dp2px(Context context, float dpValue) {    final float scale = context.getResources().getDisplayMetrics().density;    return (int) (dpValue * scale + 0.5f);}/** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */public static int px2dp(Context context, float pxValue) {    final float scale = context.getResources().getDisplayMetrics().density;    return (int) (pxValue / scale + 0.5f);}</code></pre><h3 id="关于-sp"><a href="#关于-sp" class="headerlink" title="关于 sp"></a>关于 sp</h3><p>sp 与缩放无关的抽象像素（Scale-independent Pixel）。sp 和 dp 很类似但唯一的区别是，sp 还会根据用户的字体大小偏好来缩放。Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时 1sp=1dp=0.00625 英寸，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> View布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美图实习周报-week1</title>
      <link href="/2018/06/14/%E7%BE%8E%E5%9B%BE%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A5-week1/"/>
      <url>/2018/06/14/%E7%BE%8E%E5%9B%BE%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A5-week1/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还是一贯的习惯，人学会总结才能收获更多。来到美图实习也有一个星期了，这一个星期下来，收获很多，也认识到现在的自己有多么的弱。没办法，只有一步一步地来。</p><p>I want to be stronger！</p><h2 id="这一周都做了什么"><a href="#这一周都做了什么" class="headerlink" title="这一周都做了什么"></a>这一周都做了什么</h2><p>初来咋到，这一周师兄给了一个小项目先热热身，虽然只是一个小项目，但是时间花的真挺多的。<br>师兄给的项目是模仿<code>Camera 360 lite</code>版本滤镜打开动画，做出来的效果如下：<br><img src="http://dengw.xyz/blog/180614/kilIdD9kCm.gif" alt="mark"></p><p>大概的过程就是：实现一个支持drop down的菜单栏，并且是一个具有两级菜单的菜单栏，最开始，菜单都是隐藏的，当点击下方的按钮，出发条件，显示出一级菜单，并且这是一个滑动的过程，弹性的移动，一级菜单可以从左向右滑动，当点击点击一级菜单中的某个item，显示出对应的二级菜单，这个过程也是动态的，这也是这个项目中的一个难点所在，下面详细讲解，二级菜单也可以左右滑动，点击某个item，然后to do something. 每个二级菜单的最左边有一个fixed 返回按钮，它不会随着二级菜单的滑动而移动，当前及这个返回按钮，会返回之前进入二级菜单时的一级菜单，这个过程也是动态，同时也是本此项目的一个难点所在，也下面详细讲解。最下方的按钮控制真个菜单的隐藏与显示，当菜单是显示的时候，不管显示的一级菜单还是二级菜单，点击都要隐藏整个菜单，同理，当整个菜单隐藏的时候，点击后显示。</p><h2 id="怎么实现的"><a href="#怎么实现的" class="headerlink" title="怎么实现的"></a>怎么实现的</h2><h3 id="在布局上"><a href="#在布局上" class="headerlink" title="在布局上"></a>在布局上</h3><p>首先两个菜单，根据效果，选择使用<code>RecylerView</code>实现，这里为什么没有选择<code>ListView</code>呢？因为有很多动画，使用<code>RecylerView</code>更好实现，功能更多，并且能用<code>ListView</code>实现的肯定<code>RecylerView</code>也能实现。在控件的层次上，最下层需要是二级菜单，中间一层是一级菜单，最上面一层是蓝色的部分，i还有就是fixed按钮需要在二级菜单的上层。具体布局文件可以看博客最后面给的项目链接。<br>还有一个比较有记录价值的就是简单的实现一个圆形按钮，首先在drawable中添加<code>circle_background_for_image_button.xml</code>文件，代码如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;    &lt;!-- 填充色 --&gt;    &lt;solid android:color=&quot;@color/white&quot; /&gt;    &lt;!-- 圆角 --&gt;    &lt;corners android:radius=&quot;90dp&quot; /&gt;&lt;/shape&gt;</code></pre><p>然后把该文件赋值给控件的<code>background</code>属性就Ok了。</p><pre><code class="xml">    &lt;ImageButton        android:id=&quot;@+id/fixedButton&quot;        android:layout_width=&quot;40dp&quot;        android:layout_height=&quot;40dp&quot;        android:layout_alignBottom=&quot;@id/menu2&quot;        android:layout_marginBottom=&quot;5dp&quot;        android:layout_marginLeft=&quot;10dp&quot;        android:background=&quot;@drawable/circle_background_for_image_button&quot;        android:src=&quot;@drawable/ic_keyboard_return_grey_500_24dp&quot; /&gt;</code></pre><h3 id="动画的实现"><a href="#动画的实现" class="headerlink" title="动画的实现"></a>动画的实现</h3><h4 id="一级菜单的弹性滑动"><a href="#一级菜单的弹性滑动" class="headerlink" title="一级菜单的弹性滑动"></a>一级菜单的弹性滑动</h4><p>对于一级菜单，首先是一个弹性滑动，这里需要一个动画效果，然后移动后还能够响应点击事件，所以这就需要使用是属性动画来实现，所以代码是：</p><pre><code class="java">    /*     * 使用动画平滑移动view指定的距离     * @param1 要移动的view     * @param2 标志位，值为true的时候下移，值为false的时候上移     */    private void moveViewSmooth(View view, boolean sign) {        float from = view.getTranslationY(), to;        if (sign) {            to = from + fromDpToPx();        } else {            to = from - fromDpToPx();        }        ObjectAnimator.ofFloat(view, &quot;translationY&quot;, from, to).setDuration(400).start();    }</code></pre><p>NOTE: 这里面的<code>fromDpToPx()</code>函数是一个将固定Dp（控件的高度）值转化为px值的函数。</p><pre><code class="java">    /*     * 将dp = 60的值转化为对应px值     */    private float fromDpToPx() {        final float scale = getApplicationContext().getResources().getDisplayMetrics().density;        return 60 * scale + 0.5f;    }</code></pre><h4 id="显示二级菜单"><a href="#显示二级菜单" class="headerlink" title="显示二级菜单"></a>显示二级菜单</h4><p>这个过程如效果图：点击屏幕上的某个一个菜单，从该位置处开始显示二级菜单，并且是从中间向两边逐个显示二级菜单的item，最后同时到达各自的边界。<br>对于这个动画，我们要明确一下几点，也是要解决的问题：</p><ol><li>动画的开始位置是你点击的一级菜单的横坐标</li><li>然后根据坐标确定二级菜单的哪些item是向左移动，哪些是向右移动的</li><li>动画分为左边和右边两部分，每个部分的动画不一样，所以不能给整个<code>RecylerView</code>添加动画，<code>LayoutAnimation</code>就不用考虑了.</li><li>每个item的动画是同时开始，同时结束的，动画的时间一样，但是每个item的移动距离不一样，所以需要为每个二级菜单的item设置一个动画，动画的属性都不完全一样</li></ol><p>下面就一个问题一个问题地解决。</p><ol><li>获取所点击item的横坐标。<br>对于这个问题，我们先要明白，在<code>Activity</code>或者<code>Fragment</code>中的是一个<code>RecylerView</code>的实例，是没有办法获取到其中一个Item的横坐标的，那有什么办法呢，方法就是在<code>Adapter</code>中获取，并且还只有在能获取<code>MotionEvent</code>的函数中才能获取坐标信息，因此在<code>Adapter</code>中的<code>onClick</code>函数中获取不到，因为该函数没有捕捉<code>MotionEvent</code>，那怎么办呢？我们发现<code>View</code>的<code>onTouch</code>函数会捕捉<code>MotionEvent</code>。因此一个可以解决问题的方案是：在<code>adapter</code>的<code>onBindViewHolder</code>函数中重写<code>holder.itemView</code>的<code>setOnTouchListener</code>函数，在该函数中记录最近一次点击的横坐标，然后在需要的时候通过<code>Adapter</code>返回给<code>Acticity</code>。</li></ol><pre><code class="java">    @Override    public void onBindViewHolder(final ViewHolder holder, int position) {        holder.name.setText(itemList.get(position).getName());        holder.itemView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                click.onItemClick(holder.getAdapterPosition());            }        });        // 获取所点击Item相对于屏幕的横坐标        holder.itemView.setOnTouchListener(new View.OnTouchListener() {            @Override            public boolean onTouch(View view, MotionEvent motionEvent) {                if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {                    rawX = motionEvent.getRawX();                }                return false;   //这里要返回false,返回true会使点击事件无效            }        });    }</code></pre><pre><code class="java">public float getRawX() {    return rawX;}</code></pre><p>这其中需要注意的是<code>onTouch</code>函数这里需要返回false，不然会和<code>onClick</code>函数冲突是<code>onClick</code>函数失效。</p><ol start="2"><li>确定二级菜单item的移动方向<br>首先对于二级菜单的移动，因为每个item的动画都不一样，因此只有在二级菜单的<code>adapter</code>中的<code>onBindViewHolder</code>函数中给每个item添加动画，因此在new一个二级菜单的    <code>Adapter</code> 的时候需要把刚得到的坐标作为参数传递给二级菜单的    <code>Adapter</code>内部。这里我们把位置参数转化为<code>position</code>传递进去，转化的代码逻辑很简单,<code>fromDpToPx()</code>上面已经提过。</li></ol><pre><code class="java">    /*     * 获取二级菜单动画开始的下标     * @param 所点击一级菜单item的横坐标     */    private int getStartPosition(float rawX) {        int n = 0;        while ((rawX - fromDpToPx()) &gt;= 0.0001) {            n++;            rawX -= fromDpToPx();        }        return n;    }</code></pre><p>在二级菜单的<code>adapter</code>中获取到这个<code>position</code>参数之后，<code>adapter</code>内部支持重写一个<code>getItemViewType</code>函数，这样就可以根据item的下标与动画开始下标的关系，决定item的移动方向。</p><pre><code class="java">    @Override    public int getItemViewType(int position) {        if (position &gt; startPosition) {            return RIGHT;        } else if(position &lt; startPosition){            return LEFT;        } else {            return MIDDLE;        }    }</code></pre><ol start="3"><li><p>因为每个item移动的距离都有差别，所以不能使用<code>xml</code>文件定义定义动画的方式为item添加动画，需要根据位置的关系使用java代码动态添加。这里使用了以下几类：<code>TranslateAnimation</code>、<code>ScaleAnimation</code>、<code>AlphaAnimation</code>。<br>这里需要补充的一点就是当你使用java代码要为同一个View添加多个动画的时候，可以使用动画集合<code>AnimationSet</code>。</p></li><li><p>为每个item添加特定的动画属性，平移动画的距离由动画开始位置与item所在位置的关系决定，结合上面讲的这里就比较好实现了。</p></li></ol><h4 id="关闭二级菜单"><a href="#关闭二级菜单" class="headerlink" title="关闭二级菜单"></a>关闭二级菜单</h4><p>关闭二级菜单类似与一个关门的效果，但是有一点不同的是之前在屏幕上哪个位置打开的二级菜单，那么关闭的时候二级菜单的结束位置也要在这个位置。其实动画的设置和开始动画挺像的，肯定位置关系添加动画属性，所以这不是难点。首先我们也明确这个动画是作用于每个item的，不是作用于个<code>RecylerView</code>，这和开始动画有点一样，但也有不一样的地方。开始动画我们是在<code>adapter</code>的<code>onBinderView</code>函数中添加的，而<code>onBinderBinder</code>函数是<code>adapter</code>的生命周期函数，是可以自发执行的，但是当我们关闭二级菜单的时候，<code>adapter</code>的生命周期中并没有这样一个类似的函数供我们来调用，这样我们就不能获取到每个item，相应的也不能把动画添加给每个item，这么办呢？这个问题困扰了我很久，始终找不到什么好的解决方法，昨天下午突然灵光一闪，我在adapter中添加一个<code>ViewHolder</code>类型的属性，然后在<code>onCreateViewHolder</code>中把create出来的<code>ViewHolder</code>实例添加进容器里面，这样我们就能在非生命周期函数中操作这些item，达到想要的效果。<br>这个部分值得留意的获取一个RecylerView当前可见Item的下标范围。</p><pre><code class="java">    /*     * 获取secondMenu可见item范围的下值     */    private int getFirstVisibleItemPosition(RecyclerView view) {        LinearLayoutManager layoutManager = (LinearLayoutManager) view.getLayoutManager();        return layoutManager.findFirstVisibleItemPosition();    }    /*     * 获取secondMenu可见item范围的上值     */    private int getLastVisibleItemPosition(RecyclerView view) {        LinearLayoutManager layoutManager = (LinearLayoutManager) view.getLayoutManager();        return layoutManager.findLastVisibleItemPosition();    }</code></pre><h4 id="其他一些实现"><a href="#其他一些实现" class="headerlink" title="其他一些实现"></a>其他一些实现</h4><blockquote><p>尝试了facebook开源框架<a href="http://facebook.github.io/rebound/" target="_blank" rel="noopener">rebound</a>的使用，可以添加一个弹簧效果。</p></blockquote><pre><code class="java">    /*     * item平移动画结束后的弹簧效果     * @param 要作用的view     * @param 标记位，用于判断左右方向（true: 向左， false: 向右）     */    private void addSpringEffect(final View viewToAnim, final boolean isLeft) {        Runnable startSpringAnimation = new Runnable() {            @Override            public void run() {                SpringConfig config = new SpringConfig(250, 25);                Spring spring = SpringSystem.create().createSpring();                spring.setSpringConfig(config);                spring.addListener(new SimpleSpringListener() {                    @Override                    public void onSpringUpdate(Spring spring) {                        float val;                        if(isLeft) {                            val = (float) (-MAX_SPRING_LENGTH - spring.getCurrentValue());                        } else {                            val = (float) (MAX_SPRING_LENGTH - spring.getCurrentValue());                        }                        viewToAnim.setTranslationX(val);                    }                });                if(isLeft) {                    spring.setEndValue(-MAX_SPRING_LENGTH);                } else {                    spring.setEndValue(MAX_SPRING_LENGTH);                }            }        };        viewToAnim.postDelayed(startSpringAnimation, ANIMATATE_DURATION - 20);    }</code></pre><blockquote><p>另外一个技巧就是实现延时动画</p></blockquote><p>这个项目中有这样一个需求，在平移动画结束的时候再添加一个弹性效果，可以使用<code>postDelayed()</code>+ <code>Runnable</code>的方法，代码看上面<code>rebound</code>的部分。</p><blockquote><p>还对之前自己对adapter的使用方法做了一个纠正</p></blockquote><p>之前传入<code>Adapter</code>中数据参数都是 <code>List&lt;Map&lt;String, Object&gt;&gt;</code>类型的，现在体会了这对面向对象特性的不友好，可以理解为 <code>List&lt;Map&lt;String, Object&gt;&gt;</code>是为view层的，而 <code>List&lt;Bean&gt;</code>model层的，维护view的代价肯定比维护model层的代价更大。</p><p><a href="https://github.com/duang0626/Camera" target="_blank" rel="noopener">项目github地址</a></p><h2 id="最后再说点什么"><a href="#最后再说点什么" class="headerlink" title="最后再说点什么"></a>最后再说点什么</h2><p>上面说的这些方法都是自己慢慢尝试出来的，并没有一上来就想到，也让我体会到经验的重要性。所以说，继续加油吧少年！</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RecylerView </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Java内存机制的理解</title>
      <link href="/2018/05/04/%E5%85%B3%E4%BA%8EJava%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/05/04/%E5%85%B3%E4%BA%8EJava%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在这次春招的过程中，很多次都会被问到与Java内存相关的问题，自己回答的不太好，现在春招结束了，就Java内存相关的知识好好总结一下。</p><h2 id="Java内存区域划分"><a href="#Java内存区域划分" class="headerlink" title="Java内存区域划分"></a>Java内存区域划分</h2><p>Java虚拟机在执行java程序的时候会把它所管理的内存区域划分为若干个不同的数据区域，在看相关的知识之前。我一直以为Java内存就是由堆内存(Heap)以及栈内存(Stack)，其实这种说法不是很准确的，实际的Java的内存划分要更复杂一些，这种说法比较印象流，下面就分别从相对广义以及相对狭义的角度来介绍与。</p><h3 id="广义的Java内存划分"><a href="#广义的Java内存划分" class="headerlink" title="广义的Java内存划分"></a>广义的Java内存划分</h3><p>在JVM内部，Java内存模型把内存分成了两部分：栈区和堆区，下图展示了Java内存模型在JVM中的逻辑视图：</p><p><img src="http://dengw.xyz/hexo-blog/180504/jC1lCHEHFh.png" alt=""></p><p><strong>栈区，也被称为线程栈</strong>，为每个线程所私有的，其生命周期和线程相同，包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。<br>不同线程的线程栈之间相互独立，一个线程只能访问自己的线程栈，里面存储的数据对其他线程不可见。<br>在线程栈存放了编译阶段可知的所有基本数据类型（byte, char, boolean, short, int, long, float, double)，对象引用（注意并不是对象本身，只是一个指向对象起始地址的引用指针）。</p><p><strong>堆区</strong>包含了Java应用创建的所有对象实例，不管对象是哪个线程创建的。对上面说到的对象引用，就是这个对象存储到堆中，在栈中获得一个该对象在堆中的地址，所以栈中的只是一个引用指针。</p><p>下图具体的展示了在栈区以及堆区存储的数据类型：</p><p><img src="http://dengw.xyz/hexo-blog/180504/DKbLabC17d.png" alt=""></p><p>另外一点就是Static类型的变量存储在堆区，其实事实上这是存储在Java虚拟机的方法区中，虽然java虚拟机把方法区描述为堆的一个逻辑部分，但是方法区还有一个别名叫做Non-Heap(非堆)，说明实际上两个区域应该是分开的，后面比较详细的介绍。</p><p>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。<br>下图展示了上面描述的过程: </p><p><img src="http://dengw.xyz/hexo-blog/180504/hiaBA10aL2.png" alt=""></p><h3 id="实际的Java内存划分"><a href="#实际的Java内存划分" class="headerlink" title="实际的Java内存划分"></a>实际的Java内存划分</h3><p>上面提到的堆—栈模型划分方式只是大多数程序员比较关注的、关系比较密切的一个方式，实际上的内存区域划分更为复杂。</p><p><img src="http://dengw.xyz/hexo-blog/180504/G1dKG5DJF6.jpg" alt=""></p><p><img src="http://dengw.xyz/hexo-blog/180504/kbakdmG2Gi.jpg" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，为当前线程所拥有， 可以看做是当前线程代码编译之后所产生的字节码的行号指示器，通过改变这个指示器的值来选取下一条需要执行的字节码的指令。程序计数器在计算机组成原理的课上有学，通过它来实现分支，跳转，循环，线程恢复等基础功能。<br>设想一下这个场景，在Java的多线程切换中由其他线程切换到当前线程中继续执行，程序计数器指示了恢复到正确继续执行的位置。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈也是线程私有的，生命周期和线程相同。<br>Java虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。</p><p><strong>栈帧(Stack Frame)</strong> 是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。</p><p>每一个栈帧代表了该线程的一个方法法，包括局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。栈帧的概念结构如下图所示：</p><p><img src="http://dengw.xyz/hexo-blog/180504/iDi64AJj85.png" alt="enter description here"></p><ul><li><p>局部变量表<br>局部变量表就和前面提到的堆—栈模型中的栈是同一个概念了，包括一些编译器可知的基本的数据类型和对一些对象的引用。</p></li><li><p>操作数栈<br>是一个后进先出栈，由若干个Entry组成，长度由编译期决定，单个Entry即可以存储一个Java虚拟机中定义的任意数据类型的值，包括long和double类型，但是存储long和double类型的Entry深度为2，其他类型的深度为1。在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。</p></li><li><p>动态连接<br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</p></li><li><p>方法返回地址<br>当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。<br>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。</p></li></ul><p>在这个区域中，Java虚拟机规范中规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈允许动态拓展（当前大部分的java虚拟机都可以动态扩展），如果扩展时无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>在理解这个内容之前需要知道什么是本地(native)方法。</p><p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用<code>extern C</code>告知C++编译器去调用一个C的函数。</p><p>然后说回本地方法栈，其实和Java虚拟机栈是非常相似，之间的区别只不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native 方法服务。</p><p>与虚拟机栈一样，这个区域也会抛出<code>StackOverflowError</code>异常和<code>OutOfMemoryError</code>异常。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆可以说是java虚拟机所管理的内存中最大的一块了，也是我们经常接触到的Java区域。<strong>此区域的唯一目的就是存放对象的实例</strong>。在java程序中不管对象是在哪个线程创建的，产生的对象实例都是存放在Java堆中的。</p><p>此外呢，Java堆还是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。从内存回收的角度来看，由于现代收集器基本上都采用分代收集算法，所以Java堆中还可以细分为新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。具体各个区域分配的细节在垃圾回收的部分回收更详细的介绍。</p><p>在实现时，Java堆区域既可以是固定大小的，也可以是可扩展的。当前主流的Java虚拟机都是按照可扩展来实现的，如果在堆中没有内存完成实例分配，并且堆也无法再扩展的话就会抛出<code>OutOfMemoryError</code>异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区和Java堆一样，是各个线程共享的内存区域，该区域用于存储被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据.</p><p>根据Java虚拟机规范的规定，在方法区无法满足内存分配需求时，会抛出<code>OutOfMemoryError</code>异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。在Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。不过相比class文件中的常量池，运行时常量池支持动态添加，在运行期间也可以将新的常量放入池中。</p><p>既然运行时常量池是方法区的一部分，自然也会受到方法去内存的限制，当常量池无法再申请到内存的时候会抛出<code>OutOfMemoryError</code>异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
            <tag> Java内存机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android实习面试知识整理</title>
      <link href="/2018/04/26/Android%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2018/04/26/Android%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>今晚把准备面试的过程中遇到的一些问题总结了一下。</p><h2 id="Android相关"><a href="#Android相关" class="headerlink" title="Android相关"></a>Android相关</h2><h3 id="广播（BroadcastReceiver）"><a href="#广播（BroadcastReceiver）" class="headerlink" title="广播（BroadcastReceiver）"></a>广播（BroadcastReceiver）</h3><p>静态广播：程序未启动的情况下也能启动，在注册文件里面注册，广播有一个属性action，根据action的name进行匹配。<br>静态广播即使Activity销毁了，仍然可以收到广播。</p><p>动态广播：程序启动之后才能接收到广播，使用Java代码注册 。<br>注册广播的时候提供广播的名字以及启动广播的条件，即intentFilter，通过给intentfilter设置action实现。<br>动态广播必须手动关闭，不然会有内存泄漏的风险。</p><p>处理广播消息的时候需要写一个继承BroadcastReceiver的类，重写里面的接收函数onReceive()处理逻辑。</p><p>有序广播：广播接收器是有先后顺序的，可以设置接收器的权重，并且先接收到的接收器可以截断广播的传递。</p><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>Android应用间的数据交互，本质上是进程进行数据交互&amp;共享，是一种跨进程通信的方式。</p><p><img src="http://dengw.xyz/hexo-blog/180426/AF40Lemhce.png" alt=""><br>ContentProvider的底层是采用 Android中的Binder机制。</p><p>借助ContentResolver实现，提供一系列进行数据CURD的操作，</p><p>通过URI参数访问特定的数据表，区分不同应用以及用一应用中的不同表。<br>获得表之后通过增删改查操作数据。</p><h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>使用键值对的方式存储数据。<br>数据存储过程：</p><blockquote><p>根据get方法获取一个SharedPreferences对象，这里需要文件名，路径是默认的<br>然后调用edit()获取一个editor对象<br>然后进行put操作，比如putString<br>调用apply（）提交数据</p></blockquote><p>数据读取：</p><blockquote><p>根据get方法获取一个SharedPreferences对象<br>然后通过getXXX的方法，比如：getInt(“key”, 默认值)的方式读取。</p></blockquote><h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>首先自己使用String的方式定义表的格式，</p><p>继承SQLiteOpenHelper帮助类，重写里面的创建表和升级表的方法。<br>实例化一个自定义类的实例，使用getWritableDatabase()或者getReadableDatabase()方法获取一个SQLiteDatabase对象，然后就可以通过增删改查的函数进行操作了</p><p>NOTE：ContentValues的使用</p><h3 id="LitePal"><a href="#LitePal" class="headerlink" title="LitePal"></a>LitePal</h3><p>是一个开源库，需要添加依赖，配置litepal.xml文件（包括数据库名以及版本号），最后在AndroidMainfest.xml文件中注册一个name = “org.litepal.LitePalApplication”的application。</p><p>对象关系映射：面向对象的语言和面向关系的数据库建立映射关系<br>需要自定义一个Java Bean继承自DataSupport，然后就可以使用面向对象的语言进行操作了。</p><h3 id="Asset目录与res目录的区别"><a href="#Asset目录与res目录的区别" class="headerlink" title="Asset目录与res目录的区别"></a>Asset目录与res目录的区别</h3><p>assets: 需要自己手动创建的，用于存放需要打包到应用程序的静态文件，以便部署到设备中。与res/raw不同点在于，ASSETS支持任意深度的子目录。很重要的一点是这些文件不会生成资源ID，必须使用/assets开始（不包含它）的相对路径名。<br>res: 自动创建的， 能够被系统编译的，用于存放应用程序的资源，比如布局文件，图标等，支持以根据资源ID的形式访问。</p><h3 id="activity退出怎么保存数据"><a href="#activity退出怎么保存数据" class="headerlink" title="activity退出怎么保存数据"></a>activity退出怎么保存数据</h3><p><a href="http://blog.csdn.net/huaheshangxo/article/details/50829752" target="_blank" rel="noopener">http://blog.csdn.net/huaheshangxo/article/details/50829752</a></p><h3 id="Android的数据存储形式"><a href="#Android的数据存储形式" class="headerlink" title="Android的数据存储形式"></a>Android的数据存储形式</h3><blockquote><p>使用SharedPreferences：存储数据: 轻量级的存储，保存一些常用的配置比如窗口状态，比如onSaveInstanceState保存一般使用SharedPreferences完成，主要存储一些基本数据类型以及String类型，数据保存在xml文件里。<br>文件存储数据：java提供的数据保存方法，文件可用来存放大量数据，如文本、图片、音频等。<br>SQLite数据库存储数据：使用sql语言的轻量级嵌入式数据库引擎，主要是对表格类型的数据进行操作，具体的包括增删改查。<br>使用ContentProvider存储数据 ：是应用程序之间共享数据的接口，以数据库形式存入手机内存，可以共享自己的数据给其他应用使用。<br>网络存储数据：比如什么云备份，就是把数据存储在云端，通过网络请求实现数据交互。</p></blockquote><h3 id="Activity正常和异常情况下的生命周期"><a href="#Activity正常和异常情况下的生命周期" class="headerlink" title="Activity正常和异常情况下的生命周期"></a>Activity正常和异常情况下的生命周期</h3><p>活动的几个状态，具体的边界</p><ul><li>Active (运行状态)：Activity 运行中的状态，可与用户之间进行交互，此时当前Activity位于栈顶。</li><li>Paused (暂停状态)：当Activity 暂时暗下来，退到背景画面的状态</li><li>Stopped (停止状态)：Activity完全被另一个Activity所覆盖，则其状态为Stopped。</li><li>Dead (销毁状态)：Activity 尚未被启动、已经被手动终止，或已经被系统回收的状态。</li><li><p>主要是异常情况，起作用的是onSaveInstanceState()函数，调用的实际，活动被非应用行为退出，如：</p></li><li><p>当用户按下HOME键时</p></li><li>长按HOME键，选择运行其他的程序时</li><li>按下电源按键（关闭屏幕显示）时</li><li>从activity A中启动一个新的activity时</li><li>屏幕方向切换时，例如从竖屏切换到横屏时，</li><li>资源内存不足杀死低优先级的活动<br>应用行为主要包括：主动调用finish()方法，或者主动按Back键，让Activity结束，这个时候就不会调用onSaveInstanceState()函数。</li></ul><p>数据恢复：</p><ul><li>onCreate：恢复了Paracelable对象下的Fragment</li><li>onRestoryInstanceState：恢复数据HierarchyState（View树的状态）</li></ul><p>注：要保存View的状态，View必须要有id，作为key<br>方法：针对某一个特定的View，进行保存，每个View都有onSaveInstanceState和onRestoreInstanceState方法<br>相关，Acticity的configChanges属性，View的保存，委托的思想，活动的三种优先级</p><h3 id="Acticity的优先级"><a href="#Acticity的优先级" class="headerlink" title="Acticity的优先级"></a>Acticity的优先级</h3><ul><li>前台活动</li><li>可见但非前台活动</li><li>后台活动</li></ul><h3 id="activity四种启动模式区别和应用场景。"><a href="#activity四种启动模式区别和应用场景。" class="headerlink" title="activity四种启动模式区别和应用场景。"></a>activity四种启动模式区别和应用场景。</h3><p>在特性的任务栈中启动一个Activity，通过设置TaskAffinity参数实现，主要是结合singleTask使用<br>应用场景： </p><blockquote><p>singleTop适合接收通知启动的内容显示页面。适用于接受到消息后显示的界面，例如QQ接受到消息后弹出Activity，如果一次来10条消息，总不能一次弹10个Activity。</p></blockquote><blockquote><p>singleTask适合作为程序入口点。在进入程序的第一个界面点击返回按钮，正常的逻辑是退出程序。满足这种情况。</p></blockquote><blockquote><p>singleInstance适合需要与程序分离开的页面。比如说，使用微信调起自己的客户端某个页面，不做任何处理的情况下，按下回退或者当前Activity.finish()，页面不会停留在自己的客户端而是返回到微信的客户端页面。但是如果这个页面的启动模式设置为singleTask，当按下返回键或者Activity。finish（）例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。</p></blockquote><p>相关：任务栈，onNewIntent方法的调用</p><h3 id="Android怎样退出终止App"><a href="#Android怎样退出终止App" class="headerlink" title="Android怎样退出终止App"></a>Android怎样退出终止App</h3><p>使用单例模式创建一个Activity管理对象ActivityManager，该对象中有一个Activity容器，可以使用LinkedList实现（一个容器代表一个app实例）专门负责存储新开启的每一个Activity。</p><pre><code class="java">private static ActivityManager instance;    //单例模式中获取唯一的app实例    public static ActivityManager getInstance() {        if(null == instance) {            instance = new ActivityManager();        }        return instance;    }</code></pre><p>使用：</p><blockquote><p>在每一个Activity中的onCreate方法里添加该Activity到AppUtils对象实例容器中<br>ActivityManager.getInstance().addActivity(this);</p></blockquote><blockquote><p>在需要结束所有Activity的时候调用exit方法<br>ActivityManager.getInstance().exit();</p></blockquote><h3 id="Fragement的生命周期"><a href="#Fragement的生命周期" class="headerlink" title="Fragement的生命周期"></a>Fragement的生命周期</h3><p>getFragementById()：在活动中获取碎片的方法<br>getActivity()：在碎片中获取活动的方法<br>几个重要的函数：</p><blockquote><p>onAttach()当碎片和活动建立关联的时候调用。</p></blockquote><blockquote><p>onCreateView()为碎片建立视图的时候调用, 加载布局和findViewById的操作通常在此函数内完成。</p></blockquote><blockquote><p>onActivityCreated() 确保碎片与碎片相关联的活动已经创建完时调用, 在该方法内可以进行与Activity交互的UI操作。</p></blockquote><blockquote><p>onDestroyView() 当与碎片关联的视图被移除的时候调用, 销毁与Fragment有关的视图，但未与Activity解除绑定，依然可以通过onCreateView方法重新创建视图</p></blockquote><blockquote><p>onDetach() 当碎片和活动解除关联的时候调用</p></blockquote><p>一旦activity进入running状态，你就可以自由地添加和删除fragment了，fragment的生命周期才能独立的运转，其它时候是依赖于activity的生命周期变化的。</p><p><img src="http://dengw.xyz/hexo-blog/180426/cA1kBDeEH1.png" alt=""></p><h3 id="service生命周期，两种启动方式的区别"><a href="#service生命周期，两种启动方式的区别" class="headerlink" title="service生命周期，两种启动方式的区别"></a>service生命周期，两种启动方式的区别</h3><blockquote><p>startService 方法启动，该Service在后台运行。如果一个Service被startService 方法多次启动，onCreate方法只会调用一次，onStartCommand将会被调用多次，并且系统只会创建Service的一个实例，因此只需要一次stopService。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。</p></blockquote><blockquote><p>bindService 方法绑定启动，不管调用 bindService 调用几次，onCreate方法都只会调用一次，同时onStartCommand方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。一定要显示使用unbindService()解除引用。</p></blockquote><p><strong>NOTE</strong>: 如果一个Service又被启动又被绑定，则该Service将会一直在后台运行。并且不管如何调用，onCreate始终只会调用一次，对应startService调用多少次，Service的onStart便会调用多少次。调用unbindService将不会停止Service，而必须调用 stopService 或 Service的 stopSelf 来停止服务。<br><img src="http://dengw.xyz/hexo-blog/180426/e93db3aFH2.png" alt=""></p><h3 id="app如何保证后台服务不被杀死"><a href="#app如何保证后台服务不被杀死" class="headerlink" title="app如何保证后台服务不被杀死"></a>app如何保证后台服务不被杀死</h3><ul><li><p>建立两个service互相监听，当一个service被kill掉的时候马上启动另一个</p></li><li><p>在onDestory里自监听，service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service</p></li><li><p>提升进程优先级（有6个优先级）</p></li></ul><h3 id="HandlerThread的实现原理"><a href="#HandlerThread的实现原理" class="headerlink" title="HandlerThread的实现原理"></a>HandlerThread的实现原理</h3><p>HandlerThread继承自Thread，内部保存一个Looper对象。<br>这是一个系统帮我们包装好的Thread，这个线程的run方法已经调用了Looper.prepare和Looper.loop（即已经绑定了一个Looper对象，并且可以开始轮询消息），创建该对象之后可以通过获得对象获取到一个Looper对象，然后可以当前Looper的引用返回以方便调用，将Looper对象传递给Handler（通过Looper可以实例化一个Handler），完成Handler和Looper以及MessageQueue的绑定，最终handleMessage方法会在HandlerThread线程中被调用。最后再其他的线程中调用Handler的sendMessage或者post(Runable)方法发送消息，handler中的callback.handleMessage方法会在HandlerThread中运行。即，将消息发送到了特定的线程（此处是HandlerThread）处理。</p><p>继承自Thread，是一种可以使用handler的Thread，实现很简单，就是在run方法中通过Looper.prepare（）方法来创建一个消息队列。普通的Thread主要用来在run方法中执行一个耗时任务，handlerThread则是通过handler的消息方式来通知handlerThread执行一个具体的任务，主要的使用场景就是IntentService。</p><p>使用方法：一般是把HandlerThread线程的Looper，在需要的地方使用new Handler(Looper)创建一个WorkerHandler处理业务逻辑。</p><h3 id="IntentService比Service好在哪"><a href="#IntentService比Service好在哪" class="headerlink" title="IntentService比Service好在哪"></a>IntentService比Service好在哪</h3><p>IntentService继承自Service，运行时优先级更高，内部使用了HandlerThread作为处理消息的线程。内部有一个私有内部类ServiceHandler继承自Handler，并且会创建一个ServiceHandler对象。 </p><p>使用startService()方法启动IntentService时，不会重新创建一个服务，会调用ServiceHandler对象发送包含该Intent的Message对象，该对象通过HandlerThread处理后交给ServiceHandler重写的handleMessage方法进行处理，处理的方式是调用IntentService的onHandleIntent（Intent）方法，所以使用的方式就是创建一个继承自IntentService类的子类，并重写onHandleIntent方法，在该方法中处理startService时传递的Intent。Intent中包含有要交给Service处理的信息。</p><p>Service缺点：不是专门的一个新的线程，因此不能够在里面执行耗时操作。<br>IntentService： IntentService封装了HandlerThread和Handler，内部创建一个HandlerThread开辟新的线程。</p><p>重写继承的handler</p><pre><code class="java">private final class ServiceHandler extends Handler {    public ServiceHandler(Looper looper) {        super(looper);    }    @Override    public void handleMessage(Message msg) {        onHandleIntent((Intent)msg.obj);        stopSelf(msg.arg1);    }}</code></pre><pre><code class="java">@Overridepublic void onCreate() {    // TODO: It would be nice to have an option to hold a partial wakelock    // during processing, and to have a static startService(Context, Intent)    // method that would launch the service &amp; hand off a wakelock.    super.onCreate();    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);    thread.start();    mServiceLooper = thread.getLooper();    mServiceHandler = new ServiceHandler(mServiceLooper);}</code></pre><p>是通过Handler、looper、message的方式实现了一个多线程的操作，同时耗时操作也可以被这个线程管理和执行<br>（1）IntentService会创建单独的worker线程来处理所有的intent请求。<br>（2）IntentService会创建单独的worker线程来处理onHandleIntent（）方法实现的代码。<br>     继承类重写IntentService的onHandleIntent（）方法，处理具体的业务逻辑<br>（3）当所有的请求处理完之后，IntentService会自动停止。<br>（4）为Service的OnBind（）方法提供了默认的实现，返回null。<br>（5）为service的onStartCommand（）方法提供了默认的实现，该实现会将请求intent添加到队列中。<br>所以对IntentService的使用就是：继承IntentService，重写onHandleIntent()方法即可。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，并且在多线程环境下每个线程里的变量独立于其他线程内的变量。</p><p>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p><p>实现：<br>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是每个线程的ThreadLocal实例本身，value是真正需要存储的Object。</p><p>用法：<br>initialValue函数：用来设置ThreadLocal的初始值<br>get函数：用来获取与当前线程关联的ThreadLocal的值<br>set函数：用来设置当前线程的ThreadLocal的值<br>remove函数：用来将当前线程的ThreadLocal绑定的值删除</p><h3 id="handler的内在原理"><a href="#handler的内在原理" class="headerlink" title="handler的内在原理"></a>handler的内在原理</h3><p>消息队列为空会怎样？<br>消息队列为空时，消息队列的方法next就会一直阻塞，这样造成looper的loop方法也会被阻塞，直到Looper检测到消息队列中有新的消息时</p><h3 id="Looper原理"><a href="#Looper原理" class="headerlink" title="Looper原理"></a>Looper原理</h3><p>Looper主要是用来传递消息的，在消息机制里面扮演者一种消息循环的角色，会不停的从消息队列中查看是否有新消息，有消息的话就取出来才交给handler处理，没有的话就一直阻塞<br>Looper是存在于线程中的，一个线程中有Looper才能工作，<br>Prepare(): 创建Looper，在构造函数里面会声明一个消息队列，用于存放新收到的消息<br>Loop(): 启动消息循环<br>主要是loop函数起作用， 死循环，跳出循环的条件（消息队列的next方法）</p><h3 id="Android进程与线程的区别"><a href="#Android进程与线程的区别" class="headerlink" title="Android进程与线程的区别"></a>Android进程与线程的区别</h3><p>操作系统上来说：</p><blockquote><p>进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元.</p></blockquote><blockquote><p>同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。</p></blockquote><blockquote><p>进程有自己独立的地址空间，线程共享所属进程的地址空间。</p></blockquote><blockquote><p>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源</p></blockquote><p>在安卓上体现：</p><blockquote><p>一个进程看成一个独立的程序，默认情况下一个app运行在一个进程内。</p></blockquote><blockquote><p>同样的，一个进程可以有多个线程，线程共享所属进程的地址空间，但是每个线程又有自己的栈空间。</p></blockquote><p>注：进程的资源包括各种表格、内存空间、磁盘空间、I／O设备等。</p><h3 id="IPC（进程间通信）的实现方法有哪些"><a href="#IPC（进程间通信）的实现方法有哪些" class="headerlink" title="IPC（进程间通信）的实现方法有哪些"></a>IPC（进程间通信）的实现方法有哪些</h3><p><img src="http://dengw.xyz/hexo-blog/180426/A81G5DlI2b.png" alt=""></p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>一般来说，内存泄漏都是因为泄漏对象的引用被传递到该对象的范围之外，或者说内存泄漏是因为持有对象的长期引用，导致对象无法被 GC 回收。<br>开发过程中有没有实际遇到内存泄露情况，怎么解决的。</p><blockquote><p>单例造成的内存泄漏，单例是静态的，生命周期和应用的生命周期一样长，如果说单例获取的context是一个activity的context，那么当前activity销毁的时候还被引用，资源不能及时被回收，解决方法，使传入的context参数为application的context, context.getApplicationContext();</p></blockquote><blockquote><p>匿名内部内部类或者非静态内部类创建了一个静态的实例，他们都会持有外部类的引用，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。</p></blockquote><blockquote><p>Handler造成的内存泄漏，非静态匿名内部类的实例，持有外部类Activity的引用，消息队列是在一个Looper线程中不断轮询处理消息，当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有handler实例的引用，handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，解决方法，将内部类声明为静态的，对Handler持有的对象使用弱引用，这样在回收时可以回收Handler持有的对象，避免了Activity，或者在onDestroy中中断子线程的运行。</p></blockquote><blockquote><p>资源未关闭注销造成的内存泄漏，EventBus、BroadcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p></blockquote><blockquote><p>线程导致内存泄漏。我们经常会执行一些长期运行的任务，避免在这些任务中持有 Activity 对象的引用，如果持有了引用的话，我们应该在对象生命周期结束的时候，释放引用。<br>解决方法：</p></blockquote><p><strong>一句话归纳：</strong>（生命周期比Activity长的类不要去强引用Activity）</p><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><p>原理：系统会给每一个app的堆内存分配一个固定值heapSize，app运行一段时间后堆内存超过了系统规定的最大值heapSize。<br>主要是图片Bitmap的操作上，图片太大了，以及内存泄漏造成的</p><h3 id="什么是ANR，如何避免"><a href="#什么是ANR，如何避免" class="headerlink" title="什么是ANR，如何避免"></a>什么是ANR，如何避免</h3><p>Application Not Responding，在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作在5秒内应用程序未做出响应，或者BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，即是ANR</p><h3 id="什么情况会导致Force-Close-如何避免-能否捕获导致其的异常"><a href="#什么情况会导致Force-Close-如何避免-能否捕获导致其的异常" class="headerlink" title="什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?"></a>什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?</h3><p>导致出现Force Close的原因有很多，常见的有比如空指针啦，类没有找到啦，资源没找到，就连Android API使用的顺序错误也可能导致（比如setContentView()之前进行了findViewById()操作）；<br>编写程序时逻辑连贯、思维缜密；<br>能捕获异常，在logcat中能看到异常信息。</p><h3 id="NDK是什么"><a href="#NDK是什么" class="headerlink" title="NDK是什么"></a>NDK是什么</h3><p>NDK是用来给安卓手机开发软件用的，但是和SDK不同的是它用的是C语言，而SDK用的是Java语言。<br>NDK开发的软件在安卓的环境里是直接运行的，一般只能在特定的CPU指令集的机器上运行，而且C语言可以直接和硬件对话，因此一般用它开给手机开发驱动或底层应用；而SDK开发出的软件在安卓上靠Dalvik虚拟机来运行，所以如果没有特殊的需要或署专门针对某个硬件去开发，那就一般用SDK。<br>NDK是一系列工具的集合，帮助开发者迅速地开发C/C++动态库，并能自动将so和java应用打成apk包；NDK集成了交叉编译器，并提供了相应的mk文件和隔离CPU、平台等差异，开发人员只需简单的修改mk文件就可以创建出so</p><h3 id="如何将SQLite数据库与apk文件一起发布"><a href="#如何将SQLite数据库与apk文件一起发布" class="headerlink" title="如何将SQLite数据库与apk文件一起发布"></a>如何将SQLite数据库与apk文件一起发布</h3><p>可以将XX.db文件复制到Eclipse Android工程中的res\raw目录中，如图1所示。所有在res\raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。<br>使用openDatabase方法来打开数据库文件，如果该文件不存在，系统会自动创建/sdcard/dictionary目录，并将res\raw目录中的 XX.db文件复制到/sdcard/dictionary目录中。</p><h3 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h3><h3 id="View的绘制机制"><a href="#View的绘制机制" class="headerlink" title="View的绘制机制"></a>View的绘制机制</h3><h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><blockquote><p>使用convertView保存加载好的布局，当使用getView()方法时，可以将缓存好的布局重用，避免从新加载。便于复用View</p></blockquote><blockquote><p>使用ViewHolder保存控件实例，当convertView为null的时候，就是用LayoutInflater加载布局，创建一个ViewHolder并将所有控件存放在里面，然后View.settag()将ViewHolder保存在View里面，当convertView不为null的时候，通过view.getTag（）把ViewHolder重新提取出来，这一样就避免多次加载控件的实例，便于复用控件实例</p></blockquote><blockquote><p>ListView加载图片时, 如果需要显示从网络上下载的图片的话，我们不要在ListView滑动的时候加载图片，那样会使ListView变得卡顿，所以我们需要再监听器里面监听ListView的状态，如果滑动的时候，停止加载图片，如果没有滑动，则开始加载图片。</p></blockquote><h3 id="RecyclerView和ListView"><a href="#RecyclerView和ListView" class="headerlink" title="RecyclerView和ListView"></a>RecyclerView和ListView</h3><p>ViewHolder: ListView种需要自己来定义，可以实现可以不实现，而在RecyclerView中必须要自己实现RecyclerView.ViewHolder<br>LayoutManager：在布局效果上，RecyclerView支持线性布局、网格布局、瀑布流布局三种效果，同时还能够控制横向还是纵向滚动，从效果上recyclerview的使用场景更多。而ListView在Android API中只支持<br>ItemAnimator： 提供在删除或添加item时产生动画效果，<br>各自缓存原理，ListView是两级缓存，recyclerview是四级缓存。</p><h3 id="如何优雅的展示Bitmap大图"><a href="#如何优雅的展示Bitmap大图" class="headerlink" title="如何优雅的展示Bitmap大图"></a>如何优雅的展示Bitmap大图</h3><p>主要目的：避免程序占用了过高的内存就容易出现OOM<br>压缩：使用BitmapFactory提供的解析方法，BitmapFactory.Options参数，计算压缩因子inSampleSize<br>使用图片缓存：LruCache和LruDiskCache</p><h3 id="Bitmap的四种属性"><a href="#Bitmap的四种属性" class="headerlink" title="Bitmap的四种属性"></a>Bitmap的四种属性</h3><p>每种属性队形的大小。</p><h3 id="多进程和多线程的实现，进程和线程区别"><a href="#多进程和多线程的实现，进程和线程区别" class="headerlink" title="多进程和多线程的实现，进程和线程区别"></a>多进程和多线程的实现，进程和线程区别</h3><p>1、子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。<br>2、进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。<br>3、进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。<br>4、线程上下文切换比进程上下文切换要快得多。<br>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。<br>（3）处理机分给线程，即真正在处理机上运行的是线程。<br>（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>Java8中的新功能<br>Interface函数接口的<br>使用Lambda表达式必须满足只有一个待实现方法</p><p><strong>和匿名内部类的不同</strong><br>lambda表达式是某些匿名表达式的简写<br>【相同点】</p><ol><li>都可以直接访问”effectively final”的局部变量，以及外部类的成员变量（包括实例变量和类变量）</li><li>都可以直接调用从接口中继承的默认方法。<br>【区别】</li><li>匿名内部类可以为任意接口创建实例——不管有多少个抽象方法，只要匿名内部类实现了所有方法即可。<br>但是Lambda表达式只能为函数式接口创建实例，只有一个待实现方法。</li><li>匿名内部类可以为抽象类甚至普通类创创建实例，<br>但lambda表达式只能为函数式接口创建实例。</li><li>匿名内部类实现的抽象方法体允许调用接口中的默认方法，<br>但Lambda表达式的代码块不允许调用接口中的默认方法。</li></ol><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>单例、工厂、适配器、责任链、观察者<br>设计模式六大原则：</p><blockquote><p>开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></blockquote><blockquote><p>里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。<br>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。<br>LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></blockquote><blockquote><p>   依赖倒转原则（Dependence Inversion Principle）<br>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p></blockquote><blockquote><p>   接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p></blockquote><blockquote><p>   迪米特法则（最少知道原则）（Demeter Principle）<br>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></blockquote><blockquote><p>   合成复用原则（Composite Reuse Principle）<br>原则是尽量使用合成/聚合的方式，而不是使用继承。</p></blockquote><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>发布/订阅事件总线，<br>基本使用：解耦性高，开销小，<br>三要素：<br>Event：任意类型的对象<br>Subscriber：在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING）<br>Publisher：能在任意线程任意位置发送事件，直接调用EventBus的post(Event)方法<br>线程模型ThreadMode：</p><ul><li>POSTING（默认）</li><li>MAIN</li><li>BACKGROUND</li><li>ASYNC</li></ul><p>使用方法：</p><pre><code class="java">   @Subscribe(threadMode = ThreadMode.MAIN)    public void onMoonEvent(MessageEvent messageEvent){        tv_message.setText(messageEvent.getMessage());    }</code></pre><p>使用步骤：<br>（1）    添加依赖<br>（2）    在自定义一个类<br>（3）    要接收消息的页面注册<br>（4）    发送消息<br>（5）    接受消息的页面实现订阅函数（有四种类型的函数）<br>（6）    解除注册</p><p>支持粘性事件：发送事件之后才订阅该事件，依然能够接收该事件</p><p>EventBus2.0的版本中，</p><blockquote><p>onEvent：事件在哪个线程发布出来的，onEvent就会在这个线程中运行，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</p></blockquote><blockquote><p>onEventMainThread：不论事件是在哪个线程中发布出来的，接收事件就会在UI线程中运行，所以可以在里面更新UI，不能执行耗时操作</p></blockquote><blockquote><p>onEventBackground: 如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。</p></blockquote><blockquote><p>onEventAsync：无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync</p></blockquote><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>是一个abstract类，底层是对Handler与线程池的封装，使用线程池的主要原因是避免不必要的创建及销毁线程的开销。</p><pre><code class="java">public abstract class AsyncTask&lt;Params, Progress, Result&gt;</code></pre><ul><li>Params：doInBackground方法的参数类型；</li><li>Progress：AsyncTask所执行的后台任务的进度类型；</li><li>Result：后台任务的返回结果类型。</li></ul><p>提供的方法：除了doInBackground方法由AsyncTask内部线程池执行外，其余方法均在主线程中执行。</p><blockquote><p>onPreExecute() //此方法会在后台任务执行前被调用，用于进行一些准备工作 </p></blockquote><blockquote><p>doInBackground(Params… params) //此方法中定义要执行的后台任务，在这个方法中可以调用publishProgress来更新任务进度（publishProgress内部会调用onProgressUpdate方法） </p></blockquote><blockquote><p>onProgressUpdate(Progress… values) //由publishProgress内部调用，表示任务进度更新 </p></blockquote><blockquote><p>onPostExecute(Result result) //后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果</p></blockquote><blockquote><pre><code> onCancelled() //此方法会在后台任务被取消时被调用</code></pre></blockquote><p><strong>存在的不足：</strong></p><ul><li>AsyncTask对象必须在主线程中创建 </li><li>AsyncTask对象的execute方法必须在主线程中调用 </li><li>一个AsyncTask对象只能调用一次execute方法</li></ul><p><strong>注意事项</strong>：</p><ul><li><p>AsyncTask实例必须在UI Thread中创建</p></li><li><p>execute方法必须在UI Thread中调</p></li><li><p>onPreExecute()、onPostExecute(),、doInBackground() 和 onProgressUpdate()这四个方法都是回调方法，Android会自动调用，我们不应自己调用。</p></li><li><p>对于一个AsyncTack的实例，只能执行一次execute方法，在该实例上第二次执行execute方法时就会抛出异常</p></li></ul><p><strong>OkHttp</strong><br>特点：</p><ul><li>支持http2，对一台机器的所有请求共享同一个socket </li><li>内置连接池，支持连接复用，减少延迟 </li><li>支持透明的gzip压缩响应体 </li><li>通过缓存避免重复的请求 </li><li>请求失败时自动重试主机的其他ip，自动重定向 </li><li>好用的API</li></ul><p>定义一个OkHttpClient， 定义一个Request,将url添加到Request,</p><pre><code class="java">mHttpClient = new OkHttpClient();Request request = new Request.Builder().url(url).build();response = mHttpClient.newCall(request).execute();</code></pre><p>执行函数：同步请求execute或者异步请求enqueue（new Callback（））</p><h3 id="Retrofit原理："><a href="#Retrofit原理：" class="headerlink" title="Retrofit原理："></a>Retrofit原理：</h3><p>使用 Retrofit 的步骤共有7个：<br>步骤1：添加Retrofit库的依赖<br>步骤2：创建 接收服务器返回数据 的类<br>步骤3：创建 用于描述网络请求 的接口<br>步骤4：创建 Retrofit 实例<br>步骤5：创建 网络请求接口实例 并 配置网络请求参数<br>步骤6：发送网络请求（异步 / 同步）</p><h3 id="RxJava原理"><a href="#RxJava原理" class="headerlink" title="RxJava原理"></a>RxJava原理</h3><p>优缺点, map，flatmap的原理,可不可以多次subscribeOn，ObserveOn，会有什么后果。</p><p>基于观察者模式实现的异步调用，简洁，链式调用，处理复杂的逻辑的时候，消除或者减少嵌套使用的次数，代码更加容易理解</p><blockquote><p>flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象，<br>flatMap()和map() 不同的是， flatMap()中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。</p></blockquote><p><strong>flatMap() 的原理：</strong></p><ol><li>使用传入的事件对象创建一个 Observable 对象；</li><li>并不发送这个 Observable, 而是将它激活，于是它开始发送事件；</li><li>每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。<br>这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。<br>ObserveOn（）可以使用多次，一个observeOn() 指定的是 一个特性Observable 所对应的 Subscriber所在的线程，即Observable的直接下级Subscriber， 但是当我们使用lift（）函数的时候，过程中会出现对个Observable，然后对应多个observer,因此这个使用就会使用到多个observeOn()，然后在代码上体现在observeOn() 指定的是紧跟着它之后的操作所在的线程：</li></ol><pre><code class="java">Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定    .subscribeOn(Schedulers.io())    .observeOn(Schedulers.newThread())    .map(mapOperator) // 新线程，由 observeOn() 指定    .observeOn(Schedulers.io())    .map(mapOperator2) // IO 线程，由 observeOn() 指定    .observeOn(AndroidSchedulers.mainThread)     .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定</code></pre><p>subscribeOn()是不可以使用多次的，因为起作用的只有一个原始被订阅源所在的那个subscribeOn()，所以使用多次也没什么意义。</p><p>Observable (可观察者，即被观察者)、 Observer (观察者)/subscriber (订阅者)、subscriber (订阅)事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p><p>Observer/ subscriber的创建方法，注意带上参数类型，解除订阅的方法</p><p>创建 Observable，三种方法，Observable 的OnSubscribe 对象：会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 中定义好的 call() 方法会自动调用，执行一些具体的逻辑</p><p>重点是Create函数的写法：参数，参数类型等</p><pre><code class="java">Observable.create(new OnSubscribe&lt;Drawable&gt;() {    @Override    public void call(Subscriber&lt;? super Drawable&gt; subscriber) {        Drawable drawable = getTheme().getDrawable(drawableRes));        subscriber.onNext(drawable);        subscriber.onCompleted();    }})</code></pre><p>订阅函数：observable.subscribe(subscriber);</p><p>内部核心代码：</p><pre><code class="java">public Subscription subscribe(Subscriber subscriber) {    subscriber.onStart();    onSubscribe.call(subscriber);    //事件发送的逻辑开始运行    return subscriber; }</code></pre><p>subscribe() 还支持不完整定义的回调</p><pre><code class="java">Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() {   //注意Action1的含义    // onNext()    @Override    public void call(String s) {        Log.d(tag, s);    }};// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()observable.subscribe(onNextAction);</code></pre><blockquote><p>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p></blockquote><blockquote><p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p></blockquote><blockquote><p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p></blockquote><blockquote><p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p></blockquote><blockquote><p>另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p></blockquote><p><strong>map()</strong> ：用于对象的转换，转换参数类型<br>注意Func1的含义与用法：一个参数</p><pre><code class="java">Observable.just(&quot;images/logo.png&quot;) // 输入类型 String    .map(new Func1&lt;String, Bitmap&gt;() {        @Override        public Bitmap call(String filePath) { // 参数类型 String            return getBitmapFromPath(filePath); // 返回类型 Bitmap        }    })    .subscribe(new Action1&lt;Bitmap&gt;() {        @Override        public void call(Bitmap bitmap) { // 参数类型 Bitmap            showBitmap(bitmap);        }});</code></pre><p><strong>flatMap()</strong>：</p><pre><code class="java">Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() {    @Override    public void onNext(Course course) {        Log.d(tag, course.getName());    }    ...};Observable.from(students)    .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() {        @Override        public Observable&lt;Course&gt; call(Student student) {            return Observable.from(student.getCourses());        }    })    .subscribe(subscriber);</code></pre><h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><h3 id="解析xml文件的两种方法：Pull和SAX"><a href="#解析xml文件的两种方法：Pull和SAX" class="headerlink" title="解析xml文件的两种方法：Pull和SAX"></a>解析xml文件的两种方法：Pull和SAX</h3><p>Pull解析方式：<br>基于事件的模式，需要自己获取产生的事件然后做相应的操作。<br>特点：PULL解析器小巧轻便，解析速度快，简单易用，非常适合在Android移动设备中使用，Android系统内部在解析各种XML时也是用PULL解析器。<br>五种事件类型：</p><ul><li><p>START_DOCUMENT：文档开始，解析器还未读取到任何输入的时候</p></li><li><p>START_TAG：解析到开始标签</p></li><li>TEXT：解析到文本节点</li><li>END_TAG：解析到结束标签</li><li>END_DOCUMENT：文档结束</li></ul><p><strong>XmlPullParser常用方法</strong><br>// 获取指定索引属性的属性值，索引从0开始</p><blockquote><p>public abstract String getAttributeValue (int index);</p></blockquote><p>// 返回当前事件类型</p><blockquote><p>public abstract int getEventType ();</p></blockquote><p>// 返回当前事件类型的内容字符串形式</p><blockquote><p>public abstract String getText ();</p></blockquote><p>// 获取下一个解析事件类型</p><blockquote><p>public abstract int next ();</p></blockquote><p>// 当前是开始标签，如果下一个元素为文本，则返回该文本字符串，<br>// 如果下一个元素是结束标签，则返回空字符串，其它情况将抛出异常</p><blockquote><p>public abstract String nextText ();</p></blockquote><p>// 设置即将被解析的输入流</p><blockquote><p>public abstract void setInput (InputStream inputStream, String inputEncoding);</p></blockquote><p><strong>SAX解析方式</strong><br>也是事件驱动的模式<br>特点：边扫描边解析，自顶向下依次解析，由于边扫描边解析，所以它解析XML具有速度快，占用内存少的优点。<br>方法：<br>重写一个继承DefaultHandler的类,然后重写一下方法。</p><blockquote><p>startDocument()：文档解析开始时调用，该方法只会调用一次</p></blockquote><blockquote><p>startElement(String uri, String localName, String qName, Attributes attributes):标签（节点）解析开始时调用</p><ul><li>uri：xml文档的命名空间</li><li>localName：标签的名字</li><li>qName：带命名空间的标签的名字</li><li>attributes：标签的属性集</li><li>characters(char[] ch, int start, int length)：解析标签的内容的时候调用</li><li>ch：当前读取到的TextNode(文本节点)的字节数组</li><li>start：字节开始的位置，为0则读取全部</li><li>length：当前TextNode的长度</li><li>endElement(String uri, String localName, String qName)：标签（节点）解析结束后调用</li><li>endDocument()：文档解析结束后调用，该方法只会调用一次</li></ul></blockquote><p>最后在需要解析的地方调用：</p><pre><code class="java">String responseData = response.body().string();parseXMLWithSAX(responseData);</code></pre><p>解析Json数据的两种可行方式：JSONObject和GSON</p><p><strong>JSONObject的方式：</strong><br>结合JSONObject这个对象，结合JSONArray，可以将简单的Json字符串， 嵌套的json字符串，Bean对象，json数组转化为JSONObject<br>从JSONObject对象中获取值的方法：obj.get(属性名)；<br>Obj.put(“level”, “A”);</p><p><strong>GSON解析：</strong><br>通过Java Bean的方式：</p><pre><code class="java">List&lt;App&gt; applist = gson.fromJson(jsonData. New TypeToken&lt;List&lt;App&gt;&gt;) (){}.getType());</code></pre><p>其中，jsonData为reponse.Body();App为自定义的java Bean;</p><h3 id="Json有什么优劣势"><a href="#Json有什么优劣势" class="headerlink" title="Json有什么优劣势"></a>Json有什么优劣势</h3><p>优点：</p><ul><li>Json的分隔符简化了数据访问</li><li>数据格式简单，方便读写，传输效率高</li><li>支持语言很多</li></ul><p>缺点：</p><h3 id="自定义View过程"><a href="#自定义View过程" class="headerlink" title="自定义View过程"></a>自定义View过程</h3><p>onMeasure()、onLayout()、onDraw()</p><h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p><h3 id="Java面向对象的三个特征与含义"><a href="#Java面向对象的三个特征与含义" class="headerlink" title="Java面向对象的三个特征与含义"></a>Java面向对象的三个特征与含义</h3><p>封装：封装是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布给其它对象。<br>继承：继承是子对象可以继承父对象的属性和行为<br>多态：</p><h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><p>含义：我的理解是就像名字一样，表现出多个形态。父类的引用变量指向子类对象，当调用父类中存在的方法时，实际上会调用子类重写之后的方法几个相关概念：<br>重载（overload）<br>在子类中重写父类中的某个方法，这两个方法函数名相同，但是参数不同，可以是参数的类型或者参数的个数不同<br>覆盖（override）<br>在子类中重写父类中的某个函数，这两个函数函数名和参数都完全相同。<br>多态，三个条件</p><ol><li>要有继承关系</li><li>子类要重写父类的方法：这里的重写指的是覆盖（override），</li><li>父类数据的引用指向子类对象，例：Animal am = new Cat();</li></ol><h3 id="Interface与abstract类的区别"><a href="#Interface与abstract类的区别" class="headerlink" title="Interface与abstract类的区别"></a>Interface与abstract类的区别</h3><p>1). 抽象类可以有构造方法，接口中不能有构造方法。<br>2). 抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3). 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。<br>4). 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行）,但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br>5). 抽象类中可以包含静态方法，接口中不能包含静态方法<br>6). 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。<br>7). 一个类可以实现多个接口，但只能继承一个抽象类。</p><h3 id="反射的作用与原理"><a href="#反射的作用与原理" class="headerlink" title="反射的作用与原理"></a>反射的作用与原理</h3><h3 id="泛型相关"><a href="#泛型相关" class="headerlink" title="泛型相关"></a>泛型相关</h3><h3 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h3><p>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br>Collection是个java.util下的接口，它是各种集合结构的父接口。</p><h3 id="equals方法是怎么来的"><a href="#equals方法是怎么来的" class="headerlink" title="equals方法是怎么来的"></a>equals方法是怎么来的</h3><p>equals 方法是子类从超类Object中继承的,所有继承Object类的方法都有，equals是用来进行比较的，可以在具体的类中自定义</p><h3 id="hashcode和equals有什么关系"><a href="#hashcode和equals有什么关系" class="headerlink" title="hashcode和equals有什么关系"></a>hashcode和equals有什么关系</h3><p>hashCode()方法和equal()方法的作用一样，都是用来对比两个对象是否相等一致<br>有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题，比如因为表示位数被截断了）</p><ol><li>equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</li><li>hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。<br>每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</li></ol><h3 id="Object有公用方法："><a href="#Object有公用方法：" class="headerlink" title="Object有公用方法："></a>Object有公用方法：</h3><ul><li>clone方法:实现对象的浅赋值</li><li>getClass：返回运行时的类型</li><li>toString：转化为字符串</li><li>equals： 虽然很多说equals是比较值额，但是在Object中实际上还是比较地址的</li><li>hashCode：比较两个对象的哈希值，一般用于哈希查找</li><li>wait：使当前线程等待该对象的锁，当前线程具有该对象的锁</li><li>notify，唤醒在该对象上等待的某个线程</li><li>notifyAll：唤醒在该对象上等待的所有线程</li></ul><h3 id="Hashcode的作用"><a href="#Hashcode的作用" class="headerlink" title="Hashcode的作用"></a>Hashcode的作用</h3><p>hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p><h3 id="Switch能否用string做参数"><a href="#Switch能否用string做参数" class="headerlink" title="Switch能否用string做参数"></a>Switch能否用string做参数</h3><p>这个和Java的版本有关，Java7之前无法使用字符串，在Java7以及以后的版本中可以使用字符串</p><h3 id="String、StringBuffer与StringBuilder的区别"><a href="#String、StringBuffer与StringBuilder的区别" class="headerlink" title="String、StringBuffer与StringBuilder的区别"></a>String、StringBuffer与StringBuilder的区别</h3><blockquote><p>String 是字符串常量，不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。</p></blockquote><blockquote><p>StringBuffer是字符串变量，可变的对象，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象。并且StringBuffer是线程安全的，其很多方法可以带有synchronized关键字。</p></blockquote><blockquote><p>StringBuilder也是字符串变量，很多方面都和StringBuffer类似，但是最大的区别是StringBuilder是线程不安全的。</p></blockquote><ol><li>三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String</li><li>StringBuffer：线程安全的、StringBuilder：线程非安全的 </li></ol><p>适用情况：</p><ul><li><p>String：适用于少量的字符串操作的情况</p></li><li><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p></li><li><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p></li></ul><h3 id="Comparator和Comparable"><a href="#Comparator和Comparable" class="headerlink" title="Comparator和Comparable"></a>Comparator和Comparable</h3><p>两种比较机制：Comparable 和 Comparator<br>Comparator，比较接口，涉及Collection的引入，具体的类本身不支持直接排序，重写Comparator内部的compareTo方法，可重用。<br>Comparable，排序的接口，具体的类内部实现compareTo方法，比如要比较两个Person，则需要在Person内部实现类方法compareTo，耦合性高</p><h3 id="java的浅拷贝和深拷贝"><a href="#java的浅拷贝和深拷贝" class="headerlink" title="java的浅拷贝和深拷贝"></a>java的浅拷贝和深拷贝</h3><p><a href="http://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="noopener">http://blog.csdn.net/zhangjg_blog/article/details/18369201</a></p><h3 id="Java静态内部类和内部类的区别"><a href="#Java静态内部类和内部类的区别" class="headerlink" title="Java静态内部类和内部类的区别"></a>Java静态内部类和内部类的区别</h3><p>内部类的作用：</p><blockquote><p>封装，隐藏不想让别人看的东西</p></blockquote><blockquote><p>完善多重继承，弥补Java只支持单继承的缺陷。当需要多重继承的时候，就可以实现多个内部类对应分别继承，实现外部类“多重继承”的效果。这也是内部类存在的最大意义。</p></blockquote><blockquote><p>闭包，内部类不仅包含创建内部类的作用域的信息，还自动拥有一个指向此外围类对象的引用</p></blockquote><blockquote><p>可以避免修改接口而实现同一个类中两种同名方法的调用，适用情况：当要继承的类和要实现的接口中有同名、同参数、同返回值的方法时。使用方法，让外部类去继承，内部类去实现接口</p></blockquote><p>（1） 被其他类访问：创建内部静态类实例的时候可以直接使用外部类名.内部类名访问内部类的静态成员或者需要新建一个内部类的实例来访问内部类的非静态成员。但非静态必须需要先新建一个外部类的实例，然后用外部类的实例创建内部类对象进行访问。<br>（2） 被外部类访问：对于非静态内部类外部类需要新建一个内部类的实例才能访问内部类，而对于静态内部类可以直接使用内部类类名访问内部类的静态成员或者新建一个内部类的实例访问内部类的非静态成员。<br>（3） 访问外部类：非静态内部类能够访问外部类的静态和非静态成员，所有访问权限。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。<br>（4） 静态类和非静态类的共有区别：静态类，能够在这个类中定义静态的成员变量与成员方法，非静态内部类中不可以声明静态成员。</p><p><strong>局部内部类</strong>：类定义在外部类的方法中，并且有自己的类名。局部内部类相当于一个局部变量，所以不能有访问控制符以及static等修饰符。局部内部类的访问（包括对象的创建、方法的调用）局限在外部类的方法内部。</p><p><strong>匿名内部类</strong>：匿名内部类继承自一个类或者实现一个接口，使用方法是直接使用new 父类名称或者接口名称就可以创建自己匿名内部类的对象。</p><p>静态内部类的设计意图<br>主要的思想是，不需要保存引用，直接使用方法或者变量</p><h3 id="public等四个权限关键字的区别"><a href="#public等四个权限关键字的区别" class="headerlink" title="public等四个权限关键字的区别"></a>public等四个权限关键字的区别</h3><pre><code>访问权限   类   包  子类  其他包public     ∨   ∨   ∨     ∨protect    ∨   ∨   ∨     ×default    ∨   ∨   ×     ×private    ∨   ×   ×     ×</code></pre><h3 id="final作用："><a href="#final作用：" class="headerlink" title="final作用："></a>final作用：</h3><p>当用final修饰一个类时，表明这个类不能被继承，final类中的所有成员方法都会被隐式地指定为final方法<br>当用final修饰方法时，把方法锁定，以防任何继承类修改它的含义<br>当用final修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象（地址不可以改变，值可以改变）<br>当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。</p><h3 id="static的作用："><a href="#static的作用：" class="headerlink" title="static的作用："></a>static的作用：</h3><p>修饰类成员变量，来让此变量变成类的所属，而不是类的对象所属（多个实例具有相同的值）<br>修饰类成员方法，可以使用”类名.方法名”的方式操作方法，不需要先new一个对象<br>修饰对象类的对象时，static修饰的成员会首先被初始化<br>修饰静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。</p><h3 id="try-里面return了finally还会执行吗"><a href="#try-里面return了finally还会执行吗" class="headerlink" title="try 里面return了finally还会执行吗"></a>try 里面return了finally还会执行吗</h3><p>1)、不管有木有出现异常，finally块中代码都会执行；<br>2)、当try和catch中有return时，finally仍然会执行；<br>3)、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4)、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><h3 id="线程安全集合类与非线程安全集合类"><a href="#线程安全集合类与非线程安全集合类" class="headerlink" title="线程安全集合类与非线程安全集合类"></a>线程安全集合类与非线程安全集合类</h3><p>LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;<br>HashMap是非线程安全的，HashTable是线程安全的;<br>StringBuilder是非线程安全的，StringBuffer是线程安全的。</p><h3 id="classloader"><a href="#classloader" class="headerlink" title="classloader"></a>classloader</h3><p><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/54973413</a></p><h3 id="Java中强软弱虚四种引用"><a href="#Java中强软弱虚四种引用" class="headerlink" title="Java中强软弱虚四种引用"></a>Java中强软弱虚四种引用</h3><p><a href="http://blog.csdn.net/zhuojianhai88/article/details/13503007" target="_blank" rel="noopener">http://blog.csdn.net/zhuojianhai88/article/details/13503007</a></p><h3 id="foreach与正常for循环效率对比"><a href="#foreach与正常for循环效率对比" class="headerlink" title="foreach与正常for循环效率对比"></a>foreach与正常for循环效率对比</h3><h3 id="java保证线程安全有哪些方法"><a href="#java保证线程安全有哪些方法" class="headerlink" title="java保证线程安全有哪些方法"></a>java保证线程安全有哪些方法</h3><ol><li>Synchronized</li><li>使用锁</li></ol><h3 id="线程安全的理解："><a href="#线程安全的理解：" class="headerlink" title="线程安全的理解："></a>线程安全的理解：</h3><p>一段代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，<br>就是线程安全的。</p><h3 id="Java有哪几种创建新线程的方法及区别"><a href="#Java有哪几种创建新线程的方法及区别" class="headerlink" title="Java有哪几种创建新线程的方法及区别"></a>Java有哪几种创建新线程的方法及区别</h3><p>继承Thread类创建线程类<br>通过Runnable接口创建线程类<br>通过Callable和Future创建线程</p><h3 id="Thread和Runnable比较："><a href="#Thread和Runnable比较：" class="headerlink" title="Thread和Runnable比较："></a>Thread和Runnable比较：</h3><p>Thread是一个可以继承的类，Runnable是一个接口，并且从Thread的源码可以发现， Thread类也是Runnable接口的子类；<br>Runnable接口相对于继承Thread类来说，有如下优点：</p><blockquote><p>首先Runnable作为接口，可以避免由于Java的单继承特性带来的局限。</p></blockquote><blockquote><p>适合多个相同程序代码的线程去处理同一资源的情况，支持线程间的资源共享。每个线程共享对象myRunnable的资源</p></blockquote><p>启动线程的方法：</p><blockquote><p>写一个类继承自Thread类,然后重写里面的run方法,用start方法启动线程</p></blockquote><blockquote><p>写一个类实现Runnable接口,实现里面的run方法,用new Thread(Runnable target).start()方法来启动.</p></blockquote><h3 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h3><p>可否嵌套，可以嵌套，但是容易造成死锁，互相等待。<br>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象（此时这个对象不能执行其他的同步语句块）； </li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li><li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li><li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li></ol><h3 id="Volatile的用法："><a href="#Volatile的用法：" class="headerlink" title="Volatile的用法："></a>Volatile的用法：</h3><h3 id="wait和sleep的区别，应用场景"><a href="#wait和sleep的区别，应用场景" class="headerlink" title="wait和sleep的区别，应用场景"></a>wait和sleep的区别，应用场景</h3><p>一般wait()和notify()方法使用于线程间的通信；sleep()方法用于暂停当前线程的执行。<br>sleep 是线程类（Thread）的静态方法，导致此线程暂停执行指定时间（阻塞当前线程），给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复，并且调用sleep不会释放对象锁。由于没有释放对象锁（锁还是存在），所以不能调用里面的同步方法。sleep必须捕获异常，可以自动唤醒<br>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；可以调用里面的同步方法，其他线程可以访问；必须要采用notify()和notifyAll()方法唤醒，<br>1，这两个方法来自不同的类分别是Thread和Object<br>2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p><pre><code class="java">synchronized(x) {    x.notify()    //或者wait()}</code></pre><p>4, sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</p><h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><p>死锁是指两个或两个以上的进程进在执行过程中，由于资源竞争或由于相互通信而造成的一种阻塞式现象，如果没有外力影响。那么它们将永远的持续下去， 此事称系统产生死锁现象，这种永远互相在等待的进程成为死锁。</p><p><strong>死锁的四个产生必要条件：</strong></p><p>1、（互斥）互斥条件：进程对所分配到的资源具有排他性使用，一段时间内某资源只由一个进程所占有。若此时还有其他请求资源，则请求者只能等待，知道占有资源的进程使用完毕释放。<br>2、（占有并等待）请求和保持条件：进程已经保持至少一个资源，但是又提出心得资源请求，而该资源已经被其他进程所占有，此时请求进程阻塞，但又对自己已经获得的其他资源保持不变。<br>3、（非抢占）不可剥夺条件：进程获得的资源，在未使用完之前，不能被剥夺，只能在使用完时有自己释放。<br>4、（循环等待）环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p><h2 id="算法与数据结构相关"><a href="#算法与数据结构相关" class="headerlink" title="算法与数据结构相关"></a>算法与数据结构相关</h2><h3 id="链表和数组比较"><a href="#链表和数组比较" class="headerlink" title="链表和数组比较"></a>链表和数组比较</h3><pre><code>    数组静态分配内存，链表动态分配内存；    数组在内存中连续，链表不一定连续；    数组元素在栈区，链表元素在堆区；    数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；    数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</code></pre><h3 id="Hashmap的原理（很重要）"><a href="#Hashmap的原理（很重要）" class="headerlink" title="Hashmap的原理（很重要）"></a>Hashmap的原理（很重要）</h3><p>在另外一篇介绍容器的博客</p><p><img src="http://dengw.xyz/hexo-blog/180426/ljG5K6bB9D.png" alt=""></p><h3 id="Hashmap和hashtable比较"><a href="#Hashmap和hashtable比较" class="headerlink" title="Hashmap和hashtable比较"></a>Hashmap和hashtable比较</h3><h3 id="TreeMap、HashMap、LindedHashMap的区别"><a href="#TreeMap、HashMap、LindedHashMap的区别" class="headerlink" title="TreeMap、HashMap、LindedHashMap的区别"></a>TreeMap、HashMap、LindedHashMap的区别</h3><h3 id="ArrayList和LinkedList的实现和区别"><a href="#ArrayList和LinkedList的实现和区别" class="headerlink" title="ArrayList和LinkedList的实现和区别"></a>ArrayList和LinkedList的实现和区别</h3><h3 id="List与Set、Map"><a href="#List与Set、Map" class="headerlink" title="List与Set、Map"></a>List与Set、Map</h3><h3 id="Map、Set、List、Queue、Stack的特点与用法。"><a href="#Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="Map、Set、List、Queue、Stack的特点与用法。"></a>Map、Set、List、Queue、Stack的特点与用法。</h3><h3 id="HashSet和TreeSet"><a href="#HashSet和TreeSet" class="headerlink" title="HashSet和TreeSet"></a>HashSet和TreeSet</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code class="java">void smap(int []a, int index1, int index2) {    int tem = a[index1];    a[index1] = a[index2];    a[index2] = tem;}int partion(int []a, int low, int high) {    int num = a[low];    while(low &lt; high) {        while(low &lt; high &amp;&amp; num &lt; a[high]) {            high--;        }        smap(a, low, high);        while(low &lt; high &amp;&amp; num &gt;= a[low]) {            low++;        }        smap(a, low, high);                }    return low;}void quickSort(int []a, int low, int high) {    if(low &lt; high) {        int index = partion(a, low, high);        quickSort(a, low, index - 1);        quickSort(a, index + 1, high);    }}</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h3 id="AVL树-平衡二叉树"><a href="#AVL树-平衡二叉树" class="headerlink" title="AVL树(平衡二叉树)"></a>AVL树(平衡二叉树)</h3><ul><li>左子树和右子树的高度之差的绝对值不超过1</li><li>树中的每个左子树和右子树都是AVL树</li><li>每个节点都有一个平衡因子(balance factor–bf),任一节点的平衡因子是-1,0,1。(每个节点的平衡因子等于右子树的高度减去左子树的高度 )  </li></ul><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>只能有最下面两层的子节点度数不为2</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>除了最下面一层外每个节点都有两个子节点</p><p><img src="http://dengw.xyz/hexo-blog/180426/hh298Df396.png" alt=""></p><p>红黑树<br><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">https://blog.csdn.net/sun_tttt/article/details/65445754</a></p><p>Hash表<br>B+树</p><h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><p>进程冲突，生产者消费者问题，设逻辑分页和物理分页好处是什么，什么是脏内存</p><p>虚拟地址、逻辑地址、线性地址、物理地址的区别</p><p><strong>什么是虚拟内存</strong></p><p><strong>虚拟内存别称虚拟存储器（Virtual Memory）</strong></p><p><strong>进程的几种状态</strong><br>三态模型：</p><p>五态模型：</p><p><strong>线程的几种状态</strong><br>线程只有3个基本状态：就绪，执行，阻塞</p><p><strong>进程和线程的区别</strong><br>进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。每一个进程都有一个自己的地址空间，即进程空间或(虚空间)。进程空间的大小只与处理机的位数有关，一个16位长处理机的进程空间大小为216，而32位处理机的进程空间大小为232。进程至少有5种基本状态,它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p><p>线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。</p><p><strong>进程通信(IPC几种通信方式)</strong></p><h2 id="计算机网络相关"><a href="#计算机网络相关" class="headerlink" title="计算机网络相关"></a>计算机网络相关</h2><h3 id="http1-1相比以前版本（http1-0）有什么改变"><a href="#http1-1相比以前版本（http1-0）有什么改变" class="headerlink" title="http1.1相比以前版本（http1.0）有什么改变"></a>http1.1相比以前版本（http1.0）有什么改变</h3><p>HTTP/1.0协议使用非持久连接,即在非持久连接下,一个tcp连接只传输一个Web对象,；<br>HTTP/1.1默认使用持久连接，一个tcp连接可以传输多个web对象</p><h3 id="七层-五层模型"><a href="#七层-五层模型" class="headerlink" title="七层/五层模型"></a>七层/五层模型</h3><p>七层：物理层，链路层，网络层，传输层，会话层，表示层，应用层<br>五层：物理层，链路层，网络层，传输层，应用层<br>其中：</p><blockquote><p>表示层：信息语言语法语义以及它们的关联，如加密解密，转换翻译等<br>会话层：不同机器上的用户之间建立以及管理会话</p></blockquote><h3 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h3><p>GET主要是客户端的语义是请求获取指定的资源，主要用于客户端从服务端获取资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）,GET方法的报文主体没有任何语义，适合传输少量数据</p><p>POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，主要用于客户端旺服务端提交信息，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存、对传送的数据大小没有限制</p><p><strong>get和post区别</strong></p><ol><li><p>GET提交:<br>请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中），以?分割URL和传输数据，多个参数用&amp;连接;例如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p></li><li><p>POST提交：<br>把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据</p></li></ol><p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p><strong>传输数据的大小</strong>：<br>   首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p><p>   GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p><p>   因此对于GET提交时，传输数据就会受到URL长度的限制。</p><p>   POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p><p><strong>安全性</strong>：<br>    POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了</p><h3 id="Http的报文结构"><a href="#Http的报文结构" class="headerlink" title="Http的报文结构"></a>Http的报文结构</h3><p><img src="http://dengw.xyz/hexo-blog/180426/HK0Le1E7cc.png" alt="请求报文"></p><p><img src="http://dengw.xyz/hexo-blog/180426/HImLIiD8hg.png" alt="返回报文"></p><h3 id="Http的状态码含义"><a href="#Http的状态码含义" class="headerlink" title="Http的状态码含义"></a>Http的状态码含义</h3><ul><li>200 ：OK：请求成功</li><li>204： 服务器成功处理了请求，但没有返回任何内容</li><li>301  Moved Permanently：请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。 </li><li>302： 请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。</li><li>304： 如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。</li><li>400：Bad Request：一个通用差错代码，指示该请求不能被服务器理解</li><li>403：服务器拒绝请求。</li><li>404：Not Found：被请求的文档不在服务器上</li><li>500：服务器遇到错误，无法完成请求。 </li><li>503：服务器目前无法使用（由于超载或停机维护）</li><li>505：HTTP Version Not Support: 服务器不支持当前http协议的版本</li></ul><h3 id="Http-request的几种类型"><a href="#Http-request的几种类型" class="headerlink" title="Http request的几种类型"></a>Http request的几种类型</h3><ul><li>Get: 一般用来从客户端从服务器中读取内容，服务器将URL定位的资源放在响应报文的数据部分，回送给客户端</li><li>Post:</li><li>HEAD：HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</li><li>PUT</li><li>DELETE</li><li>OPTIONS</li><li>TRACE</li><li>CONNECT</li></ul><h3 id="HTTP和HTTPS协议的差别："><a href="#HTTP和HTTPS协议的差别：" class="headerlink" title="HTTP和HTTPS协议的差别："></a>HTTP和HTTPS协议的差别：</h3><p>超文本传输协议HTTP被用于在Web客户端程序和网站端程序之间传递信息，两个端系统之间通过HTTP报文进行会话，HTTP定义了这些报文的结构以及客户和服务器进行报文交换方式，它有两个很鲜明的特点：一是HTTP是一个无状态协议，二是它以明文方式发送内容，不提供任何方式的数据加密。<br>HTTPS就是为了解决HTTP协议的没办法加密的这一缺陷而产生的，毕竟不加密的话数据报文被窃取是很危险的，全称为安全套接字层超文本传输协议HTTPS，是在HTTP的基础上加入了SSL协议，使用SSL协议的加密算法来完成身份验证，并为浏览器和服务器之间的通信加密，它的安全基础是SSL协议。</p><p>用的端口也不一样，前者是80，后者是443</p><h3 id="SSL-TLS-握手"><a href="#SSL-TLS-握手" class="headerlink" title="SSL/TLS 握手"></a>SSL/TLS 握手</h3><p>SSL/TLS 协议是用来给HTTPS进行加密的，作用在 HTTP 协议之下，使用SSL的加密算法完成身份验证，防制报文信息被窃取（谈一谈HTTP的缺陷）</p><p>过程：就是https对称加密的原理，如下</p><p>https的非对称加密：非对称加密采用的是SSL协议完成的，过程如下：</p><ul><li>当你的浏览器使用htts的形式向服务器请求一个安全的网页</li><li>服务器就把它的证书和公匙发回来</li><li>浏览器检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的。</li><li>浏览器随机生成一对对称秘钥，并使用公钥（服务器端的）加密该对称秘钥，将它和对称加密后的URL一起发送到服务器</li><li>服务器用自己的私匙解密了你发送的钥匙。然后用这把对称加密的钥匙给你请求的URL链接解密。</li><li>服务器用你发的对称钥匙给你请求的网页加密。你也有相同的钥匙就可以解密发回来的网页</li></ul><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ul><li><p>TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接</p></li><li><p>TCP提供可靠的服务。背后有一套完整的机制确保通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付</p></li><li>UDP对应用层的控制更加精确，UDP会立即将应用层的报文发送给网络层。</li><li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节，TCP报文有20个字节的首部</li><li>一般实时类的应用选择UDP作为传输层协议。</li></ul><h3 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h3><p><img src="http://dengw.xyz/hexo-blog/180426/4fhfhjmjbE.png" alt=""></p><p>上图中有几个字段需要重点介绍下：</p><ol><li>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li><li>确认序号： Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</li><li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<blockquote><p>URG：紧急指针（urgent pointer）有效。<br>ACK：确认序号有效。<br>PSH：接收方应该尽快将这个报文交给应用层。<br>RST：重置连接。<br>SYN：发起一个新连接。<br>FIN：释放一个连接。</p></blockquote></li></ol><p>需要注意的是：<br>不要将确认序号Ack与标志位中的ACK搞混了。<br>确认方Ack=发起方Req+1，两端配对。</p><h3 id="TCP滑动窗口与回退N针协议"><a href="#TCP滑动窗口与回退N针协议" class="headerlink" title="TCP滑动窗口与回退N针协议"></a>TCP滑动窗口与回退N针协议</h3><p>发送方只是用一个定时器，超时重传多有已发但还未被确认过的分组<br>容错率低，单个分组可能造成GBN重传大量分组：<br>P147</p><h3 id="TCP选择重传"><a href="#TCP选择重传" class="headerlink" title="TCP选择重传"></a>TCP选择重传</h3><p>每个分组都有一个定时器，发送方超时只会重新发送一个分组<br>P151</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><h3 id="Tcp三次握手的过程"><a href="#Tcp三次握手的过程" class="headerlink" title="Tcp三次握手的过程"></a>Tcp三次握手的过程</h3><p><img src="http://dengw.xyz/hexo-blog/180426/dEiLHj5b1F.png" alt=""></p><p>如果确认信号没传到服务器会发生什么？为什么不是两次握手？</p><p>还要再发送一次确认是为了，防止已失效的连接请求报文段突然又传到了B，因而产生错误。<br>     某种情况下，A的第一个请求在某个节点滞留了，延误到达，本来这是一个早已失效的报文段，但是在A发送第二个，并且得到B的回应，建立了连接以后，这个报文段竟然到达了，于是B就认为，A又发送了一个新的请求，于是发送确认报文段，同意建立连接，假若没有三次的握手，那么这个连接就建立起来了（有一个请求和一个回应），此时，A收到B的确认，但A知道自己并没有发送建立连接的请求，因为不会理睬B的这个确认，于是呢，A也不会发送任何数据，而B呢却以为新的连接建立了起来，一直等待A发送数据给自己，此时B的资源就被白白浪费了。但是采用三次握手的话，A就不发送确认，那么B由于收不到确认，也就知道并没有要求建立连接。<br>     简而言之：第三次握手，主机A发送一次确认是为了防止：如果客户端迟迟没有收到服务器返回的确认报文，这时他会放弃连接，重新启动一条连接请求；但问题是：服务器不知客户端没收到，所以他会收到两个连接请求，白白浪费了一条连接开销。</p><h3 id="Tcp四次挥手的过程"><a href="#Tcp四次挥手的过程" class="headerlink" title="Tcp四次挥手的过程"></a>Tcp四次挥手的过程</h3><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p><p><img src="http://dengw.xyz/hexo-blog/180426/cagcJbgJbE.png" alt=""></p><ol><li>A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。</li><li>B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</li><li>A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</li><li>B没有要向A发出的数据，B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。</li><li>A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。</li></ol><h3 id="电脑上访问一个网页的过程"><a href="#电脑上访问一个网页的过程" class="headerlink" title="电脑上访问一个网页的过程"></a>电脑上访问一个网页的过程</h3><p>DNS、HTTP、TCP、OSPF、IP、ARP。</p><h3 id="Ping的整个过程"><a href="#Ping的整个过程" class="headerlink" title="Ping的整个过程"></a>Ping的整个过程</h3><p>ICMP报文是什么。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年实习春招面试总结</title>
      <link href="/2018/04/25/2018%E5%B9%B4%E5%AE%9E%E4%B9%A0%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/25/2018%E5%B9%B4%E5%AE%9E%E4%B9%A0%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>到今天为止，我的实习春招之路应该可以画上一个句号了，至于说这个句号完不完整，个人还是比较满意的。从量出比的角度来看，可以说自己的努力没有白费吧。从过完年之后决定找安卓方向的实习开始，到三月份从头再学习一遍安卓基础知识、系统性学习Java，然后在四月初开始出去面试，到现在收获第一个offer，现在回想起这个过程，心里面真的竟有感触的。整个三、四月份基本上都是凌晨两三点才睡，平均每天六个小时的睡眠，翘了无数的课，心情从每次面试前的满怀希望到面试后失望甚至到后期的绝望。晚上开始失眠，半个小时、一个小时、两个小时、三个小时，翻来覆去，第一次感受到这么大的压力。天晚上接完hr的录用电话后，那一刻真的想哭，真的很心酸…但是却什么也不想多说，只想静静地坐着，就那样坐着。</p><p>这次春招的收获，我觉得offer是一方面，另一方面深深刻刻地认识到自己的不足，真的是太弱了，要学习的东西太多了，太多了…这也为秋招敲响了警钟吧。知不足而奋进，我想，如果能够好好总结这次春招，根据面试过程中自己暴露出的薄弱项进行有针对的弥补与提高，也将会成为这次春招最大的收获吧。</p><p>面试过程中暴露出了如下一些问题：</p><h3 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h3><ul><li><p>Java泛型类</p></li><li><p>Java的内存管理</p></li><li><p>Java垃圾回收机制</p></li><li><p>Java虚拟机相关的知识</p></li><li><p>Java中线程相关，锁与同步的问题</p></li><li><p>Java并发编程相关的</p></li><li><p>一些比较底层的实现原理，比如：Java多态的实现原理</p></li><li><p>Java文件操作</p></li><li><p>Java网络访问</p></li></ul><p>总的来说，对于Java相关的知识，不管是广度还是深度都没有，有很多重要知识点是一点都没有了解，比如Java虚拟机相关的，另外一点就是对Java的底层原理了解的太少，面试官问的稍微深一点就不说不出来了。</p><h3 id="Android相关"><a href="#Android相关" class="headerlink" title="Android相关"></a>Android相关</h3><p>Android在面试中暴露出的问题主要有如下几个方面：</p><ul><li><p>底层实现原理不了解，现在掌握程度只停留在使用上，技术深度不够</p></li><li><p>纸上得来终觉浅，一些知识点没有亲自上手，很容易就遗忘或者理解有误</p></li><li><p>项目经验严重不足，对于技术难点以及一些问题的解决方法一点都不了解</p></li><li><p>设计模式太陌生了</p></li><li><p>常见的框架仅仅停留在使用的层面上，对实现方法不了解</p></li><li><p>没有了解的特别深入的知识点，与面试官的共同语言太少</p></li><li><p>知识广度不够，比如像性能优JNI和NDK相关的知识一点都不了解</p></li><li><p>对新技术了解地太少，比如插件化，热修复等</p></li></ul><p>上面罗列的知识只是一些大概的方向，没有涉及到具体的问题，还要总结一下具体的没有答上来或者没有答好的问题。</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>卒</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>有待完善</p><h3 id="信息安全相关"><a href="#信息安全相关" class="headerlink" title="信息安全相关"></a>信息安全相关</h3><p>有待完善</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>有待完善</p><h3 id="面试问题整理"><a href="#面试问题整理" class="headerlink" title="面试问题整理"></a>面试问题整理</h3><p><a href="https://blog.csdn.net/code__man/article/details/79635714" target="_blank" rel="noopener">BAT大厂Android面试题Java部分问题和答案整理(一)</a><br><a href="https://www.jianshu.com/p/c70989bd5f29" target="_blank" rel="noopener">最全的BAT大厂Android面试题整理</a><br><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge" target="_blank" rel="noopener">常用的Android开发的一些技能点以及史上最全的BAT大厂Android面试题汇集</a><br><a href="https://www.jianshu.com/p/cf5092fa2694?utm_source=desktop&amp;utm_medium=timeline" target="_blank" rel="noopener">Android大厂面试题锦集(BAT TMD JD 小米)</a><br><a href="https://blog.csdn.net/xhmj12/article/details/54730883" target="_blank" rel="noopener">Android面试题</a><br><a href="https://github.com/Mr-YangCheng/ForAndroidInterview" target="_blank" rel="noopener">Android 名企面试题及涉及知识点整理</a><br><a href="https://zhuanlan.zhihu.com/p/34111396" target="_blank" rel="noopener">Android基础知识面试30题及答案</a></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SelectCourseApp开发过程问题总结</title>
      <link href="/2018/04/23/SelectCourseApp%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/23/SelectCourseApp%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Fragement的部署以及实现fragment效果的几种方法总结一下</p></blockquote><blockquote><p>Viewpager的使用</p></blockquote><blockquote><p>tools属性</p></blockquote><blockquote><p> getColor方法过时的解决方法</p></blockquote><blockquote><p>关于页面顶部标题栏和状态栏的操作方法，沉浸式状态栏(透明状态栏)</p></blockquote><blockquote><p> 不同布局场景下的一些居中方法</p></blockquote><blockquote><p> 不同的布局使用方法</p></blockquote><blockquote><p> PopupWindow的使用与一些定制化</p></blockquote><blockquote><p>Spinner的使用</p></blockquote><blockquote><p>RecycleView和ListView的底层原理</p></blockquote><blockquote><p>使图片填满ImageView(比例问题)</p></blockquote><blockquote><p>去掉窗口顶部的通知栏（从windows的角度）<br>顺便学习Android中windows相关的</p></blockquote><blockquote><p>设置顶部通知栏的颜色（从windows的角度）</p></blockquote><blockquote><p>去掉应用顶部的标题栏</p><pre><code class="java">if (getSupportActionBar() != null){    getSupportActionBar().hide();}</code></pre></blockquote><blockquote><p>Fragment的使用总结</p></blockquote><blockquote><p>怎么让一个Activity在点击返回按钮后不会再出现，比如登录Activity， SplashActivity</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android学习笔记—MVP初体验</title>
      <link href="/2018/04/18/Android-MVP%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/04/18/Android-MVP%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>最近正在学习MVP模式，在学习了相关的知识之后就尝试着对之前的一些项目使用MVP模式进行重构。在这个过程中有一些个人感悟，在这里记录一下这次尝试中自己的一些想法、遇到的问题以及解决思路。最后在贴上重构前以及重构后的代码版本，方便对比学习。因为这是自己第一次尝试着使用MVP模式，应该一些地方自己理解的不是很深刻，肯定有很多需要改进的地方，对MVP的一些特性暂时理解不到。</p><h3 id="MVP简单介绍"><a href="#MVP简单介绍" class="headerlink" title="MVP简单介绍"></a>MVP简单介绍</h3><p>MVC模式想必大家已经比较熟悉了，之前在做web应用开发的时候就已经接触过了。在学习Android的时候，使用AS开发项目一般都是使用MVC模式的。但是随着开发的深入，会发现Activity类会越来越臃肿，在Activity中实现的逻辑越来越复杂，有时候甚至会把业务逻辑，数据请求等全部放在Activity中实现。即使你对里面使用到的函数有很好的命名规范，但是一段时间后你再回来看甚至看不明白这个类，这个函数有什么用。</p><p>这个时候MVP模式就显得很有用了，它可以把逻辑关系里的非常顺，条理非常清晰，MVP模式对各个层的任务有非常明确的分配。所以学习MVP模式很重要的一点个人感觉就是了解各个层的具体任务，明白各个层具体是干嘛的，这样就能够将功能进行有效的划分，这也是一个初学者的首要任务吧。</p><p>在介绍各个层之前有必要介绍另外一个重要的概念—接口。Model、Presenter和View都被设置成为接口的形式。至于为什么要全部设置为接口而不直接设成类，个人觉得这样更符合Java面向抽象的设计思想，一个接口可以有很多个具体实现的类，实现方法根据具体的类而定；另外一个原因我想应该是根据接口的特性，一个类可以实现多个接口，因为存在一个类中要使用多个类中的方法，而接口可以更好地满足这一点。</p><p><strong>Model层</strong></p><p>我最开始以为model层就放一些bean类就好了，后来发现其实不是。我认为model层更准确的叫法叫data层，是用来和数据打交道的，比如请求数据，处理数据的。当你确定好有哪些和数据相关的方法之后，就可以在model层接口中声明相应的函数，然后根据函数的返回情况设置好相应的回调函数。然后在Presenter层会获得当前model接口的一个引用，这样就能调用接口的方法进行数据处理了。</p><p>一个访问网络请求数据的接口实现如下：</p><p>根据用户名访问网络请求数据，回调函数接口为GetUserInfoCallback</p><pre><code class="java">package com.example.duang1996.githubfetcher.Main.model;/** * Created by duang1996 on 2018/4/17. */public interface IMainModel {    void getUserInfo(String userName, GetUserInfoCallback getUserInfoCallback);}</code></pre><p>回调函数的实现，因为我是使用Retrofit请求数据的，这里返回情况有三种</p><pre><code class="java">package com.example.duang1996.githubfetcher.Main.model;import java.util.Map;/** * Created by duang1996 on 2018/4/17. */public interface GetUserInfoCallback {    void GetSuccess(Map&lt;String, Object&gt; tem);    // 对应于onSuccess()    void GetComplete();                          // 对应于onNext    void GetFailed();                            //对应于onError}</code></pre><p>实现model接口，实现了具体的方法，用来实例化接口</p><pre><code class="java">public class MainModel implements IMainModel{    private GitHubService gitHubService = new ServiceFactory().getGitHubService();;    private Subscriber&lt;User&gt; subscriber;    @Override    public void getUserInfo(String userName, final GetUserInfoCallback getUserInfoCallback) {        subscriber = new Subscriber&lt;User&gt;() {            @Override            public void onCompleted() {                getUserInfoCallback.GetComplete();   //调动回调函数接口中的方法，下同            }            @Override            public void onError(Throwable e) {                getUserInfoCallback.GetFailed();            }            @Override            public void onNext(User user) {                Map&lt;String, Object&gt; tem = new LinkedHashMap&lt;&gt;();                tem.put(&quot;name&quot;, user.getLogin());                tem.put(&quot;id&quot;, &quot;id: &quot; + user.getId());                tem.put(&quot;blog&quot;, &quot;blog: &quot; + user.getBlog());                getUserInfoCallback.GetSuccess(tem);            }        };        gitHubService.getUser(userName)                .subscribeOn(Schedulers.io())                .observeOn(AndroidSchedulers.mainThread())                .subscribe(subscriber);    }}</code></pre><p><strong>View层</strong><br>View层用来处理UI界面相关的逻辑，作用效果是改变UI视图，一般这个接口的方法最开始不太好定义，因为不知道具体有哪些地方需要更改UI，不过不用着急，有个笨办法，当你需要一个就定义一个。不过这种方法对于接口的复用不太友好，而复用又是MVP很重要的一个特性。当你水平够高了，项目经验足够丰富的时候就可以一眼看穿，事先定义好啦~</p><p>继续来样例，View接口的定义</p><pre><code class="java">package com.example.duang1996.githubfetcher.Main.view;/** * Created by duang1996 on 2018/4/17. */public interface IMainView {    void showProcessBar();    void hideProcessBar();    void toRepoActivity(String userName);   //其实这个方法是否放在这儿还有待考虑    void notifyItemInserted(int i);}</code></pre><p>View接口的实现：<br>看网上相关的教程不难发现。View接口的具体实现是在Activity中操作，我刚开始看到的时候还在想，为什么View接口的不单独新建一个类来实现View接口中的方法呢，凭什么其他两种接口就可以有单独的类来实现就View就没有呢？你们先想一下能够想到答案吗？</p><p>哈哈，机智的你应该已经想到了。我的理解是这样的。首先，View层是用来干嘛的，是用来更新UI的，准确的说是用来改变布局控件的外观的，那这些控件是在哪儿实例化的呢，就是在Activity中，所以View接口是在activity中实现的，方便方法直接访问这些控件。</p><p>说完了就看一下view接口的具体实现吧</p><pre><code class="java">public class MainActivity extends AppCompatActivity implements IMainView{    private EditText input;    private Button clearBtn;    private Button fetchBtn;    private ProgressBar progressBar;    private RecyclerView usersView;    private CardAdapter cardAdapter;    private MainPresenterCompl mainPresenterCompl;  //获取一个继承自presenter接口的实例    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        /*         *初始化元素         */        initViews();    }    ......    @Override    public void showProcessBar() {        progressBar.setVisibility(View.VISIBLE);    }    @Override    public void hideProcessBar() {        progressBar.setVisibility(View.GONE);    }    @Override    public void toRepoActivity(String userName){        Intent intent = new Intent(MainActivity.this, RepoActivity.class);        intent.putExtra(&quot;login&quot;, userName);        startActivity(intent);    }    @Override    public void notifyItemInserted(int i) {        cardAdapter.notifyItemInserted(i);    }}</code></pre><h3 id="Presenter层"><a href="#Presenter层" class="headerlink" title="Presenter层"></a>Presenter层</h3><p>Presenter是Model和View之间交互的桥梁，我的理解是将model层返回的数据传递给View层，然后更新UI界面，此外还可以收到view层UI上的反馈命令后分发处理逻辑，充当一个业务逻辑层的额角色</p><p>一个Presenter接口定义如下，里面的函数包括一些业务逻辑函数以及对model层函数的包装</p><pre><code class="java">package com.example.duang1996.githubfetcher.Main.presenter;import java.util.List;import java.util.Map;/** * Created by duang1996 on 2018/4/17. */public interface IMainPresenter {    void getUserInfo(String str);    void setClick(int i);    void setLongClick(int i);    void clear();    void destorySubscription();    List&lt;Map&lt;String, Object&gt;&gt; getUserList();}</code></pre><p>presenter接口的具体实现：</p><pre><code class="java">//view 与model之间的桥梁public class MainPresenterCompl implements IMainPresenter{    private IMainModel iMainModel;  // 获取model接口的引用    private IMainView iMainView;  // 获取view接口的引用    private List&lt;Map&lt;String, Object&gt;&gt; userList = new ArrayList&lt;&gt;();    public MainPresenterCompl(){        this.iMainModel = new MainModel();    }     //因为要获取Activity的引用，结合下面的方法可以防止引用空指针    public void attachView(IMainView iMainView) {          this.iMainView = iMainView;    }    public boolean isViewAttached(){        return iMainView != null;    }    // 解除引用，防止内存泄漏    public void detachView() {         this.iMainView= null;    }    @Override    public void getUserInfo(String str) {        if(isViewAttached()) {            iMainView.showProcessBar();            iMainModel.getUserInfo(str, new GetUserInfoCallback() {                  //model 层中回调接口的具体实现                @Override                public void GetSuccess(Map&lt;String, Object&gt; tem) {                    userList.add(tem);                    iMainView.notifyItemInserted(userList.size() - 1);                }                @Override                public void GetComplete() {                    iMainView.hideProcessBar();                }                @Override                public void GetFailed() {                }            });        }    }    @Override    public void setClick(int i) {        if(isViewAttached()) {            Map&lt;String, Object&gt; tem = userList.get(i);            String login = tem.get(&quot;name&quot;).toString();            iMainView.toRepoActivity(login);        }    }    @Override    public void setLongClick(int i) {        if(isViewAttached()) {            userList.remove(i);        }    }    @Override    public void clear() {        if(isViewAttached()) {            userList.clear();        }    }    @Override    public List&lt;Map&lt;String, Object&gt;&gt; getUserList() {        if(isViewAttached()) {            return userList;        }        return null;    }    @Override    public void destorySubscription() {        if(isViewAttached()) {            iMainModel.destorySubscription();        }    }}</code></pre><h3 id="MVP各层之间的引用关系"><a href="#MVP各层之间的引用关系" class="headerlink" title="MVP各层之间的引用关系"></a>MVP各层之间的引用关系</h3><p><img src="http://dengw.xyz/hexo-blog/180420/HGCGE61a88.png" alt="层关系引用图"><br><strong>Presenterc层</strong><br>Presenter持有model接口和view接口的引用，这样也很好理解，Presenter充当一个桥梁的角色，肯定要能够使用到两个接口中的方法</p><p><strong>View层</strong><br>View层持有presenter层的接口，presenter层需要处理一些UI界面上的业务逻辑，因此将presenter接口暴露给view层方便调用。</p><p>可能初学的时候大家会觉得presenter层和view层互相持有对方的接口有一点绕，可以按照下面的这个思路来理解。</p><p>Model层获取到数据返回给Prensenter层，这时候需要更新UI，然后根据Presenter中引用的View接口，调用View接口中的相应方法，这是presenter层到view层。<br>当View层上获取一些逻辑命名，比如button被点击了，这个时候通过View层中引用的Presenter接口，调用presenter接口中定义相关的函数，这是view层到presenter层。</p><h3 id="使用对比"><a href="#使用对比" class="headerlink" title="使用对比"></a>使用对比</h3><p>下面是使用MVP模式和不适用MVP模式对同一个项目的两种实现，完整的代码：<br><a href="https://github.com/duang0626/GithubFetcher/tree/7bd31479901f9c0163f707e8e3e91282b5bbb180" target="_blank" rel="noopener">使用MVP模式重构之前的版本</a><br><a href="https://github.com/duang0626/GithubFetcher" target="_blank" rel="noopener">使用MVP模式重构之后的版本</a></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> MVP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit2.0完全解读（三）</title>
      <link href="/2018/03/31/Retrofit2.0%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/03/31/Retrofit2.0%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在前面一篇文章中介绍了Retrofit的快速使用，根据这些介绍就可以搭建一个简单的Demo来练练手了。但是这些对了掌握Retrofit来说当然是远远不够，下面就详细地讲解一下在步骤中一些很重要的东西吧。</p><h2 id="依赖添加"><a href="#依赖添加" class="headerlink" title="依赖添加"></a>依赖添加</h2><p>Retrofit 2.0以后的版本已经默认使用OkHttp作为作为HTTP 连接接口，在之前的版本是可以选择的。所以在之前的版本里面，如果想要使用OkHttp，就必须要像下面这样把OkHttp的依赖也添加到依赖文件里面：</p><pre><code class="java">dependencies {    ...    compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39;    compile &#39;com.squareup.okhttp3:okhttp:3.1.2&#39;  }</code></pre><p>但是在Retrofit 2.0中，已经自动为OkHttp设置了依赖：</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt;        &lt;artifactId&gt;okhttp&lt;/artifactId&gt;    &lt;/dependency&gt;    ...&lt;/dependencies&gt;</code></pre><p>所以在依赖文件只需要添加Retrofit的依赖即可:</p><pre><code>dependencies {    ...    implementation &#39;com.squareup.retrofit2:retrofit:2.3.0&#39;  }</code></pre><p>当然一般我们都会集合Gson使用，有时候还会使用RxJava，这些也要添加依赖的：</p><pre><code>dependencies {    ...    implementation &#39;com.squareup.retrofit2:retrofit:2.3.0&#39;    implementation &#39;com.squareup.retrofit2:adapter-rxjava:2.3.0&#39;    implementation &#39;com.squareup.retrofit2:converter-gson:2.3.0&#39;    implementation &#39;io.reactivex:rxandroid:1.2.1&#39;  }</code></pre><h2 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h2><p>官方给的是这样的一个样例，看着简单，但是这里面却有很多要说</p><pre><code class="java">public interface GitHubService {  @GET(&quot;users/{user}/repos&quot;)  Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><p>可以看到在接口设置这儿有很多的注解类型，Retrofit2.0 中有三种类型的注解，分别是：网络请求方法、标记类、网络请求参数。</p><h3 id="网络请求方法"><a href="#网络请求方法" class="headerlink" title="网络请求方法"></a>网络请求方法</h3><p>这儿对应Http request的请求类型，上面示范代码中的<code>@Get</code>就是网络请求方法的一种，不同的注解代表不同的操作，Http请求方法有以下几种，其中，除HTTP以外都对应了HTTP标准中的请求方法：</p><p><img src="http://dengw.xyz/hexo-blog/180331/Hci6kla12g.png" alt="HTTP请求方法注解"></p><p>对于每种方法的作用这里就不详细的介绍，具体的讲一下每一种请求类型在这儿的使用方法。</p><ul><li>@GET、@POST、@PUT、@DELETE、@HEAD、@Path、@HEAD、@OPTIONS</li></ul><p>这些方法都是HTTP的请求方法，它们的使用方法很类似，都可以以下面这样的形式：</p><pre><code class="java">@XXX(path)比如：@GET(&quot;users/list&quot;)@POST(&quot;users/new&quot;)@PUT(&quot;user/photo&quot;)</code></pre><p>说到这儿了，就很有必要讲一下Retrofit2.0 的URL组成了。一般都是由两部分组成: baseUrl + path， 其中baseUrl是在创建Retrofit2.0 实例时设置的，path就是上面请求方法中括号中的path。组合的规则如下：</p><table><thead><tr><th>类型</th><th>具体的使用</th></tr></thead><tbody><tr><td>path = 完整的Url</td><td>Url =  <a href="https://api.github.com/users/list" target="_blank" rel="noopener">https://api.github.com/users/list</a><br>path =   <a href="https://api.github.com/users/list" target="_blank" rel="noopener">https://api.github.com/users/list</a><br>baseUrl不设置</td></tr><tr><td>path = 绝对路径</td><td>Url =  <a href="https://api.github.com/users/list" target="_blank" rel="noopener">https://api.github.com/users/list</a><br>path = /users/list<br>baseUrl = <a href="https://api.github.com/a/b" target="_blank" rel="noopener">https://api.github.com/a/b</a></td></tr><tr><td>path =  相对路径<br>baseUrl = 目录形式</td><td>Url =  <a href="https://api.github.com/users/list" target="_blank" rel="noopener">https://api.github.com/users/list</a><br>path = users/list<br>baseUrl = <a href="https://api.github.com/" target="_blank" rel="noopener">https://api.github.com/</a></td></tr></tbody></table><p>一种比较好的定义形式是第三种，即</p><blockquote><p>Base URL: 总是以 /结尾<br>@Url: 不要以 / 开头</p></blockquote><ul><li>HTTP</li><li>作用：替换上面提到的七种注解 及 更多功能拓展</li><li>具体使用：通过属性method、path、hasBody进行设置</li></ul><p>例如，下面两段代码等价：</p><pre><code class="java">    @GET(&quot;users/{user}&quot;)    Observable&lt;User&gt; getUser(@Path(&quot;user&quot;) String user);      //使用@HTTP替代@GET      @HTTP(method=&quot;GET&quot;, path=&quot;users/{user}&quot;, hasBody = false)    Observable&lt;User&gt; getUser(@Path(&quot;user&quot;) String user);</code></pre><ul><li>method 表示请求的方法，区分大小写</li><li>path表示路径</li><li>hasBody表示是否有请求体</li></ul><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p><img src="http://dengw.xyz/hexo-blog/180331/LB9HF0e2ak.png" alt="标记类注解"></p><p>@FormUrlEncoded</p><p>作用：表示发送form-encoded的数据<br>每个键值对需要用@Filed来注解键名，随后的对象需要提供值。</p><p>@Multipart</p><p>作用：表示发送form-encoded的数据（适用于 有文件 上传的场景）<br>每个键值对需要用@Part来注解键名，随后的对象需要提供值。 </p><p>@Streaming</p><p>如果下载一个非常大的文件，Retrofit会试图将整个文件读进内存。为了避免这种现象的发生，我们添加了一个特殊的注解来声明请求。</p><p>声明@Streaming并不是意味着你需要观察一个Netflix文件。它意味着立刻传递字节码，而不需要把整个文件读进内存。值得注意的是，如果你使用了@Streaming，并且依然使用以上的代码片段来进行处理。Android将会抛出android.os.NetworkOnMainThreadException异常。</p><pre><code class="java">/** * {@link FormUrlEncoded} 表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded） * &lt;code&gt;Field(&quot;username&quot;)&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值 */@POST(&quot;/form&quot;)@FormUrlEncodedCall&lt;ResponseBody&gt; testFormUrlEncoded1(@Field(&quot;username&quot;) String name, @Field(&quot;age&quot;) int age);/** * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型 * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)， */@POST(&quot;/form&quot;)@MultipartCall&lt;ResponseBody&gt; testFileUpload1(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;age&quot;) RequestBody age, @Part MultipartBody.Part file);</code></pre><h3 id="网络请求参数"><a href="#网络请求参数" class="headerlink" title="网络请求参数"></a>网络请求参数</h3><p><img src="http://dengw.xyz/hexo-blog/180331/mbLCdbcdId.png" alt="参数类注解"></p><ul><li>@Header &amp; @Headers</li></ul><p>开始这部分内容之前可以先了解一下Http的请求头。</p><blockquote><p>作用：添加请求头 &amp;添加不固定的请求头</p></blockquote><pre><code class="java">// @Header@GET(&quot;user&quot;)Call&lt;User&gt; getUser(@Header(&quot;Authorization&quot;) String authorization)// @Headers@Headers(&quot;Authorization: authorization&quot;)@GET(&quot;user&quot;)Call&lt;User&gt; getUser()// 以上的效果是一致的。// 区别在于使用场景和使用方式// 1. 使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头// 2. 使用方式：@Header作用于方法的参数；@Headers作用于方法</code></pre><ul><li>@Body</li></ul><blockquote><p>作用：以 Post方式 传递 自定义数据类型 给服务器<br>特别注意：如果提交的是一个Map，那么作用相当于 @Field </p></blockquote><pre><code class="java">@POST(&quot;blog&quot;)Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);</code></pre><p>被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。</p><p>具体使用：</p><pre><code class="java">BlogService service = retrofit.create(BlogService.class);Blog blog = new Blog();blog.content = &quot;新建的Blog&quot;;blog.title = &quot;测试&quot;;blog.author = &quot;怪盗kidou&quot;;Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);</code></pre><p>服务器收到的数据：</p><pre><code class="java">Result{code=200, msg=&#39;OK&#39;, data=Blog{id=20, date=&#39;2016-04-21 05:29:58&#39;, author=&#39;怪盗kidou&#39;, title=&#39;测试&#39;, content=&#39;新建的Blog&#39;}, count=0, page=0}</code></pre><ul><li>@Field &amp; @FieldMap<blockquote><p>作用：发送 Post请求 时提交请求的表单字段<br>具体使用：与 @FormUrlEncoded 注解配合使用</p></blockquote></li></ul><pre><code class="java">public interface GetRequest_Interface {    /**     *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）     * &lt;code&gt;Field(&quot;username&quot;)&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值     */    @POST(&quot;/form&quot;)    @FormUrlEncoded    Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field(&quot;username&quot;) String name, @Field(&quot;age&quot;) int age);    /**      * Map的key作为表单的键      */    @POST(&quot;/form&quot;)    @FormUrlEncoded    Call&lt;ResponseBody&gt; testFormUrlEncoded2(@FieldMap Map&lt;String, Object&gt; map);}// 具体使用    // @Field    Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(&quot;Carson&quot;, 24);    // @FieldMap    // 实现的效果与上面相同，但要传入Map    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;username&quot;, &quot;Carson&quot;);    map.put(&quot;age&quot;, 24);    Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map);</code></pre><ul><li>@Part &amp; @PartMap<blockquote><p>作用：发送 Post请求 时提交请求的表单字段<br>与@Field的区别：功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于 有文件上传 的场景</p></blockquote></li></ul><p>具体使用：与 @Multipart 注解配合使用</p><pre><code class="java">public interface GetRequest_Interface {    /**     * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型     * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，     */    @POST(&quot;/form&quot;)    @Multipart    Call&lt;ResponseBody&gt; testFileUpload1(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;age&quot;) RequestBody age, @Part MultipartBody.Part file);    /**     * PartMap 注解支持一个Map作为参数，支持 {@link RequestBody } 类型，     * 如果有其它的类型，会被{@link retrofit2.Converter}转换，如后面会介绍的 使用{@link com.google.gson.Gson} 的 {@link retrofit2.converter.gson.GsonRequestBodyConverter}     * 所以{@link MultipartBody.Part} 就不适用了,所以文件只能用&lt;b&gt; @Part MultipartBody.Part &lt;/b&gt;     */    @POST(&quot;/form&quot;)    @Multipart    Call&lt;ResponseBody&gt; testFileUpload2(@PartMap Map&lt;String, RequestBody&gt; args, @Part MultipartBody.Part file);    @POST(&quot;/form&quot;)    @Multipart    Call&lt;ResponseBody&gt; testFileUpload3(@PartMap Map&lt;String, RequestBody&gt; args);}    // 具体使用    MediaType textType = MediaType.parse(&quot;text/plain&quot;);    RequestBody name = RequestBody.create(textType, &quot;Carson&quot;);    RequestBody age = RequestBody.create(textType, &quot;24&quot;);    RequestBody file = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), &quot;这里是模拟文件的内容&quot;);    // @Part    MultipartBody.Part filePart = MultipartBody.Part.createFormData(&quot;file&quot;, &quot;test.txt&quot;, file);    Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);    ResponseBodyPrinter.printResponseBody(call3);    // @PartMap    // 实现和上面同样的效果    Map&lt;String, RequestBody&gt; fileUpload2Args = new HashMap&lt;&gt;();    fileUpload2Args.put(&quot;name&quot;, name);    fileUpload2Args.put(&quot;age&quot;, age);    //这里并不会被当成文件，因为没有文件名(包含在Content-Disposition请求头中)，但上面的 filePart 有    //fileUpload2Args.put(&quot;file&quot;, file);    Call&lt;ResponseBody&gt; call4 = service.testFileUpload2(fileUpload2Args, filePart); //单独处理文件    ResponseBodyPrinter.printResponseBody(call4);</code></pre><ul><li>@Query和@QueryMap<blockquote><p>作用：用于 @GET 方法的查询参数（Query = Url 中 ‘?’ 后面的 key-value）</p></blockquote></li></ul><p>具体使用：配置时只需要在接口方法中增加一个参数即可：</p><pre><code class="java">//url = http://www.println.net/?cate=android，其中，Query = cate@GET(&quot;/&quot;)    Call&lt;String&gt; cate(@Query(&quot;cate&quot;) String cate);</code></pre><ul><li>@Path<blockquote><p>作用：URL地址的缺省值</p></blockquote></li></ul><p>具体使用：</p><pre><code class="java">public interface GetRequest_Interface {    @GET(&quot;users/{user}/repos&quot;)    Call&lt;ResponseBody&gt;  getBlog（@Path(&quot;user&quot;) String user ）;    // 访问的API是：https://api.github.com/users/{user}/repos    // 在发起请求时， {user} 会被替换为方法的第一个参数 user（被@Path注解作用） }</code></pre><ul><li>@Url</li></ul><blockquote><p>作用：直接传入一个请求的 URL变量 用于URL设置</p></blockquote><p>具体使用：</p><pre><code class="java">public interface GetRequest_Interface {    @GET    Call&lt;ResponseBody&gt; testUrlAndQuery(@Url String url, @Query(&quot;showAll&quot;) boolean showAll);    // 当有URL注解时，@GET传入的URL就可以省略    // 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供}</code></pre><h2 id="创建Retrofit-实例"><a href="#创建Retrofit-实例" class="headerlink" title="创建Retrofit 实例"></a>创建Retrofit 实例</h2><p>在这一步中也有很多需要注意的地方。</p><h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><p>前面已经提到，Retrofit2.0中会自动使用OkHttp实现HTTP连接，所以没有特殊需求的话，可以向下面这样很快的创建一个Retrofit 实例：</p><pre><code class="java">Retrofit retrofit = new Retrofit.Builder()    .baseUrl(&quot;https://api.github.com&quot;)    .addConverterFactory(GsonConverterFactory.create())    .build();</code></pre><p>但是当你需要进行一些特殊化处理的时候，比如cookie的设置、网络超时的设置、请求header设置等，这个时候我们就需要自己先配置好好OkHttpClient然后手动地设置Retrofit 的Client。</p><pre><code class="java">//先配置好一个OkHttpClientOkHttpClient okHttpClient = new OkHttpClient.Builder()              .connectTimeout(5*1000, TimeUnit.MILLISECONDS) //链接超时              .readTimeout(10*1000,TimeUnit.MILLISECONDS) //读取超时              .writeTimeout(10*1000,TimeUnit.MILLISECONDS) //写入超时              .addInterceptor(new HttpHeadInterceptor()) //应用拦截器：统一添加消息头              .addNetworkInterceptor(new NetworkspaceInterceptor())//网络拦截器              .addInterceptor(loggingInterceptor)//应用拦截器：打印日志              .cache(cache)  //设置缓存              .build();retrofit = new Retrofit.Builder()        .baseUrl(baseUrl)         .addConverterFactory(GsonConverterFactory.create())        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())         .client(okHttpClient)                      //设置配置好的OkHttpClient为Retrofit的Client         .build();</code></pre><p><strong>NOTE：</strong>具体可配置参数见<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.Builder.html" target="_blank" rel="noopener">OkHttpClient.Builder</a>类。</p><h3 id="数据解析器（Converter）"><a href="#数据解析器（Converter）" class="headerlink" title="数据解析器（Converter）"></a>数据解析器（Converter）</h3><p>Retrofit2.0 支持多种数据解析方式，官方给了下面几种解析器，根据自己需要选择。</p><table><thead><tr><th>数据解析器</th><th>Gradle依赖</th></tr></thead><tbody><tr><td><a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a></td><td>com.squareup.retrofit2:converter-gson</td></tr><tr><td><a href="http://wiki.fasterxml.com/JacksonHome" target="_blank" rel="noopener">Jackson</a></td><td>com.squareup.retrofit2:converter-jackson</td></tr><tr><td><a href="https://github.com/square/moshi/" target="_blank" rel="noopener">Mossi</a></td><td>com.squareup.retrofit2:converter-moshi</td></tr><tr><td><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protobuf</a></td><td>com.squareup.retrofit2:converter-protobuf</td></tr><tr><td><a href="https://github.com/square/wire" target="_blank" rel="noopener">Wire</a></td><td>com.squareup.retrofit2:converter-wire</td></tr><tr><td><a href="http://simple.sourceforge.net/" target="_blank" rel="noopener">Simple XML</a></td><td>com.squareup.retrofit2:converter-simplexml</td></tr><tr><td>Scalars (primitives, boxed, and String)</td><td>com.squareup.retrofit2:converter-scalars</td></tr></tbody></table><p><strong>注</strong>：上述依赖中还需要在后面添加特定的版本号。</p><h3 id="网络请求适配器（CallAdapter）"><a href="#网络请求适配器（CallAdapter）" class="headerlink" title="网络请求适配器（CallAdapter）"></a>网络请求适配器（CallAdapter）</h3><blockquote><p>使用时如使用的是 Android 默认的 CallAdapter，则不需要添加网络请求适配器的依赖，否则则需要按照需求进行添加 </p></blockquote><p>Retrofit2.0 除了默认的 CallAdapter外，还支持多种网络请求适配器方式：guava、Java8和 rxjava<br>不过我就只用过RxJava，这应该是Retrofit名气最大的适配器，确实非常好用，多好用呢？自己去感受一下。关于RxJava的使用也有很多是要学习的，这里帖两篇很好的博客。<br><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a><br><a href="https://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="noopener">RxJava 与 Retrofit 结合的最佳实践</a></p><h3 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h3><p>Retrofit 2.0发送网络请求有两种方法，同步和异步。我们在Retrofit 2.0 和Retrofit 1.0的差别中有介绍到，Retrofit 2.0不管是使用同步还是使用异步的方法，都是同一个函数接口，这一点相比Retrofit 1.0，省去不少功夫，具体的调用方法如下：</p><pre><code class="java">// 发送网络请求（同步）Response&lt;Reception&gt; response = call.execute();//发送网络请求(异步)call.enqueue(new Callback&lt;Translation&gt;() {      //请求成功时回调      @Override      public void onResponse(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response) {        //请求处理,输出结果    }    //请求失败时候的回调    @Override    public void onFailure(Call&lt;Translation&gt; call, Throwable throwable) {      }});</code></pre><p><strong>注</strong>：本文大部分内容来自<a href="https://blog.csdn.net/carson_ho/article/details/73732076" target="_blank" rel="noopener"> 这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a>，我写出来主要是为了加深自己的印象，作为个人博客能够好好系统总结一下，并结合自己理解对内容作了部分修改。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Retrofit </tag>
            
            <tag> 网络框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit2.0完全解读（二）</title>
      <link href="/2018/03/22/Retrofit2.0%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/03/22/Retrofit2.0%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在了解了Retrofit 2.0 和Retrofit 1.0的主要差别后，我们就要开始深入的学习Retrofit 2.0 了。个人觉得在Android学习中，刚接触到一个新的东西，还是要先了解具体是怎么使用的，而不是一开始就抱着源码啃。这种学习方法我觉得太抽象了，特别是对应用性比较强的技术。除非你之前接触过类型的东西，其原理在某些方面很相似，能够帮助理解，不然的话会很难理解原理的。当然这都是个人看法，只是这种方法对我来说效率更高，下面就结合实例讲一下Retrofit 2.0 的使用方法。</p><h2 id="Retrofit-2-0-快速使用"><a href="#Retrofit-2-0-快速使用" class="headerlink" title="Retrofit 2.0 快速使用"></a>Retrofit 2.0 快速使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在前面我们介绍到Retrofit2.0 是一个基于OKHttp的具有RESTful API风格的 HTTP 网络请求框架的封装，网络请求的本质是 OkHttp 完成的，Retrofit 2.0仅负责网络请求接口的封装。使用Retrofit2.0框架访问网络的具体过程如下：</p><p><img src="http://dengw.xyz/hexo-blog/180323/mba6hhI8ki.png" alt=""></p><ul><li>App应用程序通过 Retrofit 访问网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作。</li><li>在服务端返回数据之后，OkHttp 将原始的结果交给 Retrofit，Retrofit根据用户的需求对结果进行解析</li></ul><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>使用Retrofit 2.0主要包括以下几个步骤：</p><blockquote><p>step1：添加Retrofit库的依赖<br> step2：创建 接收服务器返回数据 的类<br> step3：创建 用于描述网络请求 的接口<br> step4：创建 Retrofit 实例<br> step5：创建 网络请求接口实例 并 配置网络请求参数<br> step6：发送网络请求（异步 / 同步）<br> step7：处理服务器返回的数据</p></blockquote><p>下面我们就结合实例一步一步的实现:</p><p><strong>实例</strong>：使用Retrofit 2.0获取Github用户信息，输入uesername返回该用户的个人信息。<br><strong>相关API：</strong> <a href="https://api.github.com/users/username" target="_blank" rel="noopener">https://api.github.com/users/username</a></p><h4 id="step1：添加Retrofit库的依赖"><a href="#step1：添加Retrofit库的依赖" class="headerlink" title="step1：添加Retrofit库的依赖"></a>step1：添加Retrofit库的依赖</h4><p>在<code>src</code>目录下的<code>build.gradle</code>中添加Retrofit库的依赖，一般也把RxJava和Gson的依赖也加上，因为基本上都会用到。</p><pre><code>dependencies {    ...    implementation &#39;com.squareup.retrofit2:retrofit:2.3.0&#39;    implementation &#39;com.squareup.retrofit2:adapter-rxjava:2.3.0&#39;    implementation &#39;com.squareup.retrofit2:converter-gson:2.3.0&#39;}</code></pre><p>添加网络权限 ，因为涉及到网络访问，肯定要添加网络的权限。</p><p>在AndroidManifest.xml文件中</p><pre><code class="stylus">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</code></pre><h4 id="step2-定义接收服务器返回数据的Model类"><a href="#step2-定义接收服务器返回数据的Model类" class="headerlink" title="step2 定义接收服务器返回数据的Model类"></a>step2 定义接收服务器返回数据的Model类</h4><p>在定义Model类之前，需要先确定的希望获取的数据格式。<br>比如我们访问 <a href="https://api.github.com/users/duang0626" target="_blank" rel="noopener">https://api.github.com/users/duang0626</a> ，返回的信息如下：</p><pre><code class="stylus">{  &quot;login&quot;: &quot;duang0626&quot;,  &quot;id&quot;: 15682310,  &quot;avatar_url&quot;: &quot;https://avatars3.githubusercontent.com/u/15682310?v=4&quot;,  &quot;gravatar_id&quot;: &quot;&quot;,  &quot;url&quot;: &quot;https://api.github.com/users/duang0626&quot;,  &quot;html_url&quot;: &quot;https://github.com/duang0626&quot;,  &quot;followers_url&quot;: &quot;https://api.github.com/users/duang0626/followers&quot;,  &quot;following_url&quot;: &quot;https://api.github.com/users/duang0626/following{/other_user}&quot;,  &quot;gists_url&quot;: &quot;https://api.github.com/users/duang0626/gists{/gist_id}&quot;,  &quot;starred_url&quot;: &quot;https://api.github.com/users/duang0626/starred{/owner}{/repo}&quot;,  &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/duang0626/subscriptions&quot;,  &quot;organizations_url&quot;: &quot;https://api.github.com/users/duang0626/orgs&quot;,  &quot;repos_url&quot;: &quot;https://api.github.com/users/duang0626/repos&quot;,  &quot;events_url&quot;: &quot;https://api.github.com/users/duang0626/events{/privacy}&quot;,  &quot;received_events_url&quot;: &quot;https://api.github.com/users/duang0626/received_events&quot;,  &quot;type&quot;: &quot;User&quot;,  &quot;site_admin&quot;: false,  &quot;name&quot;: &quot;Dengw&quot;,  &quot;company&quot;: null,  &quot;blog&quot;: &quot;&quot;,  &quot;location&quot;: &quot;GuangZhou China&quot;,  &quot;email&quot;: null,  &quot;hireable&quot;: null,  &quot;bio&quot;: &quot;A software engineering student&quot;,  &quot;public_repos&quot;: 27,  &quot;public_gists&quot;: 0,  &quot;followers&quot;: 2,  &quot;following&quot;: 4,  &quot;created_at&quot;: &quot;2015-11-06T03:17:19Z&quot;,  &quot;updated_at&quot;: &quot;2018-03-09T17:15:32Z&quot;}</code></pre><p>假如我们只需要显示查询user的login, id, name这三个字段的话，那我们就可以像下面这样定义Model类，根据自己的需要设置就好。</p><pre><code class="java">public class User {    private String login;    private String id;    private String name;    public String getLogin() {        return login;    }    public void setLogin(String login) {        this.login = login;    }    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><h3 id="step3-创建-用于描述网络请求-的接口"><a href="#step3-创建-用于描述网络请求-的接口" class="headerlink" title="step3 创建 用于描述网络请求 的接口"></a>step3 创建 用于描述网络请求 的接口</h3><p>Retrofit将 Http请求 抽象成 Java接口：采用 注解 描述网络请求参数 和配置网络请求参数 。</p><blockquote><p>用动态代理动态将该接口的注解“翻译”成一个 Http 请求，最后再执行 Http 请求<br>接口中的每个方法的参数都需要使用注解标注，否则会报错</p></blockquote><p>自定义接口，根据Retrofit 2.0规范定义方法</p><pre><code class="java">public interface GitHubService {    /*     *@GET注解的作用:采用Get方法发送网络请求     * getUser() 接收网络请求数据的方法     * 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的User类）     *  @Path(&quot;user&quot;) String user 方法参数     */    @GET(&quot;users/{user}&quot;)    Call&lt;User&gt; getUser(@Path(&quot;user&quot;) String user);}</code></pre><h3 id="step4-创建-Retrofit-实例"><a href="#step4-创建-Retrofit-实例" class="headerlink" title="step4 创建 Retrofit 实例"></a>step4 创建 Retrofit 实例</h3><pre><code class="java">String baseUrl = &quot;https://api.github.com/&quot;;Retrofit retrofit = new Retrofit.Builder()    .baseUrl(baseUrl)   //Url的base地址    .addConverterFactory(GsonConverterFactory.create())  // 设置数据解析器    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())  // 支持RxJava    .build();</code></pre><h3 id="step5-创建网络请求接口实例"><a href="#step5-创建网络请求接口实例" class="headerlink" title="step5 创建网络请求接口实例"></a>step5 创建网络请求接口实例</h3><pre><code class="java">GitHubService request = retrofit.create(GitHubService.class);</code></pre><h3 id="step6-发送网络请求"><a href="#step6-发送网络请求" class="headerlink" title="step6 发送网络请求"></a>step6 发送网络请求</h3><pre><code class="java">Call&lt;User&gt; call = request.getUser();call.enqueue(new Callback&lt;User&gt;() {    @Override    public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) {        //请求成功,处理返回结果    }    @Override    public void onFailure(Call&lt;User&gt; call, Throwable t) {        //请求失败时调用    }});</code></pre><h3 id="step7-处理返回数据"><a href="#step7-处理返回数据" class="headerlink" title="step7 处理返回数据"></a>step7 处理返回数据</h3><p>处理数据的步骤就根据自己的需要在 reponse 提取返回的数据，如果按照我们上面那样方式发送请求。在onResponse函数返回的参数reponse.Body()就是一个我们之前自己定义User类，要读取User信息直接使用相应的get函数即可获取。</p><pre><code class="java"> public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) {     Map&lt;String, Object&gt; tem = new LinkedHashMap&lt;&gt;();     tem.put(&quot;name&quot;, response.body().getLogin());     tem.put(&quot;id&quot;, &quot;id: &quot; + response.body().getId());     tem.put(&quot;name&quot;,&quot;name: &quot; + response.body().getName());     userList.add(tem);     cardAdapter.notifyItemInserted(userList.size() - 1); }</code></pre><p>结果显示如下：</p><p><img src="http://dengw.xyz/hexo-blog/180323/d0HdE5Eh7k.png" alt=""></p><p>Retrofit 2.0的快速使用就介绍到这儿了，通过上面介绍的方法就可以使用Retrofit 2.0访问网络了。相信你也看到了，这个过程中的一些参数可能重来都没有见过，下一篇文章就将介绍Retrofit 2.0使用的一些细节，参数的设置，具体的含义。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Retrofit </tag>
            
            <tag> 网络框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>华为2018年春招在线笔试题</title>
      <link href="/2018/03/18/%E5%8D%8E%E4%B8%BA2018%E5%B9%B4%E6%98%A5%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2018/03/18/%E5%8D%8E%E4%B8%BA2018%E5%B9%B4%E6%98%A5%E6%8B%9B%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>既然励志成为技术大拿，一个很重要的点就是要学会记录，学会总结，学会分享。趁着还热乎，现在就分享一下今天晚上刚参加完的华为笔试吧。</p><h3 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h3><blockquote><p>问题的描述很简单，就是实现两个带符号大数的乘法。具体的思路如下：<br>因为涉及到大数，所以肯定不能够使用常规的运算方法，即使使用 long long类型的数据还是会超出其表示范围。一种可行的方法就是使用字符串来表示一串数字，然后自己来通过字符操作来实现乘法的具体的过程：一个数的每一位分别乘以另外一个数，在乘的过程中注意移位的变化，最后再将所有的中间结果按照正确的位置相加得到最后的结果。其实就是我们将我们小学数学乘法的过程化，hahaha……但是这样算法的事件复杂度比较高，刚刚看网上有时间复杂度为O(lgn)的方法.</p></blockquote><pre><code class="cpp">#include &lt;iostream&gt;                                                                                                                          #include &lt;string&gt;using namespace std;string  Large_Multiplication(string str1, string str2) {    int len1 = str1.length();    int len2 = str2.length();    /*     *两个数A和B，A的位数为m，B的位数为n，     *则乘积结果要么为 m+n-1位（最高位无进位）或者为 m+n位（最高位有进位）     */    string re(len1 + len2, &#39;0&#39;);    //使用第二个数的每一位乘以第一个数得到中间结果    for(int i = len2 - 1;  i &gt;= 0; i--) {        int carry_pre = 0;  //每一位的乘法中向下一位的进位        int carry_add = 0;  //计算中间和时向下一位的进位        for(int j = len1 - 1; j &gt;= 0; j--) {            int num = (str2[i] - &#39;0&#39;) * (str1[j] - &#39;0&#39;) + carry_pre;            carry_pre = num / 10;            num %= 10;            //计算竖向中间和，填充结果的i+j+1位            int sum = (re[i+j+1] - &#39;0&#39;) + num + carry_add;            re[i+j+1] = sum % 10 + &#39;0&#39;;            carry_add = sum / 10;        }        re[i] += carry_add + carry_pre;  //处理进位    }    if(re[0] == &#39;0&#39;) {  //判断乘积的位数        re = re.substr(1);    }    return re;}int main() {    string num1, num2;    cin&gt;&gt;num1&gt;&gt;num2;    if(num1[0] == &#39;0&#39; || num2[0] == &#39;0&#39;) {        cout&lt;&lt;0&lt;&lt;endl;    }    else {        int sign1 = 1, sign2 = 1;  //记录两个数的正负号        string a, b;   //a, b参数用于去符号乘法        if(num1[0] == &#39;-&#39;) {            sign1 = -1;            a = num1.substr(1);        } else  {            a = num1;        }        if(num2[0] == &#39;-&#39;) {            sign2 = -1;            b = num2.substr(1);        } else {            b= num2;        }        string product = Large_Multiplication(a, b);        if(sign1 * sign2 == -1) product = &quot;-&quot; + product;        cout&lt;&lt;product&lt;&lt;endl;    }    return 0;}</code></pre><p>另外一种思路：上面一种思路主要是面上过程化，需要注意的细节更多。下面这种思路更过的是面向结果，不要考虑那么多细节，要更简单一点，传入的参数还是要先把符号处理了。</p><pre><code class="cpp">vector&lt;int&gt; Large_Multiplication(string num1, string num2) {    int len1 = num1.length();    int len2 = num2.length();    vector&lt;int&gt; re (len1 + len2, 0);    for(int i = len2 - 1; i &gt;= 0; i--) {        for(int j = len1 - 1; j &gt;= 0; j--) {            re[i + j + 1] += (num2[i] - &#39;0&#39;) * (num1[j] - &#39;0&#39;);        }    }    int carry = 0;    for(int i = re.size() - 1; i &gt;= 0; i--) {        int sum = re[i] + carry;        carry = sum / 10;        re[i] = sum % 10;    }    return re;}</code></pre><p>这道题按到来说应该不难，但是上次做大数的运算应该还是大一的时候了，在那之后就没遇到过了，在准备数据结构和算法的时候也没注意到这个部分，完全没有准备，所以还是花了挺多时间的。这也说明了一个问题，还是自己做的题太少了，对于知识点的掌握不好，再加上理解的不够深刻，所以很难想到解决方法。后来在自己试了一下大数加法之后才摸索+回忆起大数乘法的算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit 2.0 完全解读（一）</title>
      <link href="/2018/03/10/Retrofit2.0%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/03/10/Retrofit2.0%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Retrofit 是Square公司生产的一款基于OkHttp的，遵循RESTful API设计风格的开源网络请求库，目前也是Android领域最热门请求库。<br>Retrofit 通过注解配置网络请求参数，包括请求参数，请求方法，请求头以及返回参数等。并且支持同步、异步的网络请求方式。通过搭配多种多种Converter支持多种数据解析方式 &amp; 序列化方式，包括：Gson, Json, XML, Protobuf。此外还提供对RxJava的支持。功能可以说是十分的强大。<br>现在自己正在学习Retrofit 2.0，再加上为面试准备一下，所以希望通过总结一下Retrofit 2.0来加深自己的理解，更加深入地学习一下。如果这系列文章能够帮助他人来理解Retrofit 2.0的话，那就可以说是很开心了，超额完成任务。</p><h2 id="Retrofit-1-0-和-Retrofit-2-0的差别"><a href="#Retrofit-1-0-和-Retrofit-2-0的差别" class="headerlink" title="Retrofit 1.0 和 Retrofit 2.0的差别"></a>Retrofit 1.0 和 Retrofit 2.0的差别</h2><p>在介绍Retrofit 2.0之前呢，不知道大家有没有这样的疑问。在网上搜索Retrofit几乎都是关于Retrofit2.0的介绍，关于Retrofit之前的版本1.0介绍的很少。我这个人有这样的习惯，在接触一个新的东西，如果对你之前先关的一无所知的话，心里会很不踏实。新的版本一般都是对之前版本的一个改进优化，了解一下老版本就很够很好的帮助我们理解新版本的一些特性，影响也更深刻。如果你也没有这样的想法的话，那么希望这篇文章能够给你解除部分疑惑，做到心里有底。</p><h3 id="包的引用方式"><a href="#包的引用方式" class="headerlink" title="包的引用方式"></a>包的引用方式</h3><p>包的引用方式没变，只是需要改变了一下版本号，使用哪个版本就添加哪一个版本号。将你项目中app目录下的build文件中Retrofit依赖一行的版本号改为对应的版本，然后点击右上角的 <code>sync now</code>同步一下就可以使用了。</p><pre><code class="java">compile &#39;com.squareup.retrofit2:retrofit:2.0.0&#39;</code></pre><h3 id="同步和异步定义以及执行方式"><a href="#同步和异步定义以及执行方式" class="headerlink" title="同步和异步定义以及执行方式"></a>同步和异步定义以及执行方式</h3><p>Retrofit1.0版本中，如果你想定义一个同步或者异步函数，你应该这样定义：</p><pre><code class="java">/* * 具有返回值的函数为同步执行的。 */@GET(&quot;/user/{id}/photo&quot;)Photo listUsers(@Path(&quot;id&quot;)  int id);/** 而异步执行函数没有返回值并且要求函数最后一个参数为Callback对象*/@GET(&quot;/user/{id}/photo&quot;)void listUsers(@Path(&quot;id&quot;) int id, Callback cb);</code></pre><p>在Retrofit 2.0上，只需定义一个模式，因此要简单得多。</p><pre><code>/** 定义*/@POST(&quot;/list&quot;)Call loadRepo();/** 同步调用*/Call call=service.loadRepo();Repo repo=call.execute();/** 异步调用*/Call call=service.loadRepo();call.enqueue(new Callback() {    @Override    public void onResponse(Response response){    }    @Override    public void onFailure(Throwable t) {    }});</code></pre><h3 id="取消正在进行的网络任务"><a href="#取消正在进行的网络任务" class="headerlink" title="取消正在进行的网络任务"></a>取消正在进行的网络任务</h3><p> Retrofit1对正在进行的网络任务无法取消，如果你想做这件事必须手动杀死，而这并不好实现。而Retrofit2接口的定时形式变化，正是为了解决这个问题。要做到这点，你只需要调用call.cancel即可.</p><h3 id="Converter现在从Retrofit中删除Retrofit1中的setConverter，在2-0中换以addConverterFactory，用于支持Gson转换。"><a href="#Converter现在从Retrofit中删除Retrofit1中的setConverter，在2-0中换以addConverterFactory，用于支持Gson转换。" class="headerlink" title="Converter现在从Retrofit中删除Retrofit1中的setConverter，在2.0中换以addConverterFactory，用于支持Gson转换。"></a>Converter现在从Retrofit中删除Retrofit1中的setConverter，在2.0中换以addConverterFactory，用于支持Gson转换。</h3><p>在Retrofit 1.9中，GsonConverter 包含在了package 中而且自动在RestAdapter创建的时候被初始化。这样来自服务器的son结果会自动解析成定义好了的Data Access Object（DAO）<br>但是在Retrofit 2.0中，Converter 不再包含在package 中了。你需要自己插入一个Converter 不然的话Retrofit 只能接收字符串结果。同样的，Retrofit 2.0也不再依赖于Gson 。</p><p>如果你想接收json 结果并解析成DAO，你必须把Gson Converter 作为一个独立的依赖添加进来。</p><pre><code class="stylus">compile &#39;com.squareup.retrofit:converter-gson:2.1.0&#39;</code></pre><p>然后使用addConverterFactory把它添加进来。注意RestAdapter的别名仍然为Retrofit。</p><pre><code class="stylus">Retrofit retrofit = new Retrofit.Builder()            .baseUrl(&quot;http://api.nuuneoi.com/base/&quot;)            .addConverterFactory(GsonConverterFactory.create())            .build();</code></pre><h3 id="自定义Gson对象"><a href="#自定义Gson对象" class="headerlink" title="自定义Gson对象"></a>自定义Gson对象</h3><p> 为了以防你需要调整json里面的一些格式，比如，Date Format。你可以创建一个Gson 对象并把它传递给GsonConverterFactory.create()。</p><pre><code class="stylus">Gson gson = new GsonBuilder()        .setDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ&quot;)        .create();Retrofit retrofit = new Retrofit.Builder()        .baseUrl(&quot;http://api.nuuneoi.com/base/&quot;)        .addConverterFactory(GsonConverterFactory.create(gson))        .build();</code></pre><h3 id="新的URL定义方式"><a href="#新的URL定义方式" class="headerlink" title="新的URL定义方式"></a>新的URL定义方式</h3><p>对于 Retrofit 2.0中新的URL定义方式，建议：</p><ul><li><p>Base URL: 总是以 /结尾</p></li><li><p>@Url: 不要以 / 开头</p><p>而且在Retrofit 2.0中我们还可以在@Url里面定义完整的URL, 这种情况下Base URL会被忽略。</p></li></ul><pre><code class="stylus">@POST(&quot;http://api.nuuneoi.com/special/user/list&quot;)Call loadSpecialUsers();</code></pre><p>可以看到在URL的处理方式上发生了很大变化。它和前面的版本完全不同。如果你想把代码迁移到Retrofit 2.0，别忘了修正URL部分的代码。</p><h3 id="即使response存在问题onResponse依然被调用"><a href="#即使response存在问题onResponse依然被调用" class="headerlink" title="即使response存在问题onResponse依然被调用"></a>即使response存在问题onResponse依然被调用</h3><p>在Retrofit 1.9中，如果获取的 response 不能背解析成定义好的对象，则会调用failure。但是在Retrofit 2.0中，不管 response 是否能被解析。onResponse总是会被调用。但是在结果不能被解析的情况下，response.body()会返回null。所以使用的时候别忘了处理这种情况。</p><p>如果response存在什么问题，比如404什么的，onResponse也会被调用。你可以从response.errorBody().string()中获取错误信息的主体。</p><h3 id="缺少INTERNET权限会导致SecurityException异常"><a href="#缺少INTERNET权限会导致SecurityException异常" class="headerlink" title="缺少INTERNET权限会导致SecurityException异常"></a>缺少INTERNET权限会导致SecurityException异常</h3><p>在Retrofit 1.9中，如果你忘记在AndroidManifest.xml文件中添加INTERNET权限。异步请求会直接进入failure回调方法，得到PERMISSION DENIED 错误消息。没有任何异常被抛出。<br>但是在Retrofit 2.0中，当你调用call.enqueue或者call.execute，将立即抛出SecurityException，如果你不使用try-catch会导致崩溃。</p><h3 id="Use-an-Interceptor-from-OkHttp"><a href="#Use-an-Interceptor-from-OkHttp" class="headerlink" title="Use an Interceptor from OkHttp"></a>Use an Interceptor from OkHttp</h3><p>在Retrofit 1.9中，你可以使用RequestInterceptor来拦截一个请求，但是它已经从Retrofit 2.0 移除了，因为HTTP连接层已经转为OkHttp。<br>结果就是，现在我们必须转而使用OkHttp里面的Interceptor。首先你需要使用Interceptor创建一个OkHttpClient对象，通常的应用时用于拦截OkHttp日志。</p><pre><code class="stylus">HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);client = new OkHttpClient.Builder()            .addInterceptor(interceptor)            .retryOnConnectionFailure(true)            .connectTimeout(15, TimeUnit.SECONDS)            .addNetworkInterceptor(authorizationInterceptor)            .build();</code></pre><p> 然后传递创建的client到Retrofit的Builder链中。</p><pre><code class="stylus">Retrofit retrofit = new Retrofit.Builder()            .baseUrl(&quot;http://api.nuuneoi.com/base/&quot;)            .addConverterFactory(GsonConverterFactory.create())            .client(client)            .build();</code></pre><h3 id="RxJava-Integration-with-CallAdapter"><a href="#RxJava-Integration-with-CallAdapter" class="headerlink" title="RxJava Integration with CallAdapter"></a>RxJava Integration with CallAdapter</h3><p>  RxJava准备的CallAdapter，它将作为Observable返回。要使用它，你的项目依赖中必须包含两个modules。</p><pre><code class="stylus">compile &#39;io.reactivex:rxandroid:1.2.1&#39;compile &#39;com.squareup.retrofit:adapter-rxjava:2.1.0&#39;</code></pre><p> Gradle并在Retrofit Builder链表中如下调用addCallAdapterFactory：</p><pre><code class="stylus">Retrofit retrofit = new Retrofit.Builder()            .baseUrl(&quot;http://api.nuuneoi.com/base/&quot;)            .addConverterFactory(GsonConverterFactory.create())            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())            .build();Observable observable=service.loadDessertListRx();</code></pre><p>可能还有一些issues本文没有提到，更多的完整的变化可以去官方的<a href="https://github.com/square/retrofit/blob/master/CHANGELOG.md" target="_blank" rel="noopener">Change Log </a>查看，对于每个版本的变化都有详细的讲解。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Retrofit </tag>
            
            <tag> 网络框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>捋一捋Java中关系复杂的容器</title>
      <link href="/2018/03/08/%E6%8D%8B%E4%B8%80%E6%8D%8BJava%E4%B8%AD%E5%85%B3%E7%B3%BB%E5%A4%8D%E6%9D%82%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/03/08/%E6%8D%8B%E4%B8%80%E6%8D%8BJava%E4%B8%AD%E5%85%B3%E7%B3%BB%E5%A4%8D%E6%9D%82%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>上个学期在学习Android的时候接触了很多Java的容器类，比如ArrayList HashMap等等。这段时间准备找一个Android相关的实习，因为之前没有学习过java，所以着重复习了一下Java的基础。在学习J2SE容器相关部分的时候就惊呆了，相比c++,Java的容器太多了! 每种容器也有很多特性，为了不翻船，就觉得很有必要对Java一些常用到的容器总结一下，了解各种容器的特性，把一些容器横向对比，加深印象，帮助理解。</p><h2 id="常用容器类及其继承关系"><a href="#常用容器类及其继承关系" class="headerlink" title="常用容器类及其继承关系"></a>常用容器类及其继承关系</h2><p>先上图，原图片链接：<a href="http://pierrchen.blogspot.com/2014/03/java-collections-framework-cheat-sheet.html" target="_blank" rel="noopener">Java Collections Framework Cheat Sheet</a></p><p><img src="http://dengw.xyz/hexo-blog/180330/j4a9Hl940J.PNG" alt="Java Collections Framework Cheat Sheet"></p><p>这张图真是总结的太好了，几乎把我想说的都表达了出来，容器是类还是接口，容器之间的继承关系，底层的实现方式，容器的特性在这张图上都可以很清楚的知道。</p><ul><li>图中实线代表继承了这个类，虚线代表实现了这个接口。</li><li>左上角的那一块灰色里面的四个类（Dictionary、HashTable、Vector、Stack）是线程安全的，但是它们都是JDK的老的遗留类，现在基本都不怎么使用了，都有了对应的取代类。其中Map是用来代替图片中左上角的那个Dictionary抽象类（Map的官方文档里面有说明）。官方推荐使用Map接口来代替它。同样对于HashTable，官方推荐ConcurrentHashMap来代替。接着Vector可以用ArrayList替代。</li><li>图片最上面的粉红色部分一些具有某些特性的接口，中间的绿色层就是我们常用的一些容器类了。</li><li>最下方的一个整块都是java.util.concurrent包里面的类，按照包名我们就可以知道这个包里面的类都是用来处理Java编程中各种并发场景的，这个部分我现在暂时还没有接触到，等找到实习过后再来学习。所以博客后面的内容主要对中间绿色层的部分容器进行讲解。</li></ul><h3 id="对容器的分类"><a href="#对容器的分类" class="headerlink" title="对容器的分类"></a>对容器的分类</h3><ul><li>直接或间接实现Map接口的有：HashMap、HashTable、TreeMap、Sortedmap、LinkedHashMap、EnumMap、IdentityHashMap、WeakHashMap；</li><li>实现List接口的有：ArrayList，LinkedList，Vector；</li><li>实现Set接口的有：HashSet、LinkedHashSet、TreeSet；</li><li>实现Queue接口的有：PriorityQueue、LinkedList、ArrayQueue；</li></ul><h3 id="根据底层实现的数据结构分类"><a href="#根据底层实现的数据结构分类" class="headerlink" title="根据底层实现的数据结构分类"></a>根据底层实现的数据结构分类</h3><ul><li>底层以数组的形式实现：ArrayList、EnumMap、ArrayQueue；</li><li>底层以链表的形式实现：LinkedList、LinkedHashSet、LinkedHashMap；</li><li>底层以hash table(哈希表)的形式实现：HashMap、HashSet、LinkedHashMap、LinkedHashSet、WeakHashMap、IdentityHashMap；</li><li>底层以红黑树的形式实现：TreeMap、TreeSet；</li><li><p>底层以二叉堆的形式实现：PriorityQueue；</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2></li></ul><pre><code class="java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</code></pre><p>Collection中的操作方法：<a href="https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html#method_summary" target="_blank" rel="noopener">Interface Collection</a></p><p>从图片上我们可以得出容器主要分为两种类型，两个接口Collection与Map定义了两类不同的对象存储方式。<br>Collection接口是很多容器的根接口，从Collection可以衍生出很多容器，在Collection中的数据以元素的形式存在，一个Collection代表一组Object。说的更简单点，Collection就是普通的集合，相比于Map中每个元素是以键值对的形式存在<code>&lt;Object, Value&gt;</code>即Collection中一个元素就是一个Object, Map中一个元素就是一个<code>&lt;Object, Value&gt;</code>,感觉说的有点啰嗦了。</p><h3 id="List-Set-Map"><a href="#List-Set-Map" class="headerlink" title="List, Set, Map"></a>List, Set, Map</h3><p> 这三个接口都是实现了 Collection接口，三者主要的差别如下：</p><p><strong>List</strong>：链表，对元素的操作是有序的(怎么存的就怎么取出来，顺序不会乱)，元素可以重复，允许存储项的值为空。</p><pre><code class="java">public interface List&lt;E&gt; extends Collection&lt;E&gt;</code></pre><p>List的操作方法：<a href="https://docs.oracle.com/javase/7/docs/api/java/util/List.html#method_summary" target="_blank" rel="noopener">Interface List</a></p><p> <strong>Set</strong>: 集，类似于数学上集合的概念，也具有一些相似的性质，元素不按特定方式排序，不能有重复的元素，对集中成员的访问和操作是通过集中对象的引用进行的。</p><pre><code class="java">public interface Set&lt;E&gt; extends Collection&lt;E&gt;</code></pre><p>Set的操作方法：<a href="https://docs.oracle.com/javase/7/docs/api/java/util/Set.html#method_summary" target="_blank" rel="noopener">Interface Set</a></p><p> <strong>Queue</strong>：队列，就是数据结构中的队列，在List的基础上，对元素的增加和删除做了一些特殊的处理，添加元素添加到队列的尾部，删除元素从队列的头部删除，即先进先出，需要执行先进先出的动作时可以直接使用Queue接口就可以了。 </p><pre><code class="java">public interface Queue&lt;E&gt; extends Collection&lt;E&gt;</code></pre><p>Queue的操作方法：<a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#method_summary" target="_blank" rel="noopener">Interface Queue</a></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>我的理解是功能相当于C++中的Vector，是一个容量能够动态增长的动态数组。它继承了AbstractList，实现了List、RandomAccess, Cloneable, java.io.Serializable。<br>ArrayList是在Array的基础上，增加了一个自动扩容的方法，弥补了数组长度固定的不足，底层使用数组实现的。ArrayList的扩容机制是通过new一个新的容量更大的ArrayList，然后把元素赋值过去并丢弃旧的ArrayList，这也是ArrayList最主要的效率不高的地方。<br>ArrayList的操作不是线程安全的！一般在单线程中才使用ArrayList，而在多线程中一般使用Vector或者CopyOnWriteArrayList。</p><p> <strong>构造方法</strong>：</p><blockquote><p>(1) ArrayList()<br>构造一个空的数组，默认容量是 10;</p></blockquote><blockquote><p>(2) ArrrayList(int initialCapacity)<br>构造一个指定容量的空数组，当增加数据导致容量不足时，容量默认增加上次容量大小的一半;</p></blockquote><blockquote><p>(3) ArrayList(Collection&lt;? extends E&gt; c)<br>生成一个与括号内数组一样的另一个数组，括号内的数组能够继承生成后的数组。 </p></blockquote><p><strong>ArrayList 中常用的方法</strong>：</p><blockquote><p>add(E e):                     在数组末尾添加元素；<br>size():                           数组中实际元素个数，并不是数组容量；<br>add(int index, E e):    在数组指定位置添加元素；<br>clear():                         将数组中元素清空；<br>contains(E e):             判断数组中是否含有某个元素；<br>get(int index):             返回数组指定位置的元素；<br>indexOf(E e):              返回数组指定元素第一次出现的位置；<br>set(int index, E e):     替换数组指定位置的值；<br>remove(int index):     移除数组指定位置的元素；<br>remove(E e):              移除数组中第一次出现的指定元素；<br>addAll(Collection&lt;? extends E&gt; c):                     在数组末尾添加另一个数组 ；<br>addAll(int index, collection&lt;? extends E&gt; c):     在数组指定位置添加另一个数组 ；<br>removeAll(Collection&lt;?&gt;c):                                   将数组中属于数组 c 中的元素全部删除；</p></blockquote><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p> LinkedList 是一种基于链表实现的，继承自 AbstractSequentialList 接口，同时了还实现了 Deque, Queue 接口的数据结构。与普通List不同的是，LinkedList是一个双向链表，每一个节点是一个双向节点，即同时可以指向上一个节点也可以指向下一个节点。<br> ArrayList 也不是线程安全的！</p><p> <strong>LinkedList的操作方法</strong>：<br> <strong>add</strong></p><blockquote><p>boolean add(E e)：在链表后添加一个元素，如果成功，返回true，否则返回false；<br>void addFirst(E e)：在链表头部插入一个元素；<br>addLast(E e)：在链表尾部添加一个元素；<br>void add(int index, E element)：在指定位置插入一个元素。</p></blockquote><p><strong>remove</strong></p><blockquote><p>E remove()；移除链表中第一个元素；<br>boolean remove(Object o)：移除链表中指定的元素；<br>E remove(int index)：移除链表中指定位置的元素；<br>E removeFirst()：移除链表中第一个元素，与remove类似；<br>E removeLast()：移除链表中最后一个元素；<br>boolean removeFirstOccurrence(Object o)：移除链表中第一次出现所在位置的元素；<br>boolean removeLastOccurrence(Object o)：移除链表中最后一次出现所在位置的元素；</p></blockquote><p><strong>get</strong></p><blockquote><p>E get(int index)：按照下边获取元素；<br>E getFirst()：获取第一个元素；<br>E getLast()：获取第二个元素；</p></blockquote><p><strong>push、pop、poll</strong></p><blockquote><p>void push(E e)：与addFirst一样，实际上它就是addFirst；<br>E pop()：与removeFirst一样，实际上它就是removeFirst；<br>E poll()：查询并移除第一个元素；</p></blockquote><p><strong>peek</strong></p><blockquote><p>E peek()：获取第一个元素，但是不移除；<br>E peekFirst()：获取第一个元素，但是不移除；<br>E peekLast()：获取最后一个元素，但是不移除；</p></blockquote><p><strong>offer</strong></p><blockquote><p>boolean offer(E e)：在链表尾部插入一个元素；<br>boolean offerFirst(E e)：与addFirst一样，实际上它就是addFirst；<br>boolean offerLast(E e)：与addLast一样，实际上它就是addLast；</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。<br>看了网上挺多博客，都说HashSet是基于HashMap实现的，我开始就很疑惑，明明是继承自Set接口啊，怎么会是基于HashMap实现的呢。后来看了源码才知道HashSet在构造函数中实例化了一个HashMap实例来作为元素存储的容器，感兴趣的可以去找一下源码来读。来这儿又加深了自己对Java接口这个概念的理解，接口就是用来提供方法的。<br>既然HashSet是基于HashMap实现的，HashSet的很多方法也都是使用HashMap的方法来实现的了，这部分可以直接看后面的HashMap的介绍。<br>说到这儿又有点疑惑了，那么HashSet和HashMap相比又有什么区别嗯，不可能造两个完全一样的容器吧。仔细一想，两者的差别它们的名字的已经告诉我们了。一个是Set，一个是Map.前面提到，Set是不允许重复元素出现的，HashSet实现了Set接口，它不允许集合中出现重复元素。后来查阅了相关资料，发现两者除此之外还有一些其他的区别：</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td><strong>存储键值对</strong></td><td><strong>仅存储对象</strong></td></tr><tr><td>调用put（）向map中添加元素</td><td>调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table><p><strong>HashMap中元素形式：&lt;Object, value&gt;, HashSet中元素的形式：Object.</strong><br>具体的存储形式为：数据存储在HashMap的key中，value都是同一个默认值。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet继承自HashSet，唯一的区别是LinkedHashSet内部使用的是LinkHashMap。这样做的意义或者好处就是LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。LinkHashMap见本博客后面的内容。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet<e>,Cloneable,java.io.Serializable接口。一种基于TreeMap的NavigableSet实现。TreeSet与TreeMap的关系和HashSet与HashMap的关系类似，可类比理解。<br>TreeSet继承了AbstractSet抽象类，所以它是一个有序的set集合，且具有set的属性和方法。<br>TreeSet是基于TreeMap实现的，使用TreeMap作为元素容器，底层的操作也是通过TreeMap实现的，所以两者不同点：</e></p><ul><li>TreeSet和TreeMap非别实现Set和Map接口 </li><li>TreeSet只存储一个对象，而TreeMap存储两个对象Key和Value（仅仅key对象有序） </li><li>TreeSet中不能有重复对象，而TreeMap中可以存在。</li></ul><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>ArrayDeque类是<strong>双端队列</strong>的实现类，类的继承结构如下面，继承自AbastractCollection（该类实习了部分集合通用的方法，其实现了Collection接口），其实现的接口Deque接口中定义了双端队列的主要的方法，比如从头删除，从尾部删除，获取头数据，获取尾部数据等等。<strong>底层是通过数组实现的。</strong></p><p><strong>NOTE</strong>：ArrayDeque不是线程安全的，ArrayDeque不可以存取null元素。</p><p><strong>双端队列</strong>：双端队列，即可以同时在队列头和队列尾部进行增加删除的操作。</p><p>当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。（这个从底层实现分析）</p><p>此外呢，ArrayDeque有一些方法，扩容机制很特殊，以后再仔细研究。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map是Map层级结构中的根接口，维护键/值对，描述<strong>不重复</strong>的<strong>一对一</strong>的键到值的映射。<br>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。<br>即Map的元素为一个键值对接口：Entry&lt;Object, Value&gt;.</p><p>其接口为：</p><pre><code class="java">public interface Map&lt;K,V&gt;</code></pre><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>可以说是Map中最重要的一种结构了，是很多结构的实现基础。<br>HashMap继承自抽象类AbstractMap，抽象类AbstractMap实现了Map接口。</p><p>HashMap采用了链地址法，也就是使用数组+链表的方式解决哈希冲突。主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对，枝干是使用链表实现的，链表的节点也是一个Entry，包含一个key-value键值对。</p><p><img src="http://dengw.xyz/hexo-blog/180330/dgIfbCKL1H.png" alt="HashMap的整体结构"></p><p><strong>很重要</strong>：</p><ul><li>不管hashcode还是Equal的对象都是键，即Object</li><li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</li><li>HashMap非线程安全，可以使用使用ConcurrentHashMap替代。</li></ul><p>一篇非常好的关于HashMap的讲解文章：<a href="https://www.cnblogs.com/chengxiao/p/6059914.html#t2" target="_blank" rel="noopener">HashMap实现原理及源码分析</a></p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>前面讲TreeSet的时候就有提到TreeSet是基于 TreeMap实现的，现在就具体的讲讲TreeMap。</p><p>TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap由于实现了TreeMap的接口则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 ，<strong>并且是有序的</strong>。<br>在算法上，TreeMap的实现是红黑树算法的实现的，所以要想学习TreeMap原理的话要写学习一下红黑树相关的知识。</p><p><strong>TreeMap特点：</strong></p><blockquote><p>TreeMap是非线程安全的。</p></blockquote><blockquote><p>TreeMap是用键来进行升序顺序来排序的。通过Comparable 或 Comparator来排序。</p></blockquote><blockquote><p>TreeMap是SortedMap接口的基于红黑树的实现。此类保证了映射按照升序顺序排列关键字， 根据使用的构造方法不同，可能会按照键的类的自然顺序进行排序，或者按照创建时所提供的比较器（自定义）进行排序。</p></blockquote><blockquote><p>和HashMap一样，如果插入重复的元素，后面的元素会覆盖前面的。 </p></blockquote><blockquote><p>键不可以为null（如果比较器对null做了处理，就可以为null）,但是值可以为null。 </p></blockquote><p>由于现在有些赶，对TreeMap也不是很深入，这里贴一篇关于<a href="https://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="noopener">TreeMap</a>的博客，讲解的非常清楚，等这段时间面试完再来补。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>inkedHashMap不仅像HashMap那样对其进行基于哈希表和单链表的Entry数组+ next链表的存储方式，而且还结合了LinkedList的优点，为每个Entry节点增加了前驱和后继，并增加了一个为null头结点，构造了一个<strong>双向循环链表</strong>。<strong>即主干同样是一个数组，而枝干是一个双向链表实现的，并且该链表是有序的，可以按元素插入顺序或元素最近访问顺序(LRU)排列。</strong></p><p><img src="http://dengw.xyz/hexo-blog/180330/h2b0eH8C1H.png" alt="LinkedHashMap具体结构"></p><p>看一下LinkedHashMap的构造方法：</p><pre><code class="java">public LinkedHashMap(int initialCapacity, float loadFactor) {          super(initialCapacity, loadFactor);          accessOrder = false;  }</code></pre><blockquote><p>accessOrder若为false，遍历双向链表时，是按照插入顺序排序。<br>accessOrder若为true，表示双向链表中的元素按照访问的先后顺序排列，最先遍历到（链表头）的是最近最少使用的元素。</p></blockquote><p>因此在插入值的时候，相比HashMap，还有一些额外的操作来维护链表中元素存在的顺序。</p><p>我这里也只有大概介绍一下，同样贴一篇非常好的博客：<a href="https://blog.csdn.net/seu_calvin/article/details/52684341" target="_blank" rel="noopener">LinkedHashMap源码详解</a>.</p><p>待续……</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity生命周期详解</title>
      <link href="/2018/03/07/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/07/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="关于Activity"><a href="#关于Activity" class="headerlink" title="关于Activity"></a>关于Activity</h3><p>在Android应用程序里，一个Activity就是一个用户界面。用户与程序的交互就是通过Activity来实现的，可以看成网站的页面。主Activity是程序启动的入口。应用程序成功启动之后，呈献给用户的第一个界面，即为该程序的主Activity。</p><h3 id="关于任务栈"><a href="#关于任务栈" class="headerlink" title="关于任务栈"></a>关于任务栈</h3><p>Android中是使用任务（task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个任务栈也叫做返回栈。在默认情况下，当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而当我们按下 back 键或调用 finish() 方法去销毁一个活动时，处于栈顶的任务就会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。</p><h3 id="Activity的四种状态"><a href="#Activity的四种状态" class="headerlink" title="Activity的四种状态"></a>Activity的四种状态</h3><p>Android 的虚拟机(VM)是使用基于栈(Stack based) 管理，主要有四种状态：</p><p><strong>Active (运行状态)：</strong><br>使用者启动应用程序或Activity 后，Activity 运行中的状态，可与用户之间进行交互，此时当前Activity位于栈顶。<br>需要注意的是，在Android 平台上，同一个时刻只会有一个Activity 处于活动(Active)或运行(Running)状态。其他的Activity 都处于未启动(Dead)、停止(Stopped)、或是暂停(Pause)的状态。</p><p><strong>Paused (暂停状态)</strong><br>当Activity 暂时暗下来，退到背景画面的状态。<br>当使用Toast、AlertDialog或电话呼入时，都会让原本运行的Activity 退到背景画面。新出现的Toast、AlertDialog 等界面元件盖住了原来的Activity 画面。Activity 处在”Paused”状态时，使用者无法与原Activity 互动。</p><p><strong>Stopped (停止状态)</strong><br>Activity完全被另一个Activity所覆盖，则其状态为Stopped。<br>有其他Activity 正在执行，而当前Activity 已经离开屏幕，不再动作的状态。通过长按”Home”钮，可以叫出所有处于”Stopped”状态的应用程序列表。在“Stopped”状态的Activity，还可以通过“Notification”来唤醒。</p><p><strong>Dead (销毁状态)</strong><br>Activity 尚未被启动、已经被手动终止，或已经被系统回收的状态。<br>要手动终止Activity，可以在程序中调用“finish”函数，若是被系统回收，可能是因为内存不足，因此系统根据内存不足时的回收规则，将处于“Stopped”状态的Activity 所占用的内存回收。</p><h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><p>每个活动（Activity）都处于某个状态。对于开发者来说，是无法控制其应用程序处于某个状态的，这些均由系统来完成。但当一个活动状态发生改变的时，开发者可以通过调用onXXX()方法，获取相关的通知信息。</p><p>完整的Activity 生命周期由”Create”状态开始，由”Destroy”状态结束。建立<br>(Create)时分配资源，销毁(Destroy)时释放资源。</p><p><img src="http://dengw.xyz/hexo-blog/180330/d3jBcAHbj2.png" alt="Activity生命周期流程图"></p><ul><li><strong>onCreate :</strong> 当活动第一次启动时触发该方法。该方法是在Activity被创建时回调，它是生命周期第一个调用的方法，我们在创建Activity时一般都需要重写该方法，然后在该方法中做一些初始化的操作，如通过setContentView设置界面布局的资源，初始化所需要的组件信息等。 </li><li><strong>onStart :</strong> 此方法被回调时表示Activity正在启动，所属活动将被展现给用户，此时Activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。可以简单理解为Activity已显示而我们无法看见摆了。 </li><li><strong>onResume :</strong> 当一个活动和用户发生交互的时候，触发该方法。当此方法回调时，则说明Activity已在前台可见，可与用户交互了（处于前面所说的Active/Running形态），onResume方法与onStart的相同点是两者都表示Activity可见，只不过onStart回调时Activity还是后台无法与用户交互，而onResume则已显示在前台，可与用户交互。当然从流程图，我们也可以看出当Activity停止后（onPause方法和onStop方法被调用），重新回到前台时也会调用onResume方法，因此我们也可以在onResume方法中初始化一些资源，比如重新初始化在onPause或者onStop方法中释放的资源。 </li><li><strong>onPause :</strong> 当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，触发该方法。此方法被回调时则表示Activity正在停止（Paused形态），一般情况下onStop方法会紧接着被回调。但通过流程图我们还可以看到一种情况是onPause方法执行后直接执行了onResume方法，这属于比较极端的现象了，这可能是用户操作使当前Activity退居后台后又迅速地再回到到当前的Activity，此时onResume方法就会被回调。当然，在onPause方法中我们可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示——onPause方法执行完成后，新Activity的onResume方法才会被执行。 </li><li><strong>onStop :</strong> 当一个活动不再需要展示给用户的时候，触发该方法。一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖（Stopped形态），此时Activity不可见，仅在后台运行。同样地，在onStop方法可以做一些资源释放的操作（不能太耗时）。如果内存紧张，系统会直接结束这个活动，而不会触发onStop 方法，所以保存状态信息是应该在onPause时做，而不是onStop时做。</li><li><strong>onRestart</strong> : 当处于停止状态的活动需要再次展现给用户的时候，触发该方法，表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。 </li><li><strong>onDestroy</strong> :当一个活动不再需要展示给用户的时候，触发该方法。此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。 </li></ul><p>以上关于各个阶段的状态详细说明大部分来自于<a href="http://blog.csdn.net/javazejian/article/details/51932554" target="_blank" rel="noopener">Android之Activity生命周期浅析(一)</a>，并在其基础上做了一些小小的补充。</p><p>以上7个方法中除了onRestart()方法，其他的都是两两相对的，从而又可以将活动分为3个生存期。</p><p><strong>完整生命期</strong>：活动在onCreate()方法到onDestory()方法之间经历的时期。</p><p>第一次启动Activity：依次执行以下方法：onCreate() -&gt; MainActivity created  -&gt; onStart() -&gt; MainActivity started -&gt; onResume() -&gt; MainActivity actived，进入活动状态。</p><p>结束Activity：依次执行以下方法：onPause () -&gt; MainActivity paused -&gt;  onStop () -&gt; MainActivity stoped -&gt;  onDestory()  -&gt;  MainActivity killed。</p><ul><li>Activity由活动状态转为暂停状态。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见。但已失去了焦点，故不可与用户交互。在极特殊的情况下，Android将会杀死一个暂停的Activity，来为活动的Activity提供充足的资源；</li><li>Activity被停止，变为完全隐藏，失去焦点，并且不可见。但是系统将仍在内存中保存它所有的状态和信息；</li><li>Activity被杀死，转为销毁状态。Activity结束，退出当前应用程序。</li></ul><p><strong>可见生存期</strong>：活动在onStart()方法到onStop()方法之间经历的时期。<br>当Activity 运行到“Start”状态时，就可以在屏幕上看到该Activity。相反当Activity 运行到“Stop”状态时，此Activity 就会从屏幕上消失。当使用者按下Back 按钮回到上一个Activity 时，会先到Restart 状态，再到一般的Start 状态。</p><p><strong>前台生存期</strong>：活动在onResume()方法到onPause()方法之间经历的时期。<br>使用者能否直接存取屏幕（Resume/Pause），当有个Toast、AlertDialog、短信、电话等信息发生时，原来的Activity 会处于“Pause”状态，暂时放弃直接存取屏幕的能力，被中断到背景去，将前景交给优先级高的事件。当这些优先级高的事件处理完后，Activity 就改进入”Resume”状态，此时又直接存取屏幕。</p><h3 id="一些特殊情况下-Activity-的生命周期变化"><a href="#一些特殊情况下-Activity-的生命周期变化" class="headerlink" title="一些特殊情况下 Activity 的生命周期变化"></a>一些特殊情况下 Activity 的生命周期变化</h3><p>这些情况在开发的时候也会遇得到，但是更多的可能是面试中会问到，很考验开发者对Activity生命周期的掌握情况，具体的包括：</p><ul><li>按下 Home 键当前 Activity 的生命周期变化；</li><li>按下 back 键当前 Activity 的生命周期变化；</li><li>息屏时当前 Activity 的生命周期变化；</li><li>启动一个新的透明 Activity 时当前 Activity 的生命周期变化；</li><li>旋转屏幕未设置 configureChanges 参数时当前 Activity 的生命周期变化；</li><li>旋转屏幕设置了 configureChanges 参数时当前 Activity 的生命周期变化；</li></ul><p>上面这些问题我们通过一个实际的demo，通过生命周期函数打印日志来进行逐一验证；</p><h4 id="按下-Home-键当前-Activity-的生命周期变化"><a href="#按下-Home-键当前-Activity-的生命周期变化" class="headerlink" title="按下 Home 键当前 Activity 的生命周期变化"></a>按下 Home 键当前 Activity 的生命周期变化</h4><p><img src="http://dengw.xyz/hexo-blog/181002/a3L03Ad13G.png" alt="enter image description here"></p><p>可以看到点击 Home 键当前 Activity 会调用 <strong>onPause &gt; onSaveInstanceState &gt; onStop</strong> 函数，并没有调用 onDestroy 方法，说明当前活动没有被销毁，只是不再处于栈顶了。这个时候继续看一下再进入该 Activity 时该  Activity 的生命周期变化：<br><img src="http://dengw.xyz/hexo-blog/181002/EJ85jIL8fc.png" alt="enter image description here"></p><p>可以看到再进入该 Activity 依次调用 <strong>onRestart &gt; onStart &gt; onResume</strong> 方法，结合上面说的，我们总结按下 Home 键时当前 Activity 依然位于任务栈中，只是不在位于任务栈的栈顶。</p><h4 id="按下-back-键当前-Activity-的生命周期变化"><a href="#按下-back-键当前-Activity-的生命周期变化" class="headerlink" title="按下 back 键当前 Activity 的生命周期变化"></a>按下 back 键当前 Activity 的生命周期变化</h4><p>同样的，先使用 demo 试一下，然后根据结果解释；<br><img src="http://dengw.xyz/hexo-blog/181002/3lEmJ4LbcJ.png" alt="enter image description here"><br><img src="http://dengw.xyz/hexo-blog/181002/le7k0Bb5kA.png" alt="enter image description here"></p><p>可以看到当我们在 Activity2 中按下 Back 键返回 Activity1 的时候，Activity2 会调用 <strong>onPause &gt; onStop &gt; onDestroy</strong> 方法，也就是说 Activity2 会被销毁，直接从任务栈中移除掉。正常情况下一个活动直接被销毁除了上面这种情况，另外一种就是直接在一个活动中调用 <strong>finish()</strong> 方法。</p><h4 id="息屏时当前-Activity-的生命周期变化"><a href="#息屏时当前-Activity-的生命周期变化" class="headerlink" title="息屏时当前 Activity 的生命周期变化"></a>息屏时当前 Activity 的生命周期变化</h4><p>先贴一下运行结果：<br><img src="http://dengw.xyz/hexo-blog/181002/iGkdehdmgj.png" alt="enter image description here"></p><p>方法调用过程为：<strong>onPause &gt; onSaveInstanceState &gt; onStop</strong></p><p>然后再进入当前Activity，方法调用过程为：<strong>onRestart &gt; onStart &gt; onResume</strong><br><img src="http://dengw.xyz/hexo-blog/181002/9EHch5Aima.png" alt="enter image description here"></p><h4 id="启动一个新的透明-Activity-时当前-Activity-的生命周期变化"><a href="#启动一个新的透明-Activity-时当前-Activity-的生命周期变化" class="headerlink" title="启动一个新的透明 Activity 时当前 Activity 的生命周期变化"></a>启动一个新的透明 Activity 时当前 Activity 的生命周期变化</h4><p>当我们给 Acticity2 的属性设置如下的时候，可以让 Acticity2 完全透明：</p><pre><code>&lt;activity    android:name=&quot;.Main2Activity&quot;    android:theme=&quot;@android:style/Theme.Translucent&quot;&gt;&lt;/activity&gt;</code></pre><p>这样当我们从 Activity1 启动 Activity2，然后观察 Activity1 的生命周期变化，先看一下结果；<br><img src="http://dengw.xyz/hexo-blog/181002/A4E8KG2kK5.png" alt="enter image description here"><br><img src="http://dengw.xyz/hexo-blog/181002/bIfHL70hAE.png" alt="enter image description here"></p><p>可以看到调用过程为 <strong>onPause &gt; onSaveInsanceState</strong>，没有调用 onStop 方法，这里我们可以这样理解，因为  Activity2 被设置为透明的，这样跳转到  Activity2 时 Activity1 依然可见，所以不会调用 Activity1 的 onStop 方法，因为一个活动调用 onStop 方法后就不再可见。</p><h4 id="旋转屏幕未设置-configureChanges-参数时当前-Activity-的生命周期变化"><a href="#旋转屏幕未设置-configureChanges-参数时当前-Activity-的生命周期变化" class="headerlink" title="旋转屏幕未设置 configureChanges 参数时当前 Activity 的生命周期变化"></a>旋转屏幕未设置 configureChanges 参数时当前 Activity 的生命周期变化</h4><p>默认是设置 configureChanges 参数的，我们先看一下默认情况下的生命周期：<br><img src="http://dengw.xyz/hexo-blog/181002/aFFe2B0GE9.png" alt="enter image description here"><br><img src="http://dengw.xyz/hexo-blog/181002/ACfm7f9mK9.png" alt="enter image description here"></p><p>从结果中我们可以看到，当旋转屏幕并且 configureChanges 为默认值的时候，当前活动的生命周期变化为：<br><strong>onPause &gt; onSaveInstanceState &gt; onStop &gt; onDestroy &gt; onCreate &gt; onStart &gt; onRestoreInstanceState &gt; onResume</strong></p><p>从这些方法中不想归纳出当前活动是被销毁后再重新创建了一个新的活动，即旋转前和旋转后看到的其实不是同一个活动，之前的活动已经从任务栈中出栈然后新建了一个新的活动加入到任务栈中。这个很好理解嘛，旋转前和旋转后活动的宽和高发生了变化，相当于系统配置已经发生了变化，这样活动当然会被重建。</p><h4 id="旋转屏幕设置了-configureChanges-参数时当前-Activity-的生命周期变化"><a href="#旋转屏幕设置了-configureChanges-参数时当前-Activity-的生命周期变化" class="headerlink" title="旋转屏幕设置了 configureChanges 参数时当前 Activity 的生命周期变化"></a>旋转屏幕设置了 configureChanges 参数时当前 Activity 的生命周期变化</h4><p>通过 configureChanges 参数可以让活动在改变系统配置的时候不被重建，比如我们想让 Activity2 在改变系统配置的时候不被重建，可以进行如下配置：</p><pre><code>&lt;activity    android:name=&quot;.Main2Activity&quot;    android:configChanges=&quot;orientation|screenSize&quot;&gt;&lt;/activity&gt;</code></pre><p>调用情况：<br><img src="http://dengw.xyz/hexo-blog/181002/HkeG14aefd.png" alt="enter image description here"></p><p>可以看到只调用了 onConfigurationChanged 方法，说明没有重建过程了，onConfigurationChanged 方法需要我们重写。</p><pre><code class="java">@Overridepublic void onConfigurationChanged(Configuration newConfig){    super.onConfigurationChanged(newConfig);}</code></pre><h3 id="onSaveInstanceState-和onRestoreInstanceState-调用时机"><a href="#onSaveInstanceState-和onRestoreInstanceState-调用时机" class="headerlink" title="onSaveInstanceState()和onRestoreInstanceState()调用时机"></a>onSaveInstanceState()和onRestoreInstanceState()调用时机</h3><p>在上面的讨论中我们可以看到，有的时候会调用单独调用 onSaveInstanceState() 方法，有的时候onSaveInstanceState()和onRestoreInstanceState() 会成对使用，那么我们再总结一下这两个方法的调用时机。</p><h4 id="onSaveInstanceState-的调用时机"><a href="#onSaveInstanceState-的调用时机" class="headerlink" title="onSaveInstanceState() 的调用时机"></a>onSaveInstanceState() 的调用时机</h4><p>当 activity 有可能被系统回收的情况下会调用 onSaveInstanceState() 方法。需要注意的是有可能，如果是已经确定会被销毁，比如用户按下了返回键，或者调用了finish()方法销毁activity，则 onSaveInstanceState 不会被调用。或者也可以说，此方法只有在activity被异常终止的情况下会被调用。</p><p>总结一下，onSaveInstanceState() 会在以下情况被调用：<br>1、当用户按下HOME键时。<br>2、从最近应用中选择运行其他的程序时。<br>3、按下电源按键（关闭屏幕显示）时。<br>4、从当前activity启动一个新的activity时。<br>5、屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。</p><h4 id="onRestoreInstanceState-的调用时机"><a href="#onRestoreInstanceState-的调用时机" class="headerlink" title="onRestoreInstanceState() 的调用时机"></a>onRestoreInstanceState() 的调用时机</h4><p>onRestoreInstanceState(Bundle savedInstanceState) 方法只有在 activity 确实是被系统回收，重新创建 activity 的情况下才会被调用。如我们上面讨论的默认情况下的旋转屏幕这种情况，在这里 onRestoreInstanceState 被调用，是因为屏幕切换时原来的 activity 确实被系统回收了，又重新创建了一个新的 activity。所以我们可以得出如下的结论，如果 onRestoreInstanceState 被调用了，则页面必然被回收过，则 onSaveInstanceState 必然被调用过。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>项目地址：<a href="https://github.com/duang0626/CodeCollection/tree/master/demo/LifeCycleDemo" target="_blank" rel="noopener">github-duang0626: LifeCycleDemo</a></p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>彩虹糖的艺术</title>
      <link href="/2012/09/14/%E5%BD%A9%E8%99%B9%E7%B3%96%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2012/09/14/%E5%BD%A9%E8%99%B9%E7%B3%96%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>高中的时候写的，感觉很中二。不过现在让我写肯定写不出来了，文字功底退化了。</p><p>彩虹糖，正如它的名字一样，彩虹，是要经历风雨之后才能看到的。吃彩虹糖也是这样，刚放到嘴里的时候，那个酸味，简直是不能用语言来形容的，如果你一次性的吃了几颗，那么恭喜你，可能你的眼泪都要出来了。但是，慢慢的，慢慢的，酸味会慢慢的减淡，取而代之的一丝的甜味，时间一点一点的过去，甜味会越来越多，只到最后，完完全全地融入的你的舌尖。     回头想想，我们的高中又何尝不是，整个高中就是吃彩虹糖，后面的日子就是尝彩虹糖，这是一个有时间先后的过程，你不可能只尝后面的甜味，而直接跳过前面的一个过程，所以，好好的静下来，学会享受这一过程。    其实，在我们刚吃彩虹糖的时候，即使很酸，但只要你慢慢适应，久而久之，你也会享受酸带给你的乐趣。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
